<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode+wsl+c++开发环境.md]]></title>
    <url>%2F2019%2F04%2F17%2Fvscode%2Bwsl%2Bc%2B%2B%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用场景 操作步骤 开启 wsl，并配置为 vscode 默认终端 通过bat执行bash命令 改写 json 使用说明 make 工程 配置 go 使用场景 利用 wsl 实现在 windows 系统下进行 linux 环境开发 操作步骤开启 wsl，并配置为 vscode 默认终端 网上很多方法，这里不赘述 通过bat执行bash命令 如果装上子系统后，可以在 bash 下执行命令，但是如果想在windows 系统下做开发的话，不能直接执行 bash 命令 可以通过 cmd 批处理命令来调用 bash 并执行 shell 命令，使用方法如下: 1C:\Users\M-Kepler&gt;bash -c " ls ~/" 可以自己写个批处理命令，来实现 windows 下用 vscode 写代码，然后在 wsl 下编译运行代码，新建make.bat，内容如下 123set cpp_path=%1set "cpp_path=%cpp_path:\=/%"bash -c "rm -f %2 &amp;&amp; g++ --std=c++11 -g %cpp_path% -o %2 -lpthread &amp;&amp; clear &amp;&amp; time %2" 改写 json task.json下面注释部分按照实际情况改写 12345678910111213141516171819202122232425262728293031323334&#123; "version": "2.0.0", "tasks": [ &#123; "label": "make", // ctrl+ shift+b 是显示的名称 "command": "$&#123;workspaceFolder&#125;/.vscode/make.bat", // make.bat的路径 "args": [ // 传递给make.bat的参数 %1和%2 "$&#123;relativeFile&#125;", // 当前打开文件的路径 "./debug/$&#123;fileBasenameNoExtension&#125;.out" // 编译后文件输出路径 ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": [ "relative", "$&#123;workspaceRoot&#125;" ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ], "sourceFileMap": &#123; &#125;&#125; launch.json下面注释部分按照实际情况改写 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb)", "type": "cppdbg", "request": "launch", "program": "$&#123;fileBasenameNoExtension&#125;.out", "args": [ "test.log", "100" ], "stopAtEntry": true, // 设为true时程序将暂停在程序入口处 "cwd": "/mnt/f/workspaces/c++/debug", // 调试程序时的工作目录 "environment": [], "externalConsole": true, "internalConsoleOptions":"openOnSessionStart", "sourceFileMap": &#123; "/mnt/f/workspaces/c++/":"$&#123;workspaceFolder&#125;" // 路径映射，修改路径为实际路径 &#125;, "windows": &#123; "MIMode": "gdb", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125;, "pipeTransport": &#123; "pipeCwd": "", "pipeProgram": "c:\\Windows\\System32\\bash.exe", "pipeArgs": [ "-c" ], "debuggerPath": "/usr/bin/gdb" &#125; &#125; ]&#125; 使用说明 一键 F5 编译运行编译的时候实际就是通过 cmd 去执行 bash 命令，上面的例子中是先把 debug 下的 .out 删除，然后编译运行，可以直接在 vscode 中看到运行结果 make 工程 大点的工程都有 makefile，方法和上面的一样，只要改一下 make.bat就行了1bash -c "cd src &amp;&amp; make clean &amp;&amp; make %1" 配置 go 可以直接在上面的 json 上修改就行了 make.bat 1bash -c "go run %1 task.json 123456789101112131415161718192021222324252627282930313233&#123; "version": "2.0.0", "tasks": [ &#123; "label": "go", // 显示 "command": "$&#123;workspaceFolder&#125;/.vscode/make.bat", // make.bat路径 "args": [ "/mnt/f/workspaces/go/$&#123;relativeFile&#125;" // make.bat 的入参 ], "problemMatcher": &#123; "owner": "go", "fileLocation": [ "relative", "$&#123;workspaceRoot&#125;" ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ], "sourceFileMap": &#123; &#125;&#125; launch.json 123456789101112131415161718192021222324252627282930313233&#123; "version": "2.0.0", "tasks": [ &#123; "label": "go", "command": "$&#123;workspaceFolder&#125;/.vscode/make.bat", "args": [ "$&#123;relativeFile&#125;" // make.bat的参数%1 ], "problemMatcher": &#123; "owner": "go", "fileLocation": [ "relative", "$&#123;workspaceRoot&#125;" ], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;, "group": &#123; "kind": "build", "isDefault": true &#125; &#125; ], "sourceFileMap": &#123; &#125;&#125;]]></content>
      <categories>
        <category>开发周边</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>go</tag>
        <tag>wsl</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Segment fault]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Segment%20fault%2F</url>
    <content type="text"><![CDATA[重现 功能描述把 test.log 文件每一行按照 , 进行切片，将一行中的所有分片存放到 string 数组中 样例 test.log 中有很多行如下字符串 1home,m_kepler,project 目的是按照 , 切割，把子串存放到 string 数组中 1234string strTmp[3];strTmp[0] = &quot;home&quot;strTmp[1] = &quot;m_kepler&quot;strTmp[2] = &quot;project&quot; 出错的代码这里不用 strtok 是因为 ,, 也要算一个数据 123456789101112131415161718192021fstream test;char delim[] = ",";string strLine;string szstrTmp [3];test.open("./debug/test.log", ios::binary | ios::in);if(!test) perror("open");while(getline(test, strLine))&#123; int i = 0; // error1 char *orgstr = strdup(strLine.c_str()); // error2 for (token = strsep(&amp;orgstr, delim); token != NULL; token = strsep(&amp;orgstr, delim)) &#123; szstrTmp[i] = token; i++; &#125; free(orgstr);&#125;return 0; 分析 像下面这样把两个循环条件才出来，运行报错 Segmentation fault (core dumped) 12345678910string szstrTmp[3];while(getline(test,line))&#123; int j =0; for(int i =0; i &lt; 10; i++) &#123; szstrTmp[j] = "aaaa"; // gdb 调试报错此行 j++; &#125;&#125; 在 while 循环中使用 strdup，运行报错 munmap_chunk(): invalid pointer 1234567891011string szstrTmp[3];while(getline(test, line))&#123; int i = 0; char *orgstr = strdup(line.c_str()); for (token = strsep(&amp;orgstr, delim), i = 0; token != NULL, i != 3; token = strsep(&amp;orgstr, delim), i++) &#123; szstrTmp[i] = token; &#125; free(orgstr); // gbd 调试报错在此行&#125; 修复 不使用 strdup 、for 循环里多个条件限制 修复后的代码 12345678910111213141516171819202122232425fstream test;int i = 0; // ++++++char delim[] = ",";string strLine;string szstrTmp [3];test.open("./debug/test.log", ios::binary | ios::in);if(!test) perror("open");while(getline(test, strLine))&#123; // int i = 0; // error1 // ------ // char *orgstr = strdup(strLine.c_str()); // error2 // ------ char *orgstr = const_cast&lt;char*&gt;(strLine.c_str()); // for (token = strsep(&amp;orgstr, delim), i = 0; token != NULL; token = strsep(&amp;orgstr, delim)) // ------ for (token = strsep(&amp;orgstr, delim), i = 0; token != NULL, i &lt; 3; token = strsep(&amp;orgstr, delim), i++) // ++++++ &#123; szstrTmp[i] = token; // i++; // ------ &#125; // free(orgstr); // ------&#125;return 0;]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[quote test Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
</search>
