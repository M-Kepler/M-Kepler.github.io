- [编码注意事项](#编码注意事项)
  - [基础问题](#基础问题)
  - [INT 边界值的问题](#int-边界值的问题)
  - [数组](#数组)
  - [`vector`](#vector)
  - [`matrix`](#matrix)
  - [`map`](#map)
  - [`priority_queue`](#priority_queue)
  - [链表](#链表)
  - [二叉树](#二叉树)
- [其他](#其他)

# 编码注意事项

## 基础问题

- `ERROR: out-of-line declaration of a member must be a definition [-Wout-of-line-declaration]`

  直接把类成员函数复制过去，然后写逻辑，还没把 `后面的分号` 去掉

- 如果 A 非空返回 A，如果 B 非空，返回 B

  ```cpp
  // 【注意点一】 两个链表随意一个为空都可以返回
  if (!llist1 || !llist2)
  {
      return llist1 ? llist1 : llist2;
  }
  ```

- 不要用同名变量。。。如果用了又不初始化，会出现奇奇怪怪的事情，比如 [202. 快乐数](https://leetcode-cn.com/problems/happy-number/description/)

- [`isalnum()` 判断字符串是否属于 `[a-zA-Z0-9]`](https://www.cnblogs.com/r1-12king/p/13161762.html)

- 容器构造

  ```cpp
  // 通过拷贝构造函数来初始化对象 s3，以下写法都可以
  string s = "huangjinjie";

  string s3 = s2;
  string s3_1(s2.begin(), s2.end());

  // 反向构造，即翻转
  string s3_1_reverse(s2.rbegin(), s2.rend());
  string s3(s2);
  ```

- 初始化报错 `variable-sized object may not be initialized` 数组的内存大小未知

  数组是连续的内存，如果在函数里动态的创建的话，那么就没有办法保证和检测到如此多的连续的内存空间。所以数组的空间是在程序启动时就已经分配好

  ```cpp
  // ERROR: 不能用 nums.size() 作为数组长度
  int dp[nums.size()] = {0};

  // OK: 解决方法也简单粗暴，换用 vector 就好了
  vector<int> dp(nums.size());
  ```

- 同时遍历两个变量

  ```cpp
  vector<int> vec(10);

  for (int i = 0, j = vec.size() - 1; i < j; i++, j--)
  {
      if (vec[i] != vec[j])
          return false;
  }
  return true;
  ```

## INT 边界值的问题

- 有些题目的用例会刚好卡 int 的范围 `-2^31 <= val <= 2^31-1`，此时解题中如果需要进行大小比对，就很难找到一个最小的初始值，以前都是用 `INT_MIN、INT_MAX` 的

  ```cpp
  #include <limit.h>

  // int min_val = INT_MAX;
  // int max_val = INT_MIN;
  // 如果输入限定是 int 类型的话，可以用 LONG_MIN
  long min_val = LONG_MIN;
  ```

## 数组

- 用二维数组作为形参时，第一维的大小可以省略，但第二维的大小是不能省，必须和实参数组第二维的大小一致。

  ```cpp
  void func(int array[ ][4]);
  ```

## `vector`

- 分割 vector

  [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

  ```cpp
  /* 用到的是 vector 的拷贝构造函数重新构造一个 vector */
  // 用括号和大括号都可以
  return vector<int>{preSum.begin() + 1, preSum.end()};

  /* 分割序列 */
  vector<int>::iterator index = find(inorder.begin(), inorder.end(), key);
  vector<int> leftInorder(inorder.begin(), index);
  vector<int> rightInorder(index + 1, inorder.end());
  ```

- 可以通过 `==` 比对两个 `vector`

- `end()` 指向 `【最后一个字符的下一个位置】`

  - STL 算法等适配容器的函数都是直接传入 `end()`，比如 `reverse(s.begin(), s.end());`

  - 如果自己想用迭代器指向最后一个元素，需要 `auto end = s.end() -1;`

- `size_of()` 的无符号整型与有符号整型比较的坑

  `runtime ERROR: addition of unsigned offset to xxxxx overflowed to yyyyy (stl_vector.h)`

  ```cpp
  // ERROR: 负数的 int 类型与 unsigned int 类型 比对
  int right = -1
  while (right < nums_size() - 1) {}

  // 这样 size_t 类型的 i 是没事的
  // for (size_t i = 0; i < height.size(); i++)


  // ERROR: size_t 类型的变量做自减操作，还和整型比较
  // 因为后面有 -- 操作，无符号整数与整数相减，直接 overflowed 了

  // for (size_t i = nums.size() - 1; i >= 0; i--) {}

  // OK
  for (int i = nums.size() - 1; i >= 0; i--) {}
  ```

- `runtime ERROR: applying non-zero offset 16 to null pointer (stl_vector.h)`

  使用 vector 没初始化就直接通过 `[]` 操作符进行访问导致报错

  ```cpp
  // vector<int> test; // ERROR
  vector<int> test(nums.size()); // OK

  test[88] = 12;
  ```

## `matrix`

- 需要加个空格

  ```cpp
  // 编译警告说 >> 是右移符号，建议加个空格
  // vector<vector<int>> test;

  vector<vector<int> > test;
  ```

- 创建一个矩阵

  ```cpp
  /**
   * 创建一个 v 行 s 列的矩阵，默认值为 0
   *
   * 记得 vector 有这种创建方法 `vector<int> vec(10, 1);` 吧
   * 创建一个包含 10 个 int 类型元素的 vector，元素初始值为 1
   *
   * 只是这里可能是个匿名的？ vector<int>(s);
   */
  vector<vector<int>> dp(v, vector<int>(s));

  // 创建一个和 matrix 一样大小的矩阵
  int row = matrix.size();
  int col = matrix[0].size();
  vector<vector<int>> result(row, vector<int>(col));

  // 由vector实现的二维数组，可以通过resize()的形式改变行、列值
  vector<vector<int>> matrix(v);
  for (int i = 0; i < matrix.size(); i++)
  {
      matrix[i].resize(s);
  }
  ```

## `map`

- `map.count(key)` 可以快速判断是否存在某个键，就不用 `map.find(key) != map.end()` 了

- `unordered_map` 通过下标访问 `map[key]` 的时候，如果 key 不存在，C++ 会自动创建这个 key，并赋值为 0

## `priority_queue`

求 `Top K 【大】` 问题，用的是 `【小】根堆`

```cpp
#include <queue>

// less: 堆里的元素【更小】，构建的是大根堆（【默认是大根堆】）
priority_queue<int> pq;

// greater: 堆里的元素更大，构建的是小根堆
// 定义元素为 int 类型，用 vector 来装这些元素的小根堆
priority_queue<int, vector<int>, greater<int>> pq;
```

## 链表

- 遍历链表

  ```cpp
  // 不设置头节点，直接循环遍历所有节点
  ListNode *currNode = llist;
  while (currNode) {
      currNode = currNode->next;
  }

  // 设置头节点
  ListNode *headNode = new ListNode(0, llist);
  // 临时节点，用于遍历链表
  ListNode *trvalNode = headNode;
  while (trvalNode->next) {
      trvalNode = trvalNode->next;
  }

  ```

- 移动 K 个节点

  好理解，因为你是先判断了 while 条件是否成立的，所以如果是 `while (k--)`，这是指针先移动之后 k 再减一，那么就会移动 k == 3、k == 2、k == 1 三次

  所以移动的是链表首节点指针，则指向了【头节点后】的第三个节点（即第四个节点）；如果移动的是头节点，则最终指向的是头节点后的第三个节点（即链表的第三个节点）

  ```cpp
  // 向后移动 K 个节点
           llist
             ↓
    [ ] --> [1] --> [2] --> [3] --> [4]
     ↑
  headNode

  // 不用头节点的情况下：
  while (--k)
  {
      llist = llist->next;
  }

  // 用头节点的情况下：
  haedNode = new ListNode(llist);
  while (k--)
  {
      headNode = headNode->next;
  }
  ```

## 二叉树

# 其他

- 类初始化列表

  ```cpp
  MyHashMap() : m_vec(m_hashSize) {}

  struct TreeNode
  {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode() : val(0), left(nullptr), right(nullptr){};
      TreeNode(int x) : val(x), left(nullptr), right(nullptr){};
      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right){};
  };
  ```

- 三元运算符

  ```cpp
  条件 ? 成立时 : 不成立时
  int a = 1 > 2 ? 1 : 2;
  ```

  ```python
  成立时 if 条件 else 不成立时
  a = 1 if 1 > 2 else 2
  ```

- 可是实际上我们可以一边遍历一边变更新结果的，并不需要全部都算出来再遍历一遍，比如 [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/description/) 和 [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-result/description/)

- [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/description/)，这里要取 `nums[i]` 后面 n 个数的最大值，[为什么我要两层遍历呢](https://leetcode-cn.com/submissions/detail/292889405/)，感觉在做滑动窗口的时候也有这毛病，明明可以 **遍历过程中不断更新最大值，非要多搞一层局部循环**

- 列: `column`、行: `row`

- `nums[i] - 'a'` 存放字符的 ASCII 码

- `1 + '0'` 整数转字符
