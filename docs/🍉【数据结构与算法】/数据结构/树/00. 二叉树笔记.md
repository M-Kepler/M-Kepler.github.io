- [参考资料](#参考资料)
- [二叉树](#二叉树)
  - [二叉树](#二叉树-1)
    - [父节点和子节点下标关系](#父节点和子节点下标关系)
    - [概念](#概念)
    - [二叉树还原](#二叉树还原)
    - [二叉树的存储](#二叉树的存储)
    - [二叉树的遍历](#二叉树的遍历)
  - [线索二叉树](#线索二叉树)
  - [完全二叉树](#完全二叉树)
  - [满二叉树](#满二叉树)
  - [扩充二叉树](#扩充二叉树)
  - [哈夫曼树（最优二叉树）](#哈夫曼树最优二叉树)
  - [优先队列（堆）](#优先队列堆)
  - [二叉搜索树（二叉排序树）](#二叉搜索树二叉排序树)

# 参考资料

# 二叉树

## 二叉树

### 父节点和子节点下标关系

- [父节点和子节点间关系](https://blog.csdn.net/lanchunhui/article/details/52663514)

- 如果根节点标记为 0

  - 节点 i 的左右孩子分别为 `2i + 1` 和 `2i + 2`

  - 节点 i 的父节点为:

    ```sh
    i/2       当i 为左孩子节点
    i/2-1     当i 为右孩子节点
    ```

- 如果根节点标记为 1

  - 节点 i 的左右孩子分别为 `2*i` 和 `2*i + 1`

  - 节点 i (不论为左还是右孩子节点)，其父节点都是 `i/2`

### 概念

- 性质

  - 非空二叉树第 k 层节点最多为 `2^(k-1)` 个节点

  - 高度为 K 的二叉树中，总共最多有 `2^k - 1` 个节点

  - 非空二叉树普遍情况下, `n0 = n2 + 1`

- 完全二叉树

  - 只有最下面两层节点度<2,也就是：如果没有最后一层，那么它将是一个满二叉树

  - 最后一层节点都分布在左边

  - 共有 n 个节点，则深度为 `log2(n)+1`

  - 深度为 k 的完全二叉树，至少有 `2^(k-1)`，至多有 `2^k-1`。所以，满二叉树是完全二叉树

    ![alt](https://images2015.cnblogs.com/blog/818487/201510/818487-20151007234152284-380514952.jpg)

- 满二叉树

  - 深度为 k，且最多有 `2^k-1` 个节点,可以知道，其每一层节点数都是最大节点数

  - 深度为 k 的完全二叉树去掉第 K 层就变为满二叉树了

    可以看出完全二叉树和满二叉树的关系

- 扩充二叉树

  - 添加外层节点，把原树中度数 `< 2` 的节点都补为 `2`

  - 外部节点个数 N 内部节点个数 n，有 `N - n = 1`

  - 外部路径 E 内部路径 I，有 `E - I = 2n`

- 平衡二叉树

  - 其左右子树都是平衡二叉树，左右子树的高度的绝对值 `<= 1`

### 二叉树还原

- `先序 + 中序`

  根据先序找到第一个根后，就可以在中序中将序列分成左右两部分,对分开后的两部分也这样分析就可以还原了

- `中序+ 后序`

  方法和上面差不多，后序中最后一个元素就是根,倒数第二个就是根右边的儿子

- `先序 + 后序`

  无解，只能确定父子关系而已

### 二叉树的存储

- 数组

  - 如果用数组来存储的话，可以根据父子节点的位置关系来确定一颗二叉树<如果子节点为 i 则富节点为 i/2>

  - 但是无论如何都得按照完全二叉树的空间来分配即:2^k-1,很明显太浪费

    如果将一个算式存到二叉树那么先中后序遍历得到的式子刚好就是前缀中缀后缀

- 链式存储

  ```cpp
  typedef char DataType;
  typedef struct TreeNode {
     DataType data;
     struct TreeNode *lchild;
     struct TreeNode *rchild;
  } TreeNode, *pTreeNode;
  ```

### 二叉树的遍历

- 遍历

  ![alt](https://img-blog.csdn.net/20181017202631143?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhcHB5amFjb2I=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 先序遍历

- 中序遍历

- 后序遍历

- 层次遍历

## 线索二叉树

> 为了充分利用空指针,如果有儿子，指针就指向儿子,否则，作为线索只想前驱或后继节点。

## 完全二叉树

## 满二叉树

## 扩充二叉树

## 哈夫曼树（最优二叉树）

- 哈夫曼树 `WPL`

## 优先队列（堆）

- 和队列一样，队尾进,队头出。不同的是优先队列中的`最大/小元素总是位于队首`，所以并非先进先出，而是最大/小的元素先出。

- 特点

  大/小根堆: 每个子二叉树的根均大/小于其左右子树

- 构建堆

  当新增加一个数被放置到堆顶时, 如果此时不符合最小堆的特性,则将需要将这个数向下调整`与左右儿子作比较, 与小儿子做交换(小根堆)`直到找到合适的位置为止,使其重新符合最小堆的特性。

## 二叉搜索树（二叉排序树）

- 节点间是左小右大，子树也是二叉排序树, 节点元素是唯一的

  - 节点的左子树只包含 小于 当前节点的数。

  - 节点的右子树只包含 大于 当前节点的数。

  - 所有左子树和右子树自身必须也是二叉搜索树

- 插入删除都不改变树的结构

- 经过中序遍历后得到的是递增的序列(所以插入的时候，不可以在中间插入，必须遍历完,找到的位置一般都是末尾)

- 根始终大于左子树，小于右子树

- 子树也是二叉排序树

删除三种情况:

- 所删节点为叶节点

- 所删节点左/右子树空

- 所删节点左右子树都非空
