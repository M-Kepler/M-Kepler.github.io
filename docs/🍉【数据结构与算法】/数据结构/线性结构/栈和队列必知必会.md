- [参考资料](#参考资料)
- [栈](#栈)
- [队列](#队列)
- [应用](#应用)
  - [用栈来判断括号是否匹配](#用栈来判断括号是否匹配)
  - [用两个栈实现一个队列](#用两个栈实现一个队列)
  - [用两个队列实现一个栈](#用两个队列实现一个栈)

# 参考资料

- [图解 | 不就是栈吗](https://mp.weixin.qq.com/s/eB9-KeZ6sKU74sYRvFPazg)

- [面试官让手写各种队列，俺差点没写出来](https://mp.weixin.qq.com/s/UKJCMS5d5FuEKnD_2lvIgw)

# 栈

# 队列

# 应用

## 用栈来判断括号是否匹配

**描述**

给定一个只包括 `'('，')'，'{'，'}'，'['，']'`的字符串，判断字符串是否有效(如`{[]}`有效，但`{[}]无效`)

**思路**

遇到左括号就入栈，遇到右括号就判断栈顶是否是对应的左括号, 是则出栈，最后剩下的是没右括号匹配的数据，看一下栈是否空就行了

## 用两个栈实现一个队列

**思路**

已知栈是先进后出，队列则反过来，先进先出，则把栈 A 的数据弹出依次压入栈 B，顺序就颠倒过来，此时栈 B 的出栈顺序就是队的出队顺序
出队操作是先进先出，但是栈是先进后出的，如果把栈的元素颠倒一下，再出栈就是实际出队的顺序了

**入队操作**

数据全部存放在栈 A，比如入队顺序为：`1,2,3,4,5,6`

**出队操作**

把栈 A 的数据依次出栈，则栈 A 为：`1,2,3,4,5,6 [top]`，然后把出栈的数据依次弹出全部压入栈 B，则栈 B 为：`6,5,4,3,2,1 [top]`
因此，出队顺序就是栈 B 的出栈顺序

**缺点和改进**

- 问题

  如果是全入队，出队是全出队则上诉思路没问题，但是如果是入队: `1,2,3,4,5,6 [top]` 出队: `1,2,3` 再入队 `7,8`
  此时栈 A 为:`7,8 [top]`，栈 B 为：`6,5,4 [top]`，如果继续出队的话，栈 A 数据会全倒入栈 B，则栈 B 为：`6,5,4,8,7 [top]`，
  出队为：`7,8,4,5,6`，不是我们期望的 1~8
  问题就在于每次出队都是直接把栈 A 的数据倒入栈 B 再从栈 B 弹出数据，这样，如果栈 B 非空的话，数据顺序就会有问题

- 改进

  因此，在出队操作的时候，应该是先判断栈 B 是否还有数据，如果还有则应该先把栈 B 数据弹，直到栈 B 为空才把栈 A 倒入栈 B
  所以队列长度和是否为空都要判断两个栈的长度和是否为空

## 用两个队列实现一个栈

**分析**

已知队列是先进先出，因此按照两个栈实现队列的方法没用，因为队 A 倒入队 B 的顺序还是和队 A 一样
出栈的操作是先进后出，也就是后进先出，所以出栈就是把最上面的元素弹出

**思路**

队 B 作为队 A 的缓存，用来保存到队 A 里的 `size()-1`个元素，则最后留在队 A 的就是最上面的元素了，每次把最上面的元素弹出后，把保存在队 B 中的元素返回队 A，因为入队的元素都是保存在队 A 的
