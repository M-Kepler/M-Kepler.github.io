- [数组](#数组)
  - [参考资料](#参考资料)
  - [解题技巧](#解题技巧)
    - [从后往前处理](#从后往前处理)
      - [能不能用](#能不能用)
      - [怎么用](#怎么用)
      - [典型题](#典型题)
    - [`STL-vector`](#stl-vector)
    - [二分查找](#二分查找)
    - [双指针](#双指针)
    - [滑动窗口](#滑动窗口)
    - [栈](#栈)
      - [能不能用](#能不能用-1)
      - [怎么用](#怎么用-1)
      - [典型题](#典型题-1)
    - [单调栈](#单调栈)
      - [什么时候用](#什么时候用)
      - [怎么用](#怎么用-2)
      - [典型题](#典型题-2)
    - [单调队列](#单调队列)
      - [什么时候用](#什么时候用-1)
      - [怎么用](#怎么用-3)
      - [典型题](#典型题-3)
    - [优先队列 `priority_queue`](#优先队列-priority_queue)
      - [什么时候用](#什么时候用-2)
      - [怎么用](#怎么用-4)
      - [典型题](#典型题-4)
    - [哈希](#哈希)
    - [前缀和数组](#前缀和数组)
      - [什么时候用](#什么时候用-3)
      - [怎么用](#怎么用-5)
        - [普通前缀和](#普通前缀和)
          - [典型题](#典型题-5)
        - [哈希和前缀和](#哈希和前缀和)
          - [典型题](#典型题-6)
    - [二维前缀和数组](#二维前缀和数组)
      - [什么时候用](#什么时候用-4)
      - [怎么用](#怎么用-6)
      - [典型题](#典型题-7)
  - [题型](#题型)
    - [矩阵](#矩阵)
      - [参考资料](#参考资料-1)
      - [转换技巧](#转换技巧)
      - [典型题](#典型题-8)
    - [区间](#区间)
      - [参考资料](#参考资料-2)
      - [典型题](#典型题-9)
    - [TODO 排列组合](#todo-排列组合)
      - [二进制枚举法](#二进制枚举法)
      - [典型题](#典型题-10)
    - [模拟推演](#模拟推演)
- [字符串](#字符串)
  - [参考资料](#参考资料-3)
  - [把 string 当成栈来用](#把-string-当成栈来用)
  - [`STL-String`](#stl-string)
  - [`STL-algorithm`](#stl-algorithm)
  - [题型](#题型-1)
    - [反转 / 旋转字符串](#反转--旋转字符串)
    - [大数运算](#大数运算)
    - [子区间/子序列](#子区间子序列)
- [其他](#其他)

# 数组

## 参考资料

- [LeetCode 刷题总结 - 数组篇（上）](https://www.cnblogs.com/liuzhen1995/p/11789339.html)

- [LeetCode 数组类知识点 & 题型总结](https://github.com/huxiaoman7/leetcodebook/blob/master/Array/array.md)

- [数组还能这么玩](https://mp.weixin.qq.com/s/EbciwddkWspCHXXsUBuOTg)

- [★ 代码随想录 - 数组：总结篇](https://mp.weixin.qq.com/s/LIfQFRJBH5ENTZpvixHEmg)

## 解题技巧

### 从后往前处理

#### 能不能用

从后面开始往前放就可以避免大量移动

#### 怎么用

```c++
int oldEndPointer = s.size();
// s.resize() or something
int newEndPointer = s.size();

for (; oldEndPointer >= 0; oldEndPointer--, newEndPointer--)
{
    if (something ...)
    {
        do_something();
        continue;
    }
    // 从后往前处理
    s[newEndPointer] = s[oldEndPointer];
}
```

#### 典型题

- [88.合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/description)

- [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof)

### `STL-vector`

### 二分查找

\[\[二分查找必知必会]]

### 双指针

\[\[双指针必知必会]]

### 滑动窗口

\[\[双指针必知必会#滑动窗口]]

### 栈

#### 能不能用

- 利用栈先进后出的特性，可以实现字符串、链表的反转

- 利用栈实现 DFS 搜索，比如 二叉树的前序、后序遍历

#### 怎么用

#### 典型题

- [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/description/)

- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description/)

- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/)

- [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description/)

- [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/description/)

### 单调栈

单调栈，就是栈内元素是单调的，要么递增，要么递减

[单调栈结构解决三道算法题](https://labuladong.gitee.io/algo/2/20/51/)

#### 什么时候用

要寻找任一个元素的右边或者左边`【第一个比自己大或者小的元素的位置】`时可以考虑用单调栈

#### 怎么用

和单调队列一样的做法，把 nums\[i] 【沉】入到栈里面，把栈里面比 nums\[i] 小的元素全部弹出去

即，栈里保存的一直都是比当前元素要大的值，而且栈里元素是单调的

```cpp
stack<int> s;

/* 拿 [739. 每日温度] 为例 */
// 因为是求下一个更大元素，所以从后往前扫描
for (int i = nums.size() - 1; i >= 0; i--)
{
    // 栈里保存的始终是比当前元素要大的得
    while (!s.empty() && nums[s.top()] <= nums[i])
        s.pop();
    s.push(nums[i]);
    ...
}
```

#### 典型题

[TAG: 单调栈](https://leetcode-cn.com/tag/monotonic-stack/problemset/)

- [★ 739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/description)

- [42.接雨水](https://leetcode-cn.com/problems/trapping-rain-water)

- [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/description/)

- [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/description/)

- [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/description/)

### 单调队列

需要这样一个队列，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，`队列可以直接告诉我们这一组元素中，最大的 和 最小的值是多少`

#### 什么时候用

- 解决一些滑动窗口问题，即窗口在不断滑动，需要你动态计算当前窗口中的最大值

- 需要同时知道一组数据中地最大值和最小值

#### 怎么用

- 对于只要求取一组元素中最大最小值的场景，直接对这组的元素进行也是可以的，用 `优先队列` 就行

- 实际上并不需要知道所有元素的顺序，只要知道队列里的最值就行了，而且不需要对队列元素进行排序，可以使用 `双端队列 deque`

```cpp
#include <queue>

// 定义一个双端队列，队列内的值从头到尾是递减的，最大在队头，最小在队尾
deque<int> dq;

for (size_t i = 0; i < nums.size(); i++)
{
    // 元素滑入窗口的逻辑，把元素【沉】到队列里
    while (!dq.empty() && dq.back() < nums[i])
    {
        dq.pop_back();
    }

    dq.push_back(nums[i]);
    ...
}
```

#### 典型题

[TAG: 单调队列](https://leetcode-cn.com/tag/monotonic-queue/problemset/)

- [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

### 优先队列 `priority_queue`

> - push 进去后，如果堆元素超过 k 个，可以直接和 `pq.top()` 比对，淘汰掉比他大的元素，这样，堆里保存的就是 top k 小的元素了
> - TopK 小，用大根堆（根最大）
> - TopK 大，用小根堆（根最小）

```c++
#include <queue>

// less: 堆里的元素更小，构建的是大根堆（默认是大根堆）
priority_queue<int> pq;

// greater: 堆里的元素更大，构建的是小根堆
// 定义元素为 int 类型，用 vector 来装这些元素的小根堆
priority_queue<int, vector<int>, greater<int>> pq;

// 重载运算符，指定比较函数
struct Node
{
    int x, y;
    Node(int a = 0, int b = 0) : x(a), y(b) {}
};

struct cmp
{
    // 重载 () 运算符
    bool operator()(Node a, Node b)
    {
        if (a.x == b.x)
            return a.y > b.y;
        return a.x > b.x;
    }
};

// priority_queue<ListNode *, vector<ListNode *>, cmp> pq;
priority_queue<Node, vector<Node>, cmp> p;
```

#### 什么时候用

- TopK 问题

- 需要在 N 个数中找最大

#### 怎么用

[378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

- 有时候可能会疑惑，找 `【第】k 小` 的数，为什么构建的是大根堆啊？不是应该构建小根堆保存 `【前】 k 小` 的元素吗

    小根堆的堆顶是最小的元素，而我们要找的是`第 k 小的`元素，而不是 `前 k 小的所有元素`

    小根堆只知道堆顶是最小的，当堆里元素数量已经到达 k 个后，无法知道堆里面哪个元素最大，不知道要淘汰哪个元素，所以不得不把所有元素入堆，然后在弹出 k 个元素之后，才得到倒数第 k 小的元素

    ```c++
    // 小根堆
    priority_queue<int, vector<int>, greater<int>> pq;
    for (auto n: nums)
    {
        pq.push(col);
    }

    for (size_t i = 0; i < k - 1; i++)
    {
        pq.pop();
    }
    return pq.top();
    ```

- 还是这个问题，我们知道反过来想一下，用大根堆就好了

    `先`把元素添加到堆里，`然后`判断堆元素数量是否大于 k 个，如果是的话，就把堆顶**去掉**

    因为是大根堆，而且是 `先入堆再判断`，所以被去掉的肯定是比 k 个数还要大的元素（这样，我们就可以一直维持着拥有 k 个元素的大根堆）；最终，堆顶就是第 k 小的元素了

    ```c++
    priority_queue<int> pq;
    for (auto row : nums)
    {
        pq.push(col);
        if (pq.size() > k)
        {
            pq.pop();
        }
    }
    return pq.top();
    ```

#### 典型题

[TAG: 堆（优先队列）](https://leetcode-cn.com/tag/heap-priority-queue/problemset/)

- [剑指 Offer 40. 最小的 k 个数](https://leetcode-cn.com/classic/problems/zui-xiao-de-kge-shu-lcof/description/)

- [215. 数组中的第 K 个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)

- [★ 347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/description/)

- [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/description/)

- [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

- [23. 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

- [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/description/)

### 哈希

`《哈希必知必会.md》`

### 前缀和数组

[★ 前缀和数组](https://leetcode-cn.com/circle/article/EQWhUd/)

> 前缀和思想和滑动窗口会经常用在求`【子数组和子串】`问题

- 前缀和数组的意义是：`preSum[i]` 表示 `nums[0 .. i-1]` 的和，`【前缀】嘛`

    比如 `preSum[2] 表示 nums[0] + nums[1]`；像等差数列前 n 项和 `S(n) = S(n - 1) + n` 很适用于连续子数组（像数轴那样，画画区域会清晰很多）

- 可以借助前缀和数组来`求区间和`

    ```cpp
    // 数列
    S(n) - S(n - 3) = a[n - 2] + a[n - 1];

    // 前缀和数组
    sum(i, j) = preSum[j + 1] - preSum[i];
    ```

#### 什么时候用

- 问题特征不是 `和为 n`，而是 `【连续】子数组（区间）`

- 所求与左边、右边元素有关的情况，比如左侧元素的和、两侧元素的乘积这种

#### 怎么用

![alt](https://mmbiz.qpic.cn/mmbiz_gif/TQ8S0BVeWIyBQeWyPHvFXrWRGXHYeafEW88vA6EMreUgEeN8yLfPmzzX3cUtiaBgMUKziaVkGERfy8mucxwmNqXg/640?wx_fmt=gif\&tp=webp\&wxfrom=5\&wx_lazy=1)

前缀和是多用一个数组对序列进行预处理，方便后面操作；正常会搭配哈希表来用，加快处理效率

[TAG: 前缀和](https://leetcode-cn.com/tag/prefix-sum/problemset/)

##### 普通前缀和

> 前缀和初始形态（比较少用）

```cpp
// 【step1.】定义前缀和数组
// 前缀数组长度比原数组多一个，最后那个元素也要考虑进去
int len = nums.size();
vector<int> preSum(len + 1);

// 【step2.】初始化前缀数组
preSum[0] = 0;
for (int i = 1; i < perSum.size(); i++)
{
    preSum[i] = init(preSum[i - 1], nums[i - 1]);
}

// 【step3.】遍历原列表，用前缀数组辅助计算出答案
for (int i = 0; i < len; i++)
{
    result = do_something(nums[i], L[i]);
}
```

###### 典型题

- [1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/description/)

- [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

- [724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/description/)

- [★ 238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/description/)

##### 哈希和前缀和

> 一般都是求子数组个数，搞懂为什么要用哈希就清晰很多了，代码也不多；有了它你甚至不需要学复杂的 KMP

![alt](https://pic.leetcode-cn.com/1610772892-lhvGau-file_1610772891848)

```cpp
// key 为前缀和的值，value 为这个前缀和出现的次数
unordered_map<int, int> map{
    {0, 1}};

int preSum = 0;
for (auto n : nums)
{
    // 前缀和
    preSum += n;

    // 通过统计差值出现次数来避免了罗列所有的子数组（题目要的也是次数）

    // [567. 字符串的排列] 也是通过词频来判断是否是子串
    do_something(result, map[preSum - k]);
    map[preSum]++;
}
```

- [为什么 map 只记录出现次数就行了](https://www.cnblogs.com/KeepZ/p/13703610.html)，而不用记录全部前缀和

    > 只需要维护一个 `preSum` 变量存储当前元素前缀和就行

  - 两数之和是 `a + b = k`

    遍历数组，若 a 已加入哈希表，对于 b，看 `k - b` 是不是在哈希表中；在的话，证明存在 a 和 b，使得两者之和为 k

  - `[560. 和为 K 的子数组]` 转换为两数只差 `a - b = k`

    假设 a 已加入哈希表；对于 b，如果 `b + k` 也在哈希表中，则证明 `a = b + k`，即 a 和 b 之差为 k

    其中 k 表示一个和为 k 的子数组，`S(n) - S(n - 3) = a[n - 1] + a[n - 2] + a[n] = k`

    ```cpp
    sum(i, j) = preSum[j + 1] - preSum[j];
    k         = a             - b;

    int preSum = 0;
    for (auto n : nums)
    {
        preSum += n;
        // 统计出现次数即可
        result += map[preSum - k];
        map[preSum] ++;
    }
    ```

- 无论是返回索引还是本题中的计数，万变不离其宗，都是哈希表 value 定义不同而已

###### 典型题

- [★ 560.和为 k 的子数组.cpp](https://leetcode-cn.com/problems/subarray-sum-equals-k/description)

- [1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/description/)

- [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/description/)

- [525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/description/)

### 二维前缀和数组

#### 什么时候用

#### 怎么用

#### 典型题

- [304. 二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/description/)

## 题型

### 矩阵

> 列: `column`、行: `row`

- `二维数组`

    ```c++
    int [][]dp = new int [m][n];
    ```

- `matrix 矩阵`

    ```c++
    int i, j;

    // 创建一个 v 行 s 列的矩阵，默认值为 0
    vector<vector<int>> dp(v, vector<int>(s));

    // 创建一个 v 行, s 列的矩阵
    // 由 vector 实现的二维数组，可以通过resize()的形式改变行、列值
    vector<vector<int>> matrix(v);
    for (i = 0; i < matrix.size(); i++)
    {
        matrix[i].resize(s);
    }

    // 初始化矩阵

    // 创建一个和 matrix 一样大小的矩阵
    vector<vector<int>> result(matrix[0].size(), vector<int>(matrix.size()));
    ```

#### 参考资料

- [★ 二维数组的花式遍历技巧盘点](https://mp.weixin.qq.com/s/8jkzRKLNT-6CnEkvHp0ztA)

- [LeetCode 总结 - 矩阵篇](https://blog.csdn.net/linhuanmars/article/details/39248597)

- [二维矩阵 - 从 LeetCode 题海中总结常见套路](https://xduwq.blog.csdn.net/article/details/107094827)

- [二维矩阵的常见转换技巧](https://leetcode-cn.com/circle/article/yXym7U/)

#### 转换技巧

- 二维矩阵按索引拍平到一维数组

    ![alt](https://pic.leetcode-cn.com/1601343580-PYydNU-74_1.jpg)

  - 如第 2 行第 3 列的 16 这个数，其矩阵的坐标是(1,2),而映射到一维数组的时候，其对应的下标索引 `idx = i * n + j = 1 * 4 + 2=6`

  - 而如何通过 idx=6 反向得到矩阵的坐标呢？ `i = idx / n = 6 / 4 = 1; j = idx % n = 6 % 4 = 2` 得到矩阵的坐标为 `(i,j) ==> (1,2)`

- 将矩阵当成二进制转化成十进制

#### 典型题

- [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

- [867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/description/)

- [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/description/)

- [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)

- [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

- [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

- [73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/description/)

**遍历矩阵**

> 图的周游： BFS、DFS

学会一个技巧：如果当前位置是陆地，则淹没（或者说感染形象点）周围的土地

- [★ 200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/)

- [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/description/)

- [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/description/)

- [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/description/)

### 区间

> 这部分出题概率比较低

#### 参考资料

- [时间调度问题的千层套路](https://mp.weixin.qq.com/s/YVqd4J1GVnh25FKk8FUYzA)

- [一文读懂五类常见区间问题](https://mp.weixin.qq.com/s/JT8vUXIKOnfZkAuiZLT3bw)

#### 典型题

- [56.合并区间](https://leetcode-cn.com/problems/merge-intervals/)

### TODO 排列组合

#### 二进制枚举法

对于【整数数组(可以为负数)】nums，数组中的【元素互不相同】。返回该数组所有可能的子集（幂集）

- [78.子集](https://leetcode-cn.com/problems/subsets/description)

#### 典型题

- [46.全排列](https://leetcode-cn.com/problems/permutations/description)

### 模拟推演

没什么奇技淫巧，考察代码的熟练掌握程度

- [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/description/)

- [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/description/)

- [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/description/)

- [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/description/)

- [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)

- [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)

- [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/description/)

- [★ 498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/description/)

- [★ 118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/description/)

- [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/description/)

- [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/description/)

# 字符串

> 字符串和数组一样的，记录在一起

## 参考资料

- [★ 实现一些字符串操作标准库函数与解决一些字符串笔试问题](https://mp.weixin.qq.com/s/tsCeMcdtvyuJJ1uFjnjnDg)

- [关于字符串，我总结了这些](https://mp.weixin.qq.com/s/pD0a3r4_gO5ydWoRfTIyyg)

- [代码随想录 - 字符串](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzUxNjY5NTYxNA==\&scene=1\&album_id=1577944806306201601\&count=3#wechat_redirect)

- [★ Leetcode 中字符串总结](https://www.cnblogs.com/love-yh/p/7347549.html)

- [STL - string](https://blog.csdn.net/sinat_36184075/article/details/54836053)

## 把 string 当成栈来用

- 看到这种一直是左括号，遇到右括号就要把括号内的反转，第一个想到的就是遍历推入堆，然后遇到右括号时做处理

- 栈的特性，先进后出，可以用来做翻转，翻转字符串、翻转链表都可以

- [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/description)

- [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/description)

- [1190. 反转没对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/description)

## `STL-String`

- [★ C++ string 类及其成员函数汇总](https://blog.csdn.net/sinat_36184075/article/details/54836053)

- [C++ string 库函数详解](https://www.cnblogs.com/john1015/p/13027047.html)

- `substr`

    ```cpp
    // 只有一个数字 5 表示从下标为 5 开始一直到结尾：sub1 = "56789"
    string sub1 = s.substr(5);

    // 从下标为 5 开始截取长度为 3 位：sub2 = "567"
    string sub2 = s.substr(5, 3);
    ```

## `STL-algorithm`

- `reverse`

    ```cpp
    int left(), right(0);

    // 参数需要时迭代器，不过可以通过 begin() + 偏移量的方式来调整范围
    reverse(arr.begin() + left, arr.begin() + right);
    ```

- `to_string`

    ```cpp
    int x = 100;
    string str = to_string(x);
    ```

## 题型

### 反转 / 旋转字符串

[字符串左旋和右旋的常见方法](https://blog.csdn.net/loving_forever_/article/details/51168316)

- 左旋和右旋，先翻转后 k 个，后翻转前 n - k 个，再整体翻转

- [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/description/)

- [796. 旋转字符串](https://leetcode.cn/problems/rotate-string/description/)

    ```cpp
    // s1 经过旋转得到 s2

    s1 = "huangjinjie";
    s2 = "ngjinjiehua";

    // 则 s1 肯定是 s2 + s2 的子串
    s2 + s2 = "ngjinjie[huangjinjie]hua";

    ```

- [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/description/)

- [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof)

- [★ 189.旋转数组（右旋）](https://leetcode-cn.com/problems/rotate-array/description)

- [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof)

- [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/description/)

- [61.旋转链表](https://leetcode-cn.com/problems/rotate-list/description)

### 大数运算

- [8.字符串转换整数](https://leetcode-cn.com/problems/string-to-integer-atoi/description)

- [415.字符串相加](https://leetcode-cn.com/problems/add-strings/description)

- [43.字符串相乘](https://leetcode-cn.com/problems/multiply-strings/description)

### 子区间/子序列

- 区间问题，在某个区间内翻转字符串

- 子序列不一定连续，子数组是连续的

- 子序列也不一定是连续的，子串是连续的

# 其他

- [数组的玩法挺多的](https://mp.weixin.qq.com/s/-V7d3XUMqsrcDu_CWZP7bg)
