- [链表](#链表)
  - [参考资料](#参考资料)
  - [递归与迭代](#递归与迭代)
  - [设置头节点](#设置头节点)
    - [什么时候用](#什么时候用)
    - [怎么用](#怎么用)
    - [典型题](#典型题)
  - [递归](#递归)
  - [双指针法](#双指针法)
  - [转成字符串](#转成字符串)
    - [什么时候用](#什么时候用-1)
    - [怎么用](#怎么用-1)
  - [栈](#栈)
    - [什么时候用](#什么时候用-2)
    - [怎么用](#怎么用-2)
  - [对链表的部分进行操作](#对链表的部分进行操作)
    - [什么时候用](#什么时候用-3)
    - [怎么用](#怎么用-3)
  - [把结果追加到新链表中](#把结果追加到新链表中)
    - [什么时候用](#什么时候用-4)
    - [怎么用](#怎么用-4)
  - [递归创建链表](#递归创建链表)
  - [其他](#其他)

# 链表

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/5Pk2hjDCTySEKH4YibPXSia9oHN7jvEOyMKhAa3vMNVoogt780CCibSa2SwcAkRicLQdTzmmYcSEuEdyX30A7WqpKg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 节点定义

  ```cpp
  typedef int DataType;
  struct ListNode
  {
      DataType val;
      ListNode *next;

      // 节构体和类一样，都可以写构造函数
      ListNode(): val(0), next(nullptr) {};
      ListNode(DataType x): val(x), next(nullptr) {}
      ListNode(DataType x, ListNode *next): val(x), next(next) {}
  };

  // 定义一个 struct ListNode* 的指针类型
  typedef struct ListNode *pListNode;

  // 相当于 struct ListNode * llist; 关键字 struct 可写可不写，不写的话有些编译器会报错
  pLinkNode llist;
  ```

## 参考资料

- [`linklist-single.cpp`](https://github.com/M-Kepler/cpp/blob/master/datastruct/linklist/linklist-single.cpp)

- [结构之美：单链表的头节点与头指针](http://www.nowamagic.net/librarys/veda/detail/1805)

- [轻松搞定面试中的链表题目](https://blog.csdn.net/luckyxiaoqiang/article/details/7393134)

- [★ 一篇总节，搞定链表！](https://mp.weixin.qq.com/s/zr_OcJFLZYDObUIWHqpQzg)

- [【超详细】一文学会链表解题（建议收藏！）](https://zhuanlan.zhihu.com/p/147575749)

- [LeetCode 链表知识点 & 题型总结 & 题表](https://github.com/huxiaoman7/leetcodebook/blob/master/Linklist/linklist.md)

- [LeetCode 链表总结](https://blog.csdn.net/qq_41605114/article/details/105385252)

## 递归与迭代

> 经典：打印链表

**迭代**

```cpp
// 头节点
ListNode *headNode = new ListNode(0, llist);
// 用来遍历的节点
ListNode *travelNode = headNode;

while(travelNode->next)
{
    travelNode = travelNode->next;
}
```

**递归**

```cpp
ListNode* solution(ListNode *llist)
{
    if(!llist)
    {
        return llist;
    }

    llist->next = solution(llist->next);
    return llist;
}
```

## 设置头节点

[用虚拟头节点会方便很多](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247488696&idx=2&sn=b0d9cee0adb218f09a7db972b8744526&scene=21#wechat_redirect)

### 什么时候用

需要 `【操作】首节点时`，可以考虑加一个头结点

- 为什么要引入头节点

  因为链表的其他节点都是通过前一个节点来移除当前节点`preNode->next`，而`首节点`没有前一个节点，所以操作起来，首节点就要进行特殊处理，为了操作的统一性，可以设置一个头节点

- 如果只是遍历的话，可以不设置头节点

  ```cpp
  // 没有头节点，直接判断节点是否为 NULL
  while (llist) {
      llist = llist->next;
  }

  // 带头节点，需要判断 next 域是否为 NULL
  while (head->next) {
      head = head->next;
  }

  // 反例：不适合加头结点：876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/description/)
  ```

- 如果`需要操作头结点`，比如需要修改指针，删除头节点，则推荐设置头节点

  ```cpp
  ListNode *removeElements(ListNode *llist, int val)
  {
      // 因为首个节点也有可能是被删除的节点，所以设置头节点
      ListNode *headNode = new ListNode();
      headNode->next = llist;

      ListNode *preNode = headNode;
      while(headNode->next != nullptr)
      {
          // 需要修改指针指向
          // 可能被操作的是首个节点，设置头结点的用处就来了
          ListNode *tmpNode = preNode->next;
          if(tmpNode->val == val)
          {
              preNode->next = tmpNode->next;
              delete tmpNode;
          }
          else
          {
              preNode = preNode->next;
          }
      }
      // 返回源链表
      llist = headNode->next;
      delete headNode;
      return llist;
  }
  ```

### 怎么用

- 即使是个不带头节点的链表，也可以自己加个头节点上去，最终返回的时候返回头节点的下一个节点就行了

  ```cpp
  ListNode* reverseList2(ListNode* llist)
  {
      if (llist == nullptr)
      {
          return llist;
      }

      // 设置一个虚拟头节点
      ListNode* head = new ListNode(0);
      head->next = llist;

      // 翻转前第一个节点
      ListNode *pFirstNode = head->next;
      while(pFirstNode->next != nullptr){
        ...
      }
      return head->next;
  }
  ```

### 典型题

- [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/)

## 递归

[[递归算法#递归在链表中的应用]]

## 双指针法

[[数组必知必会]]

## 转成字符串

### 什么时候用

- 不适合有正负数的场景

### 怎么用

- [25.K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description)

- [234.回文链表.cpp](https://leetcode-cn.com/problems/palindrome-linked-list/description)

- 要注意，链表数据域是 int 类型，string 容器 char 类型，注意两种类型的转换，int 和 char 差了 256，比如整数 323 存到 char 里变成了 67 (67 = 323 - 256)

## 栈

### 什么时候用

- 反转链表的变形题挺好用

### 怎么用

- [92.反转链表-ii.cpp](https://leetcode-cn.com/problems/reverse-linked-list-ii/description)

- [25.K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description)

- [206.反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description)

## 对链表的部分进行操作

### 什么时候用

- 有时候需要把原链表拼接回去

- B 链表拼接到 A 链表末尾

- [92.反转链表-ii](https://leetcode-cn.com/problems/reverse-linked-list-ii/description)

- [21.合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/description)

- [61.旋转链表](https://leetcode-cn.com/problems/rotate-list/description)

### 怎么用

## 把结果追加到新链表中

### 什么时候用

- 需要`生成新链表的时候`，把值追加到结果链表中

- [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)

- [23. 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/description)

- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/)

### 怎么用

> 创建对象的三种方式

**方式一：在堆上分配空间**

```cpp
// step1. 把结果拼接成新链表
ListNode *resultHead = new ListNode();
// step2. preNode 用来保存结果链表的最末尾节点，用于追加新节点
ListNode *preNode = resultHead;

ListNode *newNode;

while (xxx)
{
    // 由 preNode 去把节点链接起来
    newNode = new ListNode();
    ...

    // step3. 新节点加入到结果链表中
    preNode->next = newNode;
    preNode = preNode->next;
}
return resultHead;
```

**方式二：在栈上分配空间**

```cpp

// 用 ListNode x; 的方式创建对象，这样在添加节点时，不用一直 new 新节点再追加
ListNode result, *resultTail(&result);
while(xxx)
{
    // 直接赋值
    resultTail->next = yyy;
    ...
    resultTail = resultTail->next;
}
```

## 递归创建链表

```cpp
// 21. 合并两个有序链表
void solution(ListNode *llist)
{
    // 创建新节点；随着递归进去，每次递归都会创建一个新的节点
    ListNode *resultNode = new ListNode();
    resultNode->next = solution(llist->next);
}
```

## 其他

- [★ 143. 重排链表](https://leetcode-cn.com/problems/reorder-list/description/)

- 是否需要创建新链表来保存结果

- 取中间节点
