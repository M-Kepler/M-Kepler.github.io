

1.数组、字符串

1.1.数组优点

1.2.数组缺点

1.3.数组例题

1.3.1.题目242.有效的字母异位词

1.3.2.分析

1.3.3.代码

2.链表

2.1.链表的优点

2.2.链表的缺点

2.3.链表的应用场景

2.4.经典解法

2.4.1.快慢指针（有时候用到三个指针）

2.4.2.构建一个虚假的链表头

2.5.链表例题

2.5.1.例题

2.5.2.分析

2.5.3.代码

3.栈

3.1.栈的特点

3.2.栈的优点

3.3.不要用数组实现栈

3.4.例题1

3.4.1题目

3.4.2.分析

3.4.3.代码

3.5.例题2

3.5.1题目

3.5.2.分析

3.5.3.代码

4.队列

4.1.队列的特点

4.2.队列的实现

4.3.应用场景

5.双端队列

5.1.双端队列的特点

5.2.双端队列的实现方式

5.3.例题分析

5.3.1.题目

5.3.2.分析

5.3.3.代码

6.树

6.1.树的形状

6.2.树的遍历

6.2.1.前序遍历

6.2.2.中序遍历

6.2.3.后序遍历

# 1.数组、字符串

## 1.1.数组优点

1. 构建一个数组非常简单

1. 能让我们在O(1)的时间里根据数组的下标(index)查询某个元素

## 1.2.数组缺点

1. 构建时必须分配一段连续的空间

1. 查询某个元素是否存在时需要遍历整个数组，耗费O(n)的时间

1. 删除和添加某个元素时，同样需要耗费O(n)的时间

## 1.3.数组例题

### 1.3.1.题目242.有效的字母异位词

给定连个字符串s和t,编写一个函数来判断t是否是s的字母异位词

示例1

输入：s = "anagram", t = "nagaram"

输出：true

示例2

输入：s = "rat", t = "car"

输出：false

### 1.3.2.分析

一个重要的前提“假设两个字符串只包含小写字母”，小写字母一共也就 26 个

首先知道什么是异位词，异位词就是一个字符串中用到的字母相同，顺序不同而已。

可以使用map的数据结构来存储26个字母，以字母为key，出现次数为value。s字符串比对时，出现次数+1，t字符串的每个字母再map比较，相同的key就对value-1。最后遍历一遍整个map，所有value为0,则表示是异位次，否则不是。

### 1.3.3.代码

```javascript
#include <iostream>
#include <vector>
#include <exception>
using namespace std;
class LowerException : public exception {
public:
    LowerException(string str) {
        cout << str << endl;
    }

};


class Solution
{
public:
    bool isDiffPosiWord(string str1, string str2) {
        if (str1.size() != str2.size()) {
            return false;
        }

        vector<int> vec(26, 0);

        for (int i = 0; i < str1.size(); i++) {
            if (!islower(str1.at(i)) || !islower(str2.at(i)))  {
                throw LowerException("is lower exception!");
            }
            vec[str1[i] - 'a']++;
            vec[str2[i] - 'a']--;
        }

        for (auto count : vec) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }
};

int main() {
    string s = "anagram";
    string t = "nagaraM";
    Solution solu;
    try {
        cout << (solu.isDiffPosiWord(s, t) ? "true" : "false");
    } catch(LowerException e){
        cout << e.what();
    }

    return 0;
}
```



# 2.链表

## 2.1.链表的优点

1. 能灵活的分配内存空间

1. 能够在O(1)时间内删除或添加元素，前提是该元素的前一个元素已知，双向链表再已知后一个元素下同样可以在O(1)时间内删除该元素。

## 2.2.链表的缺点

1. 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取。

1. 查询第k个元素需要O(k)时间

## 2.3.链表的应用场景

如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数据可能更合适。

## 2.4.经典解法

### 2.4.1.快慢指针（有时候用到三个指针）

链表的翻转，寻找倒数第k个元素，寻找链表中间位置的元素，判断链表是否有环等。

### 2.4.2.构建一个虚假的链表头

比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条ifelse语句。比较简洁的写法是创建一个空的链表头，直接往其后添加元素即可，最后返回这个空的链表头的下一个节点。

## 2.5.链表例题

### 2.5.1.例题

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

说明：

你的算法只能使用常数的额外空间。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group

### 2.5.2.分析

使用两个指针start, end，分别指向要翻转的链表头和链表尾，next指向带翻转的链表头，需要特殊处理最后一个翻转k长度的子链表，再让她重新翻转。

### 2.5.3.代码

```javascript
#include <iostream>

using namespace std;

struct LinkList {
    LinkList(int v):value(v){}
    int value;
    LinkList *next = NULL;
};

class Solution
{
public:
    LinkList * reserver(LinkList *&head, int k, LinkList *&s_next) {
        //上一个节点
        LinkList *pre = NULL;
        //要翻转的当前节点
        LinkList *cur = head;
        //下一个节点
        LinkList *next = NULL;

        //逐一翻转
        while(cur && k--) {
            next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        //新链表的最后一个节点
        LinkList *end = head;

        //新的子链表头
        head = pre;

        //未翻转的节点
        s_next = cur;

        if (k != -1) {
            //不满足k的长度，把翻转过来的子链表再翻转回去
            //TODO 翻转链表
            s_next = NULL;
        }

        return end;
    }
    LinkList * reserverGroup(LinkList *&head, int k) {
        //翻转的起始节点
        LinkList *start = head -> next;
        head ->next = NULL;
        //翻转后的尾节点
        LinkList *end = NULL;
        //保存上一次的尾节点
        LinkList *pre_end = NULL;
        //尾节点的下一个节点
        LinkList *next = NULL;

        while(true) {
            //start是翻转的起始节点，k是翻转的长度，next翻转后的end的下一个节点
            end = reserver(start, k, next);
            //当head->next为NULL时，执行第一次翻转的指针为头节点
            if (!head->next) {
                head->next = start;
            }


            //当放回的next节点为空时，表示没有翻转到链表尾部了，这是跳出循环
            if (!next) {
                //把翻转过的子链表再翻转回来
                reserver(start, k, next);
                if (pre_end) {
                    pre_end->next = start;
                }
                break;
            }
            //上一次的尾节点next执行这次翻转的头节点
            if (pre_end) {
                pre_end->next = start;
            }
            pre_end = end;
            start = next;
        }
        return head;
    }

};

int main() {
    std::cout << "Hello, World!" << std::endl;
    LinkList *head = new LinkList(0);
    int i = 0;
    LinkList *node = head;
    while(i++ < 5) {
        LinkList *newNode = new LinkList(i);
        node->next = newNode;
        node = newNode;
    }
    Solution solu;
    head = solu.reserverGroup(head, 2);
    return 0;
}
```

# 3.栈

## 3.1.栈的特点

栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。

## 3.2.栈的优点

利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。

## 3.3.不要用数组实现栈

如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。

## 3.4.例题1

### 3.4.1题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。

左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/valid-parentheses

### 3.4.2.分析

利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。

### 3.4.3.代码

```javascript
bool isValid(string s) {
    stack<char> bracket_stack;
    map<char, char> bracket_map;
    bracket_map.insert(pair<char, char>('(', ')'));
    bracket_map.insert(pair<char, char>('[', ']'));
    bracket_map.insert(pair<char, char>('{', '}'));
    for (auto c : s) {
        for (auto &kv : bracket_map) {
            //左边括号入栈
            if (kv.first == c) {
                bracket_stack.push(c);
                continue;
            }

            //右括号和栈顶元素做对比
            if (kv.second == c) {
                if (bracket_stack.empty()) {
                    return false;
                }
                char preSymbol = bracket_stack.top();
                bracket_stack.pop();
                if (preSymbol != kv.first) {
                    return false;
                }
                break;
            }
        }
    }
    if (!bracket_stack.empty()) {
        return false;
    }

    return true;
}
```

## 3.5.例题2

### 3.5.1题目

根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/daily-temperatures

### 3.5.2.分析

可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。

### 3.5.3.代码

```javascript
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        vector<int> result(T.size(), 0);
        stack<int> temperStack;
        for (int i = 0; i < T.size(); i++) {
            if (temperStack.empty()) {
                temperStack.push(i);
                continue;
            }

            //当前元素大于栈顶元素则计算上升的天数
            auto index = temperStack.top();
            if (T.at(i) > T.at(index)) {
                //计算升温的天数
                result[index] = i - index;
                //出栈
                temperStack.pop();
                //i--的目的是为了让当前元素在于栈顶元素对比
                i--;
                //如果当前温度小于栈顶温度，则入栈
            } else {
                temperStack.push(i);
            }
        }
        return result;
    }
};
```

# 4.队列

## 4.1.队列的特点

只允许在队头查看和删除数据， 在队尾查看和添加数据。

## 4.2.队列的实现

可以用双链表表来实现队列，双链表的头指针在队头允许查看和删除元素，双链表的尾指针查看和添加数据。

## 4.3.应用场景

我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。

# 5.双端队列

## 5.1.双端队列的特点

双端队列与普通队列最大的区别在于，双端队列允许在对头和队尾查看，删除和添加元素，都是O(1)的操作。

## 5.2.双端队列的实现方式

用双链表来实现

## 5.3.例题分析

### 5.3.1.题目

LeetCode第239题：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

进阶：你能在线性时间复杂度内解决此题吗？

示例:

输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3

输出: [3,3,5,5,6,7] 

解释: 

  滑动窗口的位置                最大值

---------------               -----

[1  3  -1] -3  5  3  6  7       3

 1 [3  -1  -3] 5  3  6  7       3

 1  3 [-1  -3  5] 3  6  7       5

 1  3  -1 [-3  5  3] 6  7       5

 1  3  -1  -3 [5  3  6] 7       6

 1  3  -1  -3  5 [3  6  7]      7

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/sliding-window-maximum

## 5.3.2.分析

1、暴力法：暂不考虑

2、双端队列法：使用一个双端队列保存当前窗口的最大值，接着窗口移动遍历整个数组，当值小于队头元素时，添加数据下标到队尾，当值大于队尾元素时，队尾出列，一直到队尾元素比当前元素大或者队列为空时。

## 5.3.3.代码

```javascript
#include <iostream>
#include <vector>
#include <deque>
using namespace std;
class Solution {
public:
    void entry_queue(deque<int> &deq, vector<int> &nums, int index) {
        if (deq.empty()) {
            deq.push_back(index);
            return;
        }

        //小于队尾值就入队尾
        do {
            if (nums.at(index) >= nums.at(deq.front()) || nums.at(index) >= nums.at(deq.back())) {
                deq.pop_back();
            } else {
                break;
            }
        } while (!deq.empty());

        deq.push_back(index);
    }

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int left = 0, right = k - 1;
        deque<int> index_deque;
        vector<int> result;

        for (int i = left; i < right; i++) {
            entry_queue(index_deque, nums, i);
        }

        for (int i = 0; i < nums.size() - k + 1; i++) {

            entry_queue(index_deque, nums, right);

            //取队头元素
            while(!index_deque.empty()) {
                int index = index_deque.front();
                if (right - index > k-1) {
                    index_deque.pop_front();
                } else {
                    result.push_back(nums.at(index));
                    break;
                }
            }

            right++;
        }
        return result;
    }
};
int main() {
    std::cout << "Hello, World!" << std::endl;
    vector<int> vec = {1,3,-1,-3,5,3,6,7};
//    vector<int> vec = {1,-1};
//        vector<int> vec = {7, 2, 4};

    Solution solu;
    solu.maxSlidingWindow(vec, 3);
    return 0;
}
```

# 6.树

树的结构十分直观，而树的很多概念定义都有一个相同的特点：递归，也就是说，一棵树要满足某种性质，往往要求每个节点都必须满足。例如，在定义一棵二叉搜索树时，每个节点也都必须是一棵二叉搜索树。

## 6.1.树的形状

在面试中常考的树的形状有：普通二叉树、平衡二叉树、完全二叉树、二叉搜索树、四叉树、多叉树

特殊的数：红黑树(RED BLACK Tree)、自平衡二叉搜索树（AVL Tree）一般不会在面试中问到

关于树的考题，无非就是要考察树的遍历及序列化。

## 6.2.树的遍历

### 6.2.1.前序遍历

先访问根节点，再访问左子树，接着访问右子树。在访问左右子树的时候，同样先访问子树的根节点，再访问左子树，最后访问右子树，是一个不断递归的过程。

应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

实现代码

```javascript
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void preorder(TreeNode *root, vector<int> &vec) {
    if (!root) {
        return;
    }
    vec.push_back(root->val);
    preorder(root->left, vec);
    preorder(root->right, vec);
}
```



### 6.2.2.中序遍历

先访问左子树，然后再访问根节点，最后访问右子树，在访问左、右子树的时候，同样，先访问子树的左边，再访问子树的根节点，最后再访问子树的右节点。

应用场景：最常见的是二叉搜素树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。

代码实现

```javascript
void inorder(TreeNode *root, vector<int> &vec) {
    if (!root) {
        return;
    }
    inorder(root->left, vec);
    vec.push_back(root->val);
    inorder(root->right, vec);
}
```

### 6.2.3.后序遍历

先访问左子树，然后再访问右子树，最后访问根节点。

应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。

代码实现

```javascript
 void postorder(TreeNode* root, vector<int> &vec) {
    if (!root) {
        return;
    }
    postorder(root->left, vec);
    postorder(root->right, vec);
    vec.push_back(root->val);
}
```

