- [递归算法](#递归算法)
  - [参考资料](#参考资料)
  - [算法思想](#算法思想)
  - [问题特点](#问题特点)
  - [解题步骤](#解题步骤)
    - [能不能用](#能不能用)
    - [怎么用](#怎么用)
      - [看懂递归函数](#看懂递归函数)
      - [会写递归函数](#会写递归函数)
  - [如何优化](#如何优化)
  - [转化成非递归](#转化成非递归)
- [题型](#题型)
  - [递归在二叉树中的应用](#递归在二叉树中的应用)
    - [遍历二叉树](#遍历二叉树)
      - [先序遍历](#先序遍历)
      - [中序遍历](#中序遍历)
      - [后序遍历](#后序遍历)
      - [层次遍历](#层次遍历)
      - [左右顺序互换的遍历](#左右顺序互换的遍历)
    - [综合左右子树得到答案](#综合左右子树得到答案)
    - [还原二叉树](#还原二叉树)
    - [其他](#其他)
  - [递归在链表中的应用](#递归在链表中的应用)
  - [递归在数组中的应用](#递归在数组中的应用)
  - [归并排序](#归并排序)
  - [递归嵌套](#递归嵌套)
  - [其他](#其他-1)
- [其他](#其他-2)

# 递归算法

## 参考资料

- [★ 告别递归，谈谈我的一些经验](https://mp.weixin.qq.com/s/SrkHe7MDIRptczuVi5_E-g)

- [★ 对于递归有没有什么好的理解方法](https://www.zhihu.com/question/31412436)

- [写给小白看的递归](https://mp.weixin.qq.com/s/P-pO2JW5ciZWVicXGnRp8A)

- [算法——递归（自底向上、自顶向下）](https://blog.csdn.net/longool/article/details/107109632)

- [三道题套路解决递归问题](https://lyl0724.github.io/2020/01/25/1/)

- [★ 码二说之通过链表来思考递归](https://developer.aliyun.com/article/951954)

## 算法思想

递归的本质就是将原来的问题，转化为更小的同样的一个问题，也就是将问题规模逐渐缩小，小到一定程度，通常在递归中都是小到不能再小的时候就可以很容易的解决问题，这样一来整个问题就可以得到解决。

递归调用全部展开后其实会形成一棵树，把递归转为非递归无非就是在遍历这棵树

```sh
# 以 【经典递归应用：阶乘】 为例

f(6)
=> 6 * f(5)
=> 6 * (5 * f(4))
=> 6 * (5 * (4 * f(3)))
=> 6 * (5 * (4 * (3 * f(2))))
=> 6 * (5 * (4 * (3 * (2 * f(1)))))  ==> 上部分为【递】，下半部分为【归】
=> 6 * (5 * (4 * (3 * (2 * 1))))
=> 6 * (5 * (4 * (3 * 2)))
=> 6 * (5 * (4 * 6))
=> 6 * (5 * 24)
=> 6 * 120
=> 720
```

## 问题特点

我们要求 n 的阶乘 `fn(n)`，我们知道 `fn(n) = fn(n - 1) * n` 就可以得到，这就是最核心的关系

## 解题步骤

### 能不能用

是否可以拆解成 `规模（长度）比原来小的子问题`，而且可以用同样的解法求解（是不是感觉像分治）

### 怎么用

#### 看懂递归函数

有时候看递归，总看不到头，一层套一层，就像不断放大不断放大一张图片一样，看得头昏眼花，`【自底向上】` 地看就好多了

![alt](https://mmbiz.qpic.cn/mmbiz_gif/EB1nD0zYLZpEaamZbMiaCNR9HNn1EOiajDDjSiaRoIb2813UYjruND3vmUjpfULibI9ibBYV8DpiaL2JB0icllic6oMUicA/640?wx_fmt=gif)

主要没把参数返回缩小，直接把 **`退出递归前的变量状态作为参数传进去，同时把递归推出条件拿掉，就清晰了`**，相当于到达递归的最底层；写完后，再自底向上顺着递归逻辑走两轮，看些结果是否正确。

```c++
// 函数参数是 arg
int func(int arg)
{
    // arg = 1 时，退出递归
    if (arg = 1)
        return 0;

    // 进入递归的参数变化位 arg - 1
    int ret = func(arg - 1);
    return ret + 1;
}
```

递归函数的参数变化是 `arg = arg - 1`，那么就是函数参数 `arg = 2` 时会退出递归。所以看这个递归函数的逻辑时，你就认为递归退出条件是成立的，把 `arg = 2` 代入进去看，然后 **`把递归退出条件里的返回的值逻辑搬到递归函数调用的地方`** 就清楚了

```c++
// arg = 2
int func(int arg)
{
    // 去掉递归退出条件
    /*
    if (arg = 1)
        return 0;
    */

    // 把递归退出时的返回值替到底函数调用的地方
    // int ret = func(arg - 1);
    int ret = 0;
    return ret + 1;
}
```

#### 会写递归函数

看的时候是 `【自底向上】`，写的时候是 `【自顶向下】` 的逻辑（宏观）

```c++
/**
 * 【step1】 明确递归函数的意义
 *
 * 在写递归算法的时候，有些时候不需要你特别微观的陷进递归调用里的去纠结这个递归是怎么样调用的，
 * 其实你可以直接把这个递归函数当成一个子函数，这个子函数可以完成特定的功能，
 * 而你要干的事情就是利用这个子函数来构建你自己的逻辑，来解决上层的这一个问题就好了。
 */
Recursion(args)
{
    /**
     * 【step2】 找出递归的终止条件
     * 直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少
     * 压缩到能想到的基本的、不用继续递归处理的情况
     */
    if (终止条件)
    {
        return result;
    }
    /* 没进入到终止条件中，证明此时已经走到递归的最小子问题了，比如链表，那就是走到链表末尾节点了*/

    /**
     * 【step3】 找出函数的等价关系，不断缩小参数的范围
     * 缩小之后，可以通过一些辅助的变量或者操作，使原函数的结果不变
     */

    // 【step3.1】逻辑处理，可能有，也可能没有，具体问题具体分析

    // 递归调用，（特别要注意递归进去的参数）
    // 传入的参数肯定是不断缩小范围的，比如 arg2 = arg1 - 1 或者链表的 arg2 = arg1->next
    int result = Recursion(args2);

    /**
     * 【step3.2】拿到递归返回值有需要就做一些处理，否则直接返回即可
     * 如果需要进一步处理，可以先保存递归的结果
     */

    /**
     * 【step4】return 的一般是递归函数的返回值
     *
     * 有些情况，比如链表，return 的不是递归函数的返回值，可能是一个递归前设置的头结点
     * 不要因为拿到返回值后做了些逻辑处理，就以为返回值变了
     */
    return result;
}
```

## 如何优化

- 像动态规划 `消除重叠子问题` 一样，记录计算过的数据，避免重复运算（`记忆化搜索`）

## 转化成非递归

一般用 `栈` 来解决，比如二叉树遍历的非递归实现、快排的非递归实现

- 可以用迭代的方式实现递归函数，区别在于，递归是系统隐式地维护了一个栈，而迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都差不多

- 非递归实现的难点在 `无法判断当前遇到的节点究竟是初次见面，还是【回溯】之后的久别重逢`。而这关系到我们要对它做什么；而栈正好可以用来保存遇到过的节点，然后也是会先把最近遇到的节点先吐出来；写代码或者是考的时候，脑袋里就有这样的图像；

- **用栈来实现先序遍历为例子，可以想象到【羽毛球筒】沿着树结构的左下方向收集这些节点，收集完后，再慢慢向右上移动，把节点退出来**

```c++

// 保存递归结果
vector<int> result;

// 定义一个栈存储原本递归过程会遇到的数据
stack<YourSt*> stack

/**
 * 既然要遍历所有节点。
 * 一部分遍历过的节点放在栈，一部分未遍历过的节点还是在树里面
 * 所以 while 循环退出条件判断两个因素
 *
 * 然后节点入栈是为了可以进行回溯，
 * 我遍历过该节点，但还不是处理它的时机，所以先放到栈里面，后面再从栈里取节点进行处理
 */

// step1. 遍历所有节点
// 未访问过的节点在 root，访问过的在 stack，已处理完左右子树了的被 pop 出去
while (!stack.empty() || your_condition_expr)
{
    // step2. 递归函数的主体逻辑
    if (!your_condition_expr)
    {
        // 保存递归过程访问过的数据，方便回溯
        stack.push(some_value)

        // 进入递归函数的参数变化
        your_condition_expr++
    }
    // step3. 退出递归时的逻辑
    else
    {
        // 回溯，一层层退出递归，把上一步存放到栈中的值取出来
        auto pre = stack.top();
        stack.pop();

        // 退出递归函数的参数变化
        your_condition_expr++;
    }
    // step4. 返回结果
    return result;
}

```

# 题型

## 递归在二叉树中的应用

（目前遇到的所有二叉树题目，好像都可以用递归解）==很多的递归问题，都可以抽象成递归二叉树的问题==，比如快排、归并排序等；而且还和二叉树的前中后三种遍历方式很类似（即：处理逻辑放在递归前还是递归后）

是否可以通过遍历一遍二叉树得到答案？如果不能的话，是否可以定义一个递归函数，`【通过子问题（左右子树）的答案推导出原问题的答案】`？

用递归肯定可以解决二叉树问题，可不可以练习一下迭代的写法？为了加深理解，期望是所有二叉树的递归解法，都可以用迭代来实现一遍

```c++
void test(TreeNode* root, TreeNode* result)
{
    if (!root)
    {
        return;
    }

    // 最小的那棵树是只有一个节点的那颗
    test(root->left, result);
    test(root->right, result);
}
```

**二叉树的递归**

```c++
/**
 * 二叉树怎么看递归呢，以二叉树中序遍历为例
 * ⁠   5
 * ⁠  / \
 * ⁠ 1   4
 *     / \
 *    3   6
 *
 * 【把最小的那棵树】作为参数放进去就行了，也就是 [1, null, null]
 */
void solution(TreeNode *root, vector<int> &result)
{
    // 递归终止条件
    if (root == nullptr)
        return;

    // 中序遍历，所以先递归左子树，再保存节值
    solution(root->left, result);
    result.push_back(root->val);
    solution(root->right, result);
}
```

### 遍历二叉树

> 二叉树的题目基本都是围绕着四种遍历方式来解决

![alt](https://labuladong.gitee.io/algo/images/%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86%e4%ba%8c%e5%8f%89%e6%a0%91/1.jpeg)

#### 先序遍历

需要先处理根节点，然后递归对左右子树进行处理，用前序遍历

- [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

- [100. 相同的树](https://leetcode-cn.com/problems/same-tree/description)

- ★ [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/description/)

- [112. 路径总和](https://leetcode-cn.com/problems/path-sum/description)

- [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/description/)（隐含回溯的过程）

#### 中序遍历

- [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/)

- [★ 98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/description)

- [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/)

#### 后序遍历

需要先对左右子树进行处理，然后对处理结果进行进一步处理的

- [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)

- [★ 543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/description/)

- [★ 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/description/)

- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

  需要先处理左右子树，然后在求高度只能从下到上去查，所以只能后序遍历（当然在二叉树中，深度就是高度，所以求深度也可以用后序遍历）

- [★ 111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/)

- [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/description)

- [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/description/)

- [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/description/)

- [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

- [★ 236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

- [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)

#### 层次遍历

[二叉树层序遍历](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)

- [★ 102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/)

- [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/description/)

- [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/)

- [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/)

- [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/description/)

#### 左右顺序互换的遍历

> 正常都是先处理左子树后处理右子树（`中 - 左 - 右`，`左 - 中 - 右`，`左 - 右 - 中`）；但有些题目需要先访问右子树再访问左子树

- [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/description/)

- [230. 二叉搜索树中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/)

### 综合左右子树得到答案

> 上面说到，在进入递归前后可以根据需要添加一些处理逻辑，那么什么时候要添加呢？添加在哪呢？有没有什么可总结的吗

**同时对左右子树进行递归**：一般写递归二叉树，把最左边的那颗最小的树塞进去，就可以把递归函数看的明明白白；但是现在不行了，因为现在涉及到跨左右子树，需要左子树和右子树一起满足某个条件才行。即：**左边且右边**

- [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/description)

### 还原二叉树

- **先序 + 中序**

  根据先序找到第一个根后，就可以在中序中将序列分成左右两部分，对分开后的两部分也这样分析就可以还原了

- **中序 + 后序**

  方法和上面差不多，后序中最后一个元素就是根，倒数第二个就是根右边的儿子

- **先序 + 后序**

  无解，只能确定父子关系而已

- [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/description/)

- [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/description/)

- [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

- [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

- [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/)

- [1028. 从先序遍历还原二叉树](https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/description/)

- [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/description/)

- [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

### 其他

- [★ 116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/description/)

## 递归在链表中的应用

链表是一种兼具递归和迭代性质的数据结构；对于链表来说，就是链表的节点个数不断在变小，所以，如果实在找不出递归缩小的条件，就试试 `llist->next`

==递归函数的意义：递归移动到链表末端（末端不一定是最后那个节点，可能是最后 N 个节点），然后利用回溯从后往前处理链表==

- 链表就是一个节点一个节点链接起来就是一个链表。链表也可以当作是**一个节点后面又挂了一个链表**

  ![alt](https://s2.51cto.com/images/blog/202106/01/7b496d5231ca846199f301f9dcfe704b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

  ==非常非常重要的概念：==

  ```log
  [1] --> [2] --> [3] --> [4] --> null

  可以看作 [1] 节点后面挂着一个链表，把后面的这个链表当成一个节点来操作就行了。

  [1] --> [  一个更短的链表  ]
          [2] --> [更短的链表]
                  [3] --> [..]
  ```

- 链表的递归

  ```c++
  // 经典: 剑指 Offer 06. 从尾到头打印链表 92. 反转链表 II
  void solution(ListNode *llist)
  {
      // 走到最后一个节点时返回
      if (!llist->next)
      {
          return llist;
      }

      // right 指针向右探查 cnt 个节点（不包括当前节点）
      ListNode* right = llist;
      while (cnt--)
      {
          if (!right)
              return llist;
          right = right->next;
      }

      // 参数收缩，指针后移
      recursionTest(llist->next);
      // 回溯过程中（llist = llist->next 逆过来，即当前节点的前置节点）再把指针移动回去了

      // NOTICE: 至于要不要保存结果，怎么处理递归结果，就要按需要来做
      // 比如你是要把当前节点指向递归的返回值（leetcode 21）
      // 那就需要 llist->next = solution(llist->next)
  }
  ```

- [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/description/)

- [★ 83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/)

- [★ 24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

  ```c++
  ListNode *Solution::swapPairs(ListNode *llist)
  {
      // 当只剩下一个节点或没有节点的时候，递归中止
      if (!llist || !llist->next)
      {
          return llist;
      }
      ListNode *nextNode = llist->next;
      llist->next = swapPairs(nextNode->next);
      nextNode->next = llist;
      return nextNode;
  }
  ```

- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/description/)

- [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

  ```c++
  // 21. 合并两个有序链表
  void solution(ListNode *llist)
  {
      // 创建新节点；随着递归进去，每次递归都会创建一个新的节点
      ListNode *resultNode = new ListNode();
      resultNode->next = solution(llist->next);
  }
  ```

- [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof)

- [★ 206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description/)

- [★ 25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/)

- [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/description/)

## 递归在数组中的应用

- 岛屿系列题目

  - [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/description/)

  - [1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/description/)

  - [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/)

  - [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/description/)

- [397. 整数替换](https://leetcode.cn/problems/integer-replacement/description/)

- [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/description/) 快速幂

TODO [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci)

- [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/description/)

- [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/description/)

- [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)

- [704. 二分查找](https://leetcode-cn.com/problems/binary-search/description/)

## 归并排序

记录在 [[二分查找必知必会]]

## 递归嵌套

- [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/description/)

- [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/description/)

## 其他

- [258. 各位相加](https://leetcode-cn.com/problems/add-digits/description/)

TODO - [1361. 验证二叉树](https://leetcode-cn.com/problems/validate-binary-tree-nodes/description/)

# 其他

- `Recursion` 递归

- 你写递归为什么老要 helper，你要把递归返回值利用起来

  - 第一个要明确你这个递归函数的意义，比如二叉树的中序遍历，这种遍历节点，然后 push 到结果集；但是递归函数的作用是返回当前节点，这种就要传入一个结果集的引用，而不能直接 `root->left = recursion(root->left);` 因为返回值和你这个操作冲突

  - 感觉你还是不理解递归啊，不是非要处理完才返回，你可以在递归中返回的就是结果了，因为会进入递归里面取处理子情况，只要关注当前的函数逻辑就行了，把递归看做正常的逻辑

- 打破循环的力量是多么可贵
