- [参考资料](#参考资料)
- [回溯算法](#回溯算法)
  - [算法思想](#算法思想)
  - [问题特点](#问题特点)
    - [回溯法比暴力好在哪里](#回溯法比暴力好在哪里)
    - [回溯和递归](#回溯和递归)
  - [解题步骤](#解题步骤)
    - [能不能用](#能不能用)
    - [怎么用](#怎么用)
- [典型题](#典型题)
- [其他](#其他)

# 参考资料

- [回溯算法](https://mp.weixin.qq.com/s/fsLKaWBvSWtM0jA-CfOxyA)

- [一文学会回溯算法解题技巧](https://mp.weixin.qq.com/s?src=11&timestamp=1627561917&ver=3220&signature=UM-eKU0iCyTbKqqFyXLyiBKDuXfHbhX89TNVtWrkS6jmUapLsEXqIMD3oVR-NdDnjBEntbbnsqy54Q4L1aQH5Tutuq80QEKr3nh0KT3BzkzsqW92xQ4IFL9M6TxBj2el&new=1)

- [★ 关于回溯算法，你该了解这些](https://mp.weixin.qq.com/s/gjSgJbNbd1eAA5WkA-HeWw)

- [★ 回溯算法：求组合问题](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)

- [labuladong 回溯算法框架套路详解](https://mp.weixin.qq.com/s/hNnnSq-OGLwodhPrr9JRwA)

# 回溯算法

## 算法思想

> 回溯 `backtrack` 法就 `用递归来解决嵌套层数的问题`

## 问题特点

> - 没得选，能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法；比如排列组合，如果有一千个元素，不可能写一千个循环嵌套吧
> - 回溯的重点就在于 m_path 怎么记录你走过的路，m_path 记录你走过了 1 2 3，然后吐出 3 就回到上一层了

- 组合问题：N 个数里面按一定规则找出 k 个数的集合

- 排列问题：N 个数按一定规则全排列，有几种排列方式

- 切割问题：一个字符串按一定规则有几种切割方式

- 子集问题：一个 N 个数的集合里有多少符合条件的子集

- 棋盘问题：N 皇后，解数独等等

### 回溯法比暴力好在哪里

- 回溯和递归是相辅相成的

- 回溯法`其实就是暴力查找`，并不是什么高效的算法

### 回溯和递归

[[递归算法]]

- 递归和回溯还是很紧密的，上面讲回溯在数组中应用的时候，也会提到`树`

- 递归和回溯一一对应，递归函数执行完，就是进行回溯的时候了

- 详细可以参见 [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/description/)

## 解题步骤

### 能不能用

- 求组合类问题

- 虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望

### 怎么用

- ![alt](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv5C8W0mj9MSP18fpeFku5B0cFmwQVLy8CaS2bKXP7EFahBvY98UfgaUck9hGnUwY1hlT1wKQQ0YKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  - 图中可以发现 n 相当于树的宽度，k 相当于树的深度

  - 把达到叶子节点的结果收集起来，就可以求得 n 个数中 k 个数的组合集合

  - path 数组记录走过的节点（图中红线），大小如果达到 k，说明找到了一个子集大小为 k 的组合了，在图中 path 存的就是根节点到叶子节点的路径

  - startIndex 来记录下一层递归，搜索的起始位置

```cpp
void backtracking(参数)
{
    // if(m_path.size() == nums.size())
    // 对于组合类问题来说，一般是走到末尾节点的时候就收集结果
    // 递归退出条件，这时候收集结果
    if (终止条件)
    {
        存放结果;
        return;
    }

    // for (int i = 0; i < nums.size(0); i++)
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）)
    {
        处理节点;
        // m_path.push_back(nums[i]);
        backtracking(路径，选择列表);   // 递归，进入下一层，直到退出递归
        回溯，撤销处理结果
        // m_path.pop_back();
    }
}
```

# 典型题

- [77.组合](https://leetcode-cn.com/problems/combinations/description)

- [46.全排列](https://leetcode-cn.com/problems/permutations/description)

- [78.子集](https://leetcode-cn.com/problems/subsets/description)

- [15.三数之和](https://leetcode-cn.com/problems/3sum/description)

- [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/description/)，巧妙地通过函数入参来进行回溯

- 组合是不强调元素顺序的，排列是强调元素顺序

# 其他

-
