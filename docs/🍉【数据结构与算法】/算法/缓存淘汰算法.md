- [参考资料](#参考资料)
- [`FIFO`](#fifo)
- [`LRU` 淘汰算法](#lru-淘汰算法)
  - [实现](#实现)
- [`LFU` 淘汰算法](#lfu-淘汰算法)
  - [实现](#实现-1)
- [其他](#其他)

# 参考资料

- [两种常见的缓存淘汰算法 LFU & LRU](https://blog.csdn.net/jake_li/article/details/50659868)

# `FIFO`

`first in first out` 先进先出；核心原则就是，如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，`缓存满的时候，应当把最先进入缓存的数据给淘汰掉`

# `LRU` 淘汰算法

`LRU least recently used` 最近最少使用策略； 如果一个数据`在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小`。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰

![alt](https://pic2.zhimg.com/v2-4fb9443c87c7646c9a6a2b0b14cd75cf_1440w.jpg)

## 实现

> `哈希表 hash map + 双向链表 doubly linked list`
>
> - 用`双向链表`存储数据结点，并保证是`按结点最近被使用的时间来存储的`
> - 用`哈希表`来存储索引，保证访问效率

- [146.LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/description)

- 因为最不常访问的数据被放到链表尾，最常访问的数据放到链表头部，所以需要用上 `list 双向链表` 方便在两端操作

- 如果要找到访问的节点，就需要遍历整个链表，使用 `hash` 可以让我们在 O(1) 的时间找到想要访问的结点，或者返回未找到

- `LRUCache::get()` 如果一个结点被访问了，那么它在接下来的一段时间内被访问的概率要大于其它结点。于是，我们把它放到双向链表的头部

- `LRUCache::put()` 当我们往双向链表里插入一个结点，我们也有可能很快就会使用到它，同样把它插入到头部；用这种方式不断地调整着双向链表，链表尾部的结点自然也就是最近一段时间，最久没有使用到的结点。那么，当我们的 Cache 满了，需要替换掉的就是双向链表中最后的那个结点

# `LFU` 淘汰算法

`LFU Least Frequently Used`，最不经常使用策略；算法根据数据的历史`访问频率来淘汰数据`，其核心思想是 `如果数据过去被访问多次，那么将来被访问的频率也更高`

![alt](https://img-blog.csdn.net/20160213214622601)

## 实现

TODO

# 其他
