- [参考资料](#参考资料)
- [位运算](#位运算)
  - [问题特点](#问题特点)
  - [算法思想](#算法思想)
  - [解题步骤](#解题步骤)
  - [典型题](#典型题)
- [快速幂](#快速幂)
  - [参考资料](#参考资料-1)
  - [问题特点](#问题特点-1)
  - [算法思想](#算法思想-1)
  - [解题步骤](#解题步骤-1)
  - [典型题](#典型题-1)
- [位图](#位图)
  - [参考资料](#参考资料-2)
  - [问题特点](#问题特点-2)
  - [算法思想](#算法思想-2)
  - [解题步骤](#解题步骤-2)
  - [典型题](#典型题-2)
- [其他](#其他)

# 参考资料

- [★ `bit_operate_helper.hpp`](https://github.com/M-Kepler/leetcode/blob/master/bit_helper/bit_operate_helper.hpp)

- [★ 你可能不知道的位运算技巧](https://mp.weixin.qq.com/s/INYjYfwhPU7uZcNmzBTpNQ)

- [★ 位运算有什么奇技淫巧](https://www.zhihu.com/question/38206659)

- [Cpp：bitset](https://www.jianshu.com/p/d1e966df88bf)

# 位运算

## 问题特点

- 跟 2 有关

- 跟幂次有关

- 跟位有关

## 算法思想

> `与(&)、或(|)、异或(^)、取反(~)、左移(<<)、右移(>>是带符号右移 >>>无符号右移动)`

- 与 `&`

  ```bash
  # 1 & 1 = 1； 1 & 0 = 0
    0 0 0 0 0 0 1 0
  & 1 1 1 1 1 1 1 0
  = 0 0 0 0 0 0 1 0

  2 & -2 = 2
  ```

- 或 `|`

  ```bash
  # 有一个为 1 则为 1； 0 | 0 = 0； 0 | 1 = 1； 1 | 1 = 1；
    0 0 0 0 0 0 1 0
  | 1 1 1 1 1 1 1 0
  = 1 1 1 1 1 1 1 0

  2 | -2 = -2
  ```

- 异或 `^`

  ```sh
  # 同为0；异为 1，即 0^0=0, 0^1=1, 1^1=0
    0 0 0 0 0 0 1 0
  ^ 1 1 1 1 1 1 1 0
  = 1 1 1 1 1 1 0 0

  2 ^ -2 = -4
  ```

- 按位取反 `~`

  ```bash
  # 0 变为 1；1 变为 0
  ~127 =  128
  ~ 0 1 1 1 1 1 1 1 = 1 0 0 0 0 0 0 0

  ~ -1 = 0
  ~ 1 1 1 1 1 1 1 1 = 0 0 0 0 0 0 0 0
  ```

- 移位运算

  ```c++
  // 左移运算 << 后，右边补 0；左移一位相当于乘以 2
  n <<= 1;

  // 右移运算 >>> 后，左边补 0；右移一位相当于除以 2
  // 右移动运算 >> 后，左侧补原始位

  n >>= 1;
  ```

- 把一个整型 `n` 的二进制后三位清零: `n &= ~7;`

## 解题步骤

## 典型题

- [191. 位 1 的个数](https://leetcode-cn.com/problems/number-of-1-bits/description)

- [201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/description/)

- [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/description/)

- [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/description/)

- [461] 汉明距离](https://leetcode-cn.com/problems/hamming-distance/description/)

# 快速幂

二分法

## 参考资料

[算法学习笔记 (4)：快速幂](https://zhuanlan.zhihu.com/p/95902286)

## 问题特点

- 快速求一个幂式的模（余数）

## 算法思想

> `x^n = x^(n/2) * x%(n/2)` 比如 `2^4 = (2^2) * (2^2)`，就不用一步一个数去乘，很像是一个分治的思想

![alt](https://www.zhihu.com/equation?tex=a%5En%3D%5Cbegin%7Bcases%7Da%5E%7Bn-1%7D%5Ccdot+a%2C%26%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+odd%7D+%5C%5C+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%2C+%26%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+even+but+not+0%7D%5C%5C+1%2C%26%5Ctext%7Bif+%7D+n%3D0%5Cend%7Bcases%7D)

先来思考一个问题：7 的 10 次方，怎样算比较快

- 方法 1：最朴素的想法，`7*7=49，49*7=343，... 一步一步算`，共进行了 9 次乘法。

  这样算无疑太慢了，尤其对计算机的 CPU 而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。

- 方法 2：先算 7 的 5 次方，即 `7*7*7*7*7，再算它的平方`，共进行了 5 次乘法。

  但这并不是最优解，因为对于 “7 的 5 次方”，我们仍然可以拆分问题。

- 方法 3：先算 `7*7 得 49，则 7 的 5 次方为 49*49\*7`，再算它的平方，共进行了 4 次乘法。

模仿这样的过程，我们得到一个在 时间内计算出幂的算法，也就是快速幂。

## 解题步骤

```cpp
/**
 * 计算 a 的 n 次方
 * 如果 n 是偶数（不为 0），那么就先计算 a 的 n/2 次方，然后平方
 * 如果 n 是奇数，那么就先计算 a 的 n-1 次方，再乘上 a
 * 递归出口是 a 的 0 次方为 1。
 *
 *递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：
 */
int qpow(int a, int n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a;
    else
    {
        int temp = qpow(a, n / 2);
        return temp * temp;
    }
}
```

## 典型题

- [★ 50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/description)

- [372. 超级次方](https://leetcode-cn.com/problems/super-pow/description/)

# 位图

## 参考资料

- [位图应用场合](http://blog.chinaunix.net/uid-20196318-id-308653.html)

- [`BitMap` 的原理以及运用](https://www.cnblogs.com/dragonsuc/p/10993938.html)

## 问题特点

- 位图适合处理 **`不重复的`** ，在一定范围内的 **`正整数`** 问题

- `正整数` 计算位的下标很方便，但是对于包含负数、字符串就不好弄了

  - [用 `unsigned int`?](https://www.cnblogs.com/pangxiaodong/archive/2011/08/14/2137748.html)

  - 用哈希? [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/description)

## 算法思想

位图是一个数组的每一个元素的`每一个二进制位表示一个数据的状态`，0 表示数据不存在，1 表示数据存在；作为扩展，也可以用 2 个二进制位来表示 4 种状态等等

## 解题步骤

```cpp
int arr[] = {1, 31, 53, 41, 79, 201};
// 因为最大数字是 201，一个字节 8 位
// 26 * 8 = 208 < 201 所以需要 26 个字节才能把 201 标记进去

/**
 * int bitmap[26];
 * 通过设置 0 或 1 来表示数据是否存在
 * 如何表示 31 存在数组中
 * 31 = 3 * 8 + 7
 * 即把 bitmap 数字的第三个元素 bitmap[3] 的第 7 位置为 1
 */

// 位图全部设置为 0
// 所需要的字节数（一字节 8 位） = 序列最大值 / 8 + 1
std::vector<int>::iterator max_item = max_element(nums.begin(), nums.end());
int byte_cnt = *max_item / 8 + 1;

// 定义位图，并全部设置为 0，由于 byte_cnt 是运行时确定的
// 不能直接 char bytes[byte_cnt] = {0}; 进行初始化，编译会报错
char bytes[byte_cnt];
memset(bytes, 0, byte_cnt * sizeof(char));

/**
 * 判断是否有值，即判断某个字节是已经被设置为 1
 * 用字节与位做与操作
 *
 * 1 << bit 表示把 第 bit 位置为 1
 * [0 0 0 0 0 0 0 0] _1（_1不在元素里面，这里作为标记显示出来）
 * 左移后变为 [0 _1 0 0 0 0 0 0] 0
 */
if (!(bytes[idx] & (1 << bit)))
    // 设置对应的位为 1
    bytes[idx] |= (1 << bit);
```

## 典型题

- [78. 子集](https://leetcode-cn.com/problems/subsets/description/)

- [★ 287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/description)

- [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/description)

- [位图题目](https://blog.csdn.net/qq_41643443/article/details/107162717)

- 排序

# 其他
