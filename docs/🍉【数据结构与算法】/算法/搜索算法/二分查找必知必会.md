- [二分搜索](#二分搜索)
  - [参考资料](#参考资料)
  - [复杂度](#复杂度)
  - [解题步骤](#解题步骤)
    - [能不能用](#能不能用)
    - [怎么用](#怎么用)
    - [总结](#总结)
- [典型题目](#典型题目)
  - [普通的二分查找](#普通的二分查找)
  - [数组部分有序](#数组部分有序)
  - [搜索左右边界](#搜索左右边界)
  - [在矩阵中边界调整](#在矩阵中边界调整)
  - [非等值条件进行二分](#非等值条件进行二分)
  - [归并排序](#归并排序)
  - [多路归并](#多路归并)
  - [其他](#其他)
- [其他](#其他-1)

# 二分搜索

> 二分法其实是 `分治策略` 的一种体现

## 参考资料

- [★ 我作了首诗，保你闭着眼睛也能写对二分查找](https://mp.weixin.qq.com/s/M1KfTfNlu4OCK8i9PSAmug)

- [我写了一个套路，助你随心所欲运用二分搜索](https://mp.weixin.qq.com/s/JgJ0jh2SJd6grQSPnN6Jww)

## 复杂度

- [时间复杂度: `O(logn)`](https://www.cnblogs.com/yellowgg/p/11272908.html)

## 解题步骤

### 能不能用

> 不断调整下标来缩减目标范围；而在【什么条件下】要【如何调整左右边界】呢

- 要求在 `O(logn)` 时间复杂度内解决问题

- 在 `【有序】` 区间内 `【查找某个元素】`

- `关键点一：区间怎么收缩`

  原本是要求数组是有序的，在查找的时候就可以根据元素的大小关系来调整查找范围。其实 `【部分有序】` 也行，可以抓住部分有序这个特点来收缩左右边界

- `关键点二：什么情况下返回`

  【满足某种条件】，不一定是等值查找目标元素

### 怎么用

```cpp
int binarySearch(int[] nums, int target)
{
    int left = 0;

    int right = nums.size() - 1;

    // 【注意点一】确定搜索区间
    while(left <= right)
    {
        //【注意点二】用这种方式避免整型溢出
        int mid = left + (right - left) / 2;

        //【注意点三】一般二分是进行查找，所以可以根值得大小进行二分
        // 但是有些题目就不是这样，而是【满足某种条件】，比如 33 34 278
        if(nums[mid] == target)
        {
            return mid;
        }
        // 如果需要查找左侧/右侧边界，注意收缩搜索区间，而不是直接返回
        // 根据题目要求，确定是搜索左侧还是搜索右侧
        else if (nums[mid] < target)
        {
            left = mid + 1;
        }
        else if (nums[mid] > target)
        {
            right = mid - 1;
        }
    }
    //【注意点四】搜索左/右边界时，结果是在这里返回，而不是 while 循环里
    return -1;
}
```

- `注意点一`

  右边界可以等于 `nums.size()` 也可以写成 `nums.size() - 1`

  - 如果 `right = nums.size() - 1`，则搜索区间是一个**闭合区间 `[left, right]`**，那么 `while` 循环的条件就应该是 `while (left <= right)`，因为当 `left > right` 时，已经超出这个区间了

  - 如果 `right = nums.size()`，则搜索区间是一个**左闭右开区间 `[left, right)`**，那么 `while` 循环的条件就应该是 `while (left < right)`，因为当 `left == right` 时，已经超出这个区间了

- `注意点二`

  计算 `mid` 时需要防止溢出，代码中 `int mid = left + (right - left) / 2;` 和 `int mid = (left + right) / 2;` 的结果相同，但是有效 **`防止了 left 和 right 相加太大导致溢出`**

- **`注意点三`** 搜索左侧 / 右侧时

  > 比如 `[1, 2, 2, 2, 3]`，搜索左边界就返回下标 1，右边界就返回下标 3

  当要求搜索 `左边界或右边界时`，**找到目标之后要做处理，还不能立即返回**

  ```cpp
  int left(0), right(nums.size() - 1);
  // 这里用的是搜索闭区间的写法
  // 所搜索区间为 [left, right]
  while (left <= right)
  {
      ...
      if (nums[mid] == target)
      {
          /*【搜索左边界】*/
          // 找到 target 时不要立即返回，而是缩小「搜索区间」的右边界 right
          // 在区间 [left, mid - 1] 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的
          right = mid - 1;

          /* 【搜索右边界】，则向右侧范围缩小 */
          // left = mid + 1;
      }
      ...
  }

  /* 如果【搜索左边界时】检查出界情况*/
  if (left >= nums.length || nums[left] != target)
      return -1;
  return left;

  /* 如果【搜索右边界时】检查出界情况*/
  if (right < 0 || nums[right] != target)
      return -1;
  return right;
  ```

- `注意点四` 搜索左侧 / 右侧时

  - 搜索左侧 / 右侧边界时，前面 `nums[mid] == target` 并不会返回，所以要在 `while` 循环外返回

  - 退出 `while` 循环时，`left = right + 1`，所以要判断一下是否越界，如果没有超出边界，则可以直接返回，否则返回 `-1`

  - 搜索左边界时，right 不断缩小，向 left 靠近，所以要判断 right 是否小于 left 了

  - 搜索右边界时，left 不断增大，向 right 靠近，所以要判断 left 是否大于 right 了

### 总结

搜索左侧边界还是搜索右侧边界，取决于当 `nums[mid] == target` 时，向左收缩区间，还是向右收缩区间；以及返回时，对左还是右判断越界

# 典型题目

## 普通的二分查找

- [704. 二分查找](https://leetcode-cn.com/problems/binary-search/description)

- [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/description)

## 数组部分有序

- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description)

- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description)

- [★ 162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/description/)

## 搜索左右边界

- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

- [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/description/)

## 在矩阵中边界调整

- 行和列别搞错了

  ```cpp
  int row_len = matrix.size();
  int col_len = matrix[0].size();
  ```

- 矩阵中是拿 `matrix[row][col]` 来与目标值比对

- 可以利用矩阵的行列的特性来减少查找范围，不需要对每行都进行二分查找

- [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/description)

- [★ 240. 搜索二维矩阵-ii](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description)

- [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

## 非等值条件进行二分

一般二分是进行查找，所以可以根据值的大小进行二分，但是有些题目就不是这样，而是【满足某种条件】

- [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/description/)

- [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/description/)

- [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/description/)

- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description)

- [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/description/)

## 归并排序

- 对大文件进行排序，文件内容不能一次性读入内存

- 归并排序（分治策略） = 不断把数组分解 + 合并有序数组（有点递归的感觉，先分解，再合并）

  ![alt](http://images0.cnblogs.com/blog/575634/201411/162133318062246.png)

- [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/description/)

- [★ 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/description/)

- [★ 23. 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/description/)

- [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/description/)

- [★ 148. 排序链表](https://leetcode-cn.com/problems/sort-list/description/)

## 多路归并

- [264. 丑数 II](https://www.baidu.com)

- [313. 超级丑数](https://www.baidu.com)

- [373. 查找和最小的 K 对数字](https://www.baidu.com)

- [632. 最小区间](https://www.baidu.com)

- [719. 找出第 k 小的距离对](https://www.baidu.com)

- [786. 第 K 个最小的素数分数](https://www.baidu.com)

- [1439. 有序矩阵中的第 k 个最小数组和](https://www.baidu.com)

- [1508. 子数组和排序后的区间和](https://www.baidu.com)

- [1675. 数组的最小偏移量](https://www.baidu.com)

## 其他

- [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/)

# 其他

- a
