- [参考资料](#参考资料)
- [深度优先 DFS](#深度优先-dfs)
  - [典型题](#典型题)
- [广度优先 BFS](#广度优先-bfs)
  - [典型题](#典型题-1)
- [其他](#其他)

# 参考资料

![alt](https://pic.leetcode-cn.com/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89.gif)

# 深度优先 DFS

- 先保留历史节点；下层处理完，再`回溯`处理当前层（需要把历史节点拿出来再处理一下）

- 栈先进后出，适合把历史节点存储起来，弹出栈顶后就可以处理历史节点了，所以采用栈实现

- 栈顶就是当前子树的根节点

## 典型题

- [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description)

# 广度优先 BFS

**队列实现**

- 广度优先，一层一层处理节点，不需要把历史节点拿出来再处理一下（不需要回溯的过程）

- 队列保存的是一层的节点，同时也是下一层的根节点，所以可以根据这个信息入队处理下一层的节点

- 当前层节点处理过久出队，同时把下一层以该节点未根地子节点入队；这样可以保证下一次处理时，队列里保存的节点都是同一层的

**栈实现**

- 用栈也可以做到 BFS [100. 相同的树](https://leetcode-cn.com/problems/same-tree/description/)、[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/description/)、[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)
、[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/)

## 典型题

- [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/)

# 其他
