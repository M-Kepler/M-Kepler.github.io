- [参考资料](#参考资料)
- [排序总结](#排序总结)
  - [排序稳定性重要吗](#排序稳定性重要吗)
- [交换排序](#交换排序)
  - [冒泡排序](#冒泡排序)
    - [算法过程](#算法过程)
      - [理论基础](#理论基础)
      - [`推演过程`](#推演过程)
    - [稳定性](#稳定性)
      - [理论基础](#理论基础-1)
      - [推演过程](#推演过程-1)
    - [时间复杂度](#时间复杂度)
      - [最好的情况](#最好的情况)
      - [最坏的情况](#最坏的情况)
    - [空间复杂度](#空间复杂度)
    - [代码示例](#代码示例)
    - [优化](#优化)
      - [优化一](#优化一)
      - [优化二](#优化二)
  - [★ 快速排序](#-快速排序)
    - [算法过程](#算法过程-1)
      - [理论基础](#理论基础-2)
      - [推演过程](#推演过程-2)
    - [稳定性](#稳定性-1)
      - [理论基础](#理论基础-3)
      - [推演过程](#推演过程-3)
    - [时间复杂度](#时间复杂度-1)
      - [最好的情况](#最好的情况-1)
      - [最坏的情况](#最坏的情况-1)
    - [空间复杂度](#空间复杂度-1)
    - [代码示例](#代码示例-1)
    - [快排为什么比冒泡快](#快排为什么比冒泡快)
    - [快排为什么比堆排快](#快排为什么比堆排快)
    - [★ 优化成稳定排序](#-优化成稳定排序)
    - [非递归实现](#非递归实现)
    - [优化](#优化-1)
      - [基准值的选择](#基准值的选择)
      - [序列本就基本有序](#序列本就基本有序)
      - [序列存在大量重复元素时](#序列存在大量重复元素时)
- [选择排序](#选择排序)
  - [直接选择排序](#直接选择排序)
    - [算法过程](#算法过程-2)
    - [代码示例](#代码示例-2)
    - [稳定性](#稳定性-2)
    - [时间复杂度](#时间复杂度-2)
      - [最好的情况](#最好的情况-2)
      - [最坏的情况](#最坏的情况-2)
    - [空间复杂度](#空间复杂度-2)
    - [优化](#优化-2)
    - [选择排序和插入排序有点像](#选择排序和插入排序有点像)
  - [★ 堆排序](#-堆排序)
    - [算法过程](#算法过程-3)
      - [理论基础](#理论基础-4)
      - [推演过程](#推演过程-4)
        - [排序过程](#排序过程)
        - [堆构建过程](#堆构建过程)
        - [堆调整过程](#堆调整过程)
    - [稳定性](#稳定性-3)
    - [时间复杂度](#时间复杂度-3)
      - [最好的情况](#最好的情况-3)
      - [最坏的情况](#最坏的情况-3)
    - [空间复杂度](#空间复杂度-3)
    - [代码示例](#代码示例-3)
    - [优化](#优化-3)
- [插入排序](#插入排序)
  - [直接插入排序](#直接插入排序)
    - [算法过程](#算法过程-4)
    - [代码示例](#代码示例-4)
    - [稳定性](#稳定性-4)
    - [时间复杂度](#时间复杂度-4)
    - [空间复杂度](#空间复杂度-4)
    - [优化](#优化-4)
    - [二分插入排序](#二分插入排序)
      - [算法过程](#算法过程-5)
      - [代码示例](#代码示例-5)
    - [表排序](#表排序)
      - [算法过程](#算法过程-6)
      - [代码示例](#代码示例-6)
  - [希尔排序](#希尔排序)
    - [算法过程](#算法过程-7)
    - [代码示例](#代码示例-7)
    - [稳定性](#稳定性-5)
    - [时间复杂度](#时间复杂度-5)
    - [空间复杂度](#空间复杂度-5)
    - [优化](#优化-5)
- [归并排序](#归并排序)
  - [★ 二路归并排序](#-二路归并排序)
    - [算法过程](#算法过程-8)
    - [代码示例](#代码示例-8)
    - [稳定性](#稳定性-6)
    - [时间复杂度](#时间复杂度-6)
    - [空间复杂度](#空间复杂度-6)
    - [优化](#优化-6)
  - [多路归并排序](#多路归并排序)
- [分配排序](#分配排序)
  - [基数排序](#基数排序)
    - [算法过程](#算法过程-9)
    - [代码示例](#代码示例-9)
    - [稳定性](#稳定性-7)
    - [时间复杂度](#时间复杂度-7)
    - [空间复杂度](#空间复杂度-7)
    - [优化](#优化-7)
  - [桶排序](#桶排序)
    - [算法过程](#算法过程-10)
    - [代码示例](#代码示例-10)
    - [稳定性](#稳定性-8)
    - [时间复杂度](#时间复杂度-8)
    - [空间复杂度](#空间复杂度-8)
    - [优化](#优化-8)
- [其他排序](#其他排序)
  - [计数排序](#计数排序)
    - [算法过程](#算法过程-11)
      - [理论基础](#理论基础-5)
      - [推演过程](#推演过程-5)
    - [稳定性](#稳定性-9)
    - [时间复杂度](#时间复杂度-9)
    - [空间复杂度](#空间复杂度-9)
    - [代码示例](#代码示例-11)
    - [优化](#优化-9)
  - [煎饼排序](#煎饼排序)
- [其他](#其他)

# 参考资料

> 别人已经总结得够好了，没必要自己重复造轮子，理解了就行了

- [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/description)

- [★ 排序算法](https://www.cnblogs.com/xzwblog/p/7135983.html)

- [稳定排序和不稳定排序](https://blog.csdn.net/weixin_30562025/article/details/113012981)

- [五分钟算法 - 排序算法动画与解析](https://github.com/MisterBooo/Article)

- [★ 八大排序算法](https://blog.csdn.net/hguisu/article/details/7776068)

- [★ 十种排序算法总结](https://blog.csdn.net/jnu_simba/article/details/9705111)

- [九大排序算法再总结](https://blog.csdn.net/xiazdong/article/details/8462393)

# 排序总结

![alt](https://camo.githubusercontent.com/64f6d0498e1ebdc96f6aa8721eb17c96d13fc142b833df68dbbecc0fcc9ceef0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d376361663761386465633039356138302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

- `不稳定的排序`

  希尔排序、选择排序、堆排序、快速排序

- `时间复杂度`

  - 希尔排序: `O(n^3/2)`

  - 堆和快排和归并 `O(nlog2(n))`

  - 直接插入和二分插入、表插入、直接选择、冒泡都是 `O(n^2)`

- `空间复杂度`

  - 所有的简单排序方法（包括：直接插入、起泡和简单选择）和堆排序的空间复杂度为 `O(1)`

  - 快速排序为 `O(log2n)`，为栈所需的辅助空间

  - 归并排序所需辅助空间最多，其空间复杂度为 `O(n)`

  - 链式基数排序需附设队列首尾指针，则空间复杂度为 `O(rd)`

## 排序稳定性重要吗

> 可以避免不稳定排序`导致原来已经按某一属性排好的顺序打乱`

- 如果我们只对一串数字排序，那么稳定与否确实不重要，因为一串数字的属性是单一的，就是数字值的大小

- `排序的元素往往不只有一个属性`，例如我们对一群人按年龄排序，但是人除了年龄属性还有身高体重属性，在年龄相同时如果不想破坏原先身高体重的次序，就必须用稳定排序算法

# 交换排序

## 冒泡排序

![alt](https://camo.githubusercontent.com/2ccb6aeadb6f7ab539455635324280e58e858199a251888ad74bce6810a571b8/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d666166636634393939376435313165652e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

### 算法过程

#### 理论基础

- 比较相邻的两个元素，然后判断大小，进行交换

- 循环 `n-1` 遍，确定最大、第二大、第三大、第 n-1 大的元素

- 如比较 `arr[0]` 和 `arr[1]`, 如果 `arr[0] > arr[1]` 则交换; 然后比较 `arr[1]` 和 `arr[2]`

- 这样一轮循环下来就可以比较出那个元素是最大的元素了

#### `推演过程`

- 把未排序序列 `int arr = [5, 4, 2, 3, 8, 1]` 降序排序

- 比较 `arr[0] = 5` 和 `arr[1] = 4`，`5 > 4` 进行交换得到 `arr = [4, 5, 2, 3, 8, 1]`

- 比较 `arr[1] = 5` 和 `arr[2] = 2`，`5 > 2` 进行交换得到 `arr = [4, 2, 5, 3, 8, 1]`

- 比较 `arr[2] = 5` 和 `arr[3] = 3`，`5 >３` 进行交换得到 `arr = [4, 2, 3, 5, 8, 1]`

- 比较 `arr[3] = 5` 和 `arr[4] = 8`，`5 < 8` 不用进行交换

- 比较 `arr[4] = 8` 和 `arr[5] = 1`，`8 > 1` 进行交换得到 `arr = [4, 2, 3, 5, 1, 8]`

  至此，通过不断把大的数往后 **`推`**，序列中最大的数顺利就位在 `arr[n-1]`

- 继续寻找第 `n-1` 大的数，继续上述冒泡过程

- 第一轮遍历后，序列变为 `arr = [4, 2, 3, 5, 1, 8]`，接下来开始第二轮冒泡

- 比较 `arr[0] = 4` 和 `arr[1] = 2`，`4 > 2` 进行交换得到 `arr = [2, 4, 3, 5, 1, 8]`

- 比较 `arr[1] = 4` 和 `arr[2] = 3`，`4 > 3` 进行交换得到 `arr = [2, 3, 4, 5, 1, 8]`

- 比较 `arr[2] = 4` 和 `arr[3] = 5`，`4 < 5` 不用进行交换

- 比较 `arr[3] = 5` 和 `arr[4] = 1`，`5 > 1` 进行交换得到 `arr = [2, 3, 4, 1, 5, 8]`

- 比较 `arr[4] = 5` 和 `arr[5] = 8`，`5 < 8` 不用进行交换

  至此，第二轮冒泡结束，序列中第二大的数顺利就位在 `arr[n-2]`

### 稳定性

> `稳定`

#### 理论基础

关键操作是把元素往后推，可以控制相同元素就不交换，用后面的元素与下一个元素比较，所以还是稳定的

#### 推演过程

- 假如有序列 `int arr = [3, 5, 6, _3, 2, 9]`

- 按照冒泡排序的逻辑，两两交换，不断把第 n 大的元素 推到后面

- 而 `_3 < 5` 且 `_3 < 6`，所以把 `5` 和 `6` 往后推的时候，`_3` 和 `3` 值相同并不需要交换

- 所以并不会改变两个 3 的相对位置

### 时间复杂度

> `O(n) -> O(n^2)`，平均 `O(n^2)`

#### 最好的情况

第一轮冒泡过程，寻找第 `n` 大的过程中，如果没有发生交换的话，则说明序列已经有序了，所以最好的情况是 `O(n)`

#### 最坏的情况

从上面的推演过程也可以知道，每找第 `n` 大的数就要比较 `n-1` 遍，则复杂度为 `O(n) * O(n-1) = O(n^2)`

### 空间复杂度

> `O(1)`

交换的时候需要用一个临时变量

### 代码示例

```cpp
void bubbleSort(int s[], int len)
{
    // 因为每次只能确定第 n 大的数，要想全部数据有序，就要循环 n 次
    for (int i = 0; i < len; i++)
    {
        // 这层循环是找第 n 大的冒泡过程
        for (int j = 0; j < len - 1; j++)
        {
            if (s[j] > s[j + 1])
            {
                swap(s[j], s[j + 1]);
            }
        }
    }
}
```

### 优化

#### 优化一

记录一轮下来标记的最后位置，下次从头部遍历到这个位置就行了

```cpp
void bubble_sort_opt1(int s[], int len)
{
    int i, j, tmp;
    for (i = 0; i < len; i++)
    {
        /* 优化点：因为第 k 遍循环已经找到第 k 大了
          * 所以找第 k-1 大的时候，没必要考虑第 k 个元素，只需要循环 n-1 次
          * 所以找第 k-2 大的时候，没必要考虑第 k-1 个元素，只需要循环 n-2 次
          */
        for (j = 0; j < len - i - 1; j++)
        {
            if (s[j + 1] < s[j])
            {
                swap(s[j], s[j + 1]);
            }
        }
    }
}
```

#### 优化二

设置标志位，明显在寻找第 `n` 大的过程中，如果有一趟没有发生交换，说明排序已经完成

```cpp
void bubbleSortOpt2(int s[], int len)
{
    bool swap_flag = true;
    // 因为每次只能确定第 n 大的数，要想全部数据有序，就要循环 n 次
    for (int i = 0; i < len; i++)
    {
        swap_flag = false;
        // 这层循环是找第 n 大的冒泡过程
        for (int j = 0; j < len - 1; j++)
        {
            if (s[j] > s[j + 1])
            {
                swap(s[j], s[j + 1]);
                // 在寻找 第 i 大 的过程中发生了交换
                swap_flag = true;
            }
        }
        if(!swap_flag)
        {
            break;
        }
    }
}
```

## ★ 快速排序

![快速排序](https://camo.githubusercontent.com/eddb0d91c28d3a312ebbb9df0af5620176f191d5094e54925f8f9b7de14d0048/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d366430316661663037613231653733302e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

### 算法过程

- `分治思想`，当每次划分时，若都能分成两个等长的子序列时，那么分治算法效率会达到最大

> `arr = [3, 5, 8, 1, 2, 9, 4, 7, 6]`

#### 理论基础

- 其实就是一个分区的概念，找一个基准值，然后遍历一遍序列，小于基准的放左边，大于基准的放右边

- 然后就可以确定，`left < key < right`

- 以 `arr[key]` 作为分界点，继续对左右两侧的子序列重复上述操作

#### 推演过程

- 选择第一个元素作为基准: `key = 0, arr[key] = 3`

- 指针 `low` 从左到右找比 `arr[key]` 大的值

- 指针 `high` 从左到右找比 `arr[key]` 小的值

- 所以刚开始的时候，`low < high`

- 为什么要从左往右找小呢，因为是升序，把左边小的与右边大的交换后，大的就被赶到右边了

- 所以肯定有：`arr[low] < arr[key] < arr[high]`

- `.` 表示 `low` 指针位置 `。` 表示 `high` 指针位置

  ```cpp
  arr = [3, 5, 8, 1, 2, 9, 4, 7, 6]  // 原始序列
            .        。
  ```

- 交换 `arr[low]` 和 `arr[high]`

  ```cpp
  // 第一次交换后继续刚才的步骤
  // arr[low] = 8   arr[high] = 1
  arr = [3, 2, 8, 1, 5, 9, 4, 7, 6]
               .  。
  ```

- 继续交换

  ```cpp
  // 第二次交换后继续刚才的步骤
  // arr[low] = 8   arr[hight] = 1
  arr = [3, 2, 1, 8, 5, 9, 4, 7, 6]
               。 .
  ```

- 假如下标 `low >= high`，说明已经完成一次遍历了，为了让 `arr[key]` 站在中间（`左边< arr[key] < 右边`），用 `arr[key]` 和 `arr[high]` 做交换

  ```cpp
  arr = [1, 2, 3, 8, 5, 9, 4, 7, 6]
  ```

- 至此，已经，确认把比 `arr[key]` 小的挪到左面了，比 `arr[key]` 大的挪到右面

- 前面只保证了基准左侧比基准小，右侧比基准大，但是左右两侧都不是有序的，所以可以采用递归的方式来继续 `处理基准两边的数据`

### 稳定性

> `不稳定`

#### 理论基础

> `low` 从右到左找小；`high` 从左到右找大

- 当遍历完一遍序列时, `low >= high`，此时已经把小于 `arr[key]` 的交换到左边，大于 `arr[key]` 的交换到右边了

- 要把 `arr[key] 和 arr[low]` 做一次交换，确保 `arr[low] < arr[key] < arr[high]`

- 此时就会破坏原有的稳定性

#### 推演过程

- 假如有序列 `int arr = [4, 5, 3, 6, _3, 9]`（加个标记好说明这是后面的 3）

- 按照快排的逻辑（选基准应该不会影响到排序算法的稳定性，这里直接选第一个吧）

- 以下标 `0` 为基准

- 从右往左找到第一个比 `arr[0]` 小的数 `arr[4] = _3`

- 从左往右找到第一个比 `arr[0]` 大的数 `arr[2] = 5`

- 因为 `2 < 4` 还没有遍历完全部元素，先做一次交换

- 此时序列变成了 `[4 _3 3 6 5 9]`，所以是不稳定的排序

### 时间复杂度

> `O(n logn) -> O(n^2)`，平均 `O(n logn)`

#### 最好的情况

#### 最坏的情况

### 空间复杂度

> `O(long n)`

### 代码示例

```cpp
int Partition(int *a, int left, int right)
{
    int low = left, high = right;
    // 递归退出条件: 特殊请情况，左边大于右边了。。
    if (left > right)
    {
        return 0;
    }
    int key = a[left];

    while (low < high)
    {
        // 顺序很重要,先让 high 往左走
        // 因为当 low >= high 的时候是要交换 s[high] 和 key 的
        // 所以必须 high 的方向必须是寻找 < key 的方向

        // 找到第一个比 s[key] 小的元素
        while (a[high] >= key && low < high)
            high--;
        // 找到第一个比 s[key] 大的元素
        while (a[low] <= key && low < high)
            low++;

        if (low < high)
        {
            // 如果 low > high，即 s[low] 在 s[high] 右边
            // 而 s[high] < s[key] < s[low]，所以 s[high] 和 s[low] 是不需要交换的
            swap(a[low], a[high]);
        }
    }
    // 循环结束后，low >= high
    // 因为 s[high] 是小于 s[key] 的，所以交换二者值
    // 则以 s[key] 分界，左边都比 s[key] 小，右边都比 s[key] 大
    swap(a[left], a[high]);
    return high;
}

void quickSort(int a[], int left, int right)
{
    if (left < right)
    {
        int boundary = Partition(a, left, right);
        quickSort(a, left, boundary - 1);
        quickSort(a, boundary + 1, right);
    }
}
```

### 快排为什么比冒泡快

> [为什么快速排序比冒泡排序快](https://blog.csdn.net/wjh_monkey/article/details/86482912)

```cpp
假设 n = m + k
则有 n^2 = m^2 + k^2 + 2mk; n^2 > m^2 + k^2
     可见快排里的每次分区操作都会节省 2mk 的时间
```

### 快排为什么比堆排快

[堆排序与快速排序比较](https://blog.csdn.net/qq_34768115/article/details/85265140)

- 十万数据量两种排序速度基本相当，但是`堆排序交换次数明显多于快速排序`

- 堆排序的时间复杂度要比快速排序稳定，快速排序的最差的时间复杂度是 O（n\*n）, 平均时间复杂度是 O(nlogn)。堆排序的时间复杂度稳定在 O(nlogn)。但是从综合性能来看，快速排序性能更好

### ★ 优化成稳定排序

```cpp
/**
 * @function: 快速排序的稳定版本
 * @brief : 出现交换的地方：1. arr[low] 和 arr[high] 交换 2. arr[low] 和 arr[key] 交换
 * @param :
 * @return :
 */
void quickSortStable(int arr[], int left, int right)
{
    // ...
}
```

### 非递归实现

```cpp
/**
 * @function: 快排非递归实现
 * @brief  : 任何递归解法都可以借助栈转换为非递归
 * @param  :
 * @return :
 */
void quickSort2(int a[], int left, int right)
{
    //手动利用栈来存储每次分块快排的起始点
    //栈非空时循环获取中轴入栈
    stack<int> s;
    if (left < right)
    {
        int boundary = Partition(a, left, right);

        if (boundary - 1 > left) //确保左分区存在
        {
            // 将左分区端点入栈
            s.push(left);
            s.push(boundary - 1);
        }
        if (boundary + 1 < right) //确保右分区存在
        {
            s.push(boundary + 1);
            s.push(right);
        }

        while (!s.empty())
        {
            //得到某分区的左右边界
            int r = s.top();
            s.pop();
            int l = s.top();
            s.pop();

            boundary = Partition(a, l, r);
            if (boundary - 1 > l) //确保左分区存在
            {
                //将左分区端点入栈
                s.push(l);
                s.push(boundary - 1);
            }
            if (boundary + 1 < r) //确保右分区存在
            {
                s.push(boundary + 1);
                s.push(r);
            }
        }
    }
}
```

### 优化

[快速排序的优化](https://www.jianshu.com/p/6777a3297e36)

#### 基准值的选择

> 这个。。。感觉没啥好说的，主要是要兼顾时间和空间，要想把序列按大小划分成两个区域，肯定取 **`中位数`** 最合理啊

- 取第一个或者最后一个

  简单但很傻的选择。当 `输入序列是升序或者降序时`，这时候就会导致 S1 集合为空，除基准值外所有元素在 S2 集合，这种做法，最坏时间复杂度为 `O(n^2)`。

- 随机选择

  这是比较安全的做法。除非随机数发生器出现错误，并且连续产生劣质分割的概率比较低。但随机数生成开销较大，这样就增加了运行时间。

- 三数中值分割法

  一组序列的中值（中位数）是枢纽元最好的选择（因为可以将序列均分为两个子序列，归并排序告诉我们，这时候是 `O(NlogN)`；但要计算一组数组的中位数就比较耗时，会减慢快排的效率。但可以通过计算数组的第一个，中间位置，最后一个元素的中值来代替。比如序列：`[8，1，4，9，6，3，5，2，7，0]`。第一个元素是 8，中间 (left+right)/2 (向下取整)元素为 6，最后一个元素为 0。所以中位数是 6，即枢纽元是 6。显然使用三数分割法消除了预排序输入的坏情形，并且实际减少了 14%的比较

#### 序列本就基本有序

> 序列中给原本就有序，那根据快速排序的运行逻辑，时间复杂度会退化成冒泡的 `O(n^2)`

#### 序列存在大量重复元素时

# 选择排序

## 直接选择排序

> 选择排序 --- 直接选择排序 O(n) -> O(n^2)

### 算法过程

- 每趟都从未排序的序列 `arr` 中和序列的第一个数 `arr[0]` 做比较，

- 如果比它小，就更新 `minIndex` 循环后，肯定是最小元素的下标了

- 然后 `arr[minindex]` 和 `arr[0]` 比较，如果比它小，就交换两个元素的值, 所以一遍下来 `arr[0]` 就是待排序最小的元素了

```cpp
/*
 * 直接选择排序感觉还比较好理解，冒泡才是反人类的操作
 * 比如要把序列变成正序，那么 arr[0] 就是最小的，arr[1] 是次小的, arr[n-1] 是最大的0
 * 1. 从序列中找到最小的元素，放到 arr[0] 的位置
 * 2. 从序列中找到次小的元素，放到 arr[1] 的位置
 * ...
 * 最终就排好了，每找一个元素几乎都要遍历一遍序列
 */
```

### 代码示例

```cpp
void chooseSort(int s[], int len)
{
    int i, j;
    for (i = 0; i < len; i++)
    {
        for (j = i + 1; j < len; j++)
        {
            if (s[j] < s[i])
            {
                swap(s[i], s[j]);
            }
        }
    }
}
```

### 稳定性

> `不稳定`

- 关键操作是位置交换

- 现有未排序序列 `int arr = [3, 5, 6, _3, 2, 9]`

- 按照选择排序的逻辑，第一步找出序列最小的数，然后和 `arr[0]` 交换，

- 而 `2` 是序列中最小的元素，即 `arr[0]` 会和 `arr[4]` 做交换

- 交换之后 `3` 已经跑到 `_3` 右边去了，稳定性被破坏

### 时间复杂度

> `O(n^2) -> O(n^2)`，平均 `O(n^2)`

#### 最好的情况

#### 最坏的情况

### 空间复杂度

### 优化

```cpp
// 上面代码示例是找到小的就交换，如果有多个就会交换多次
// 可以先遍历找到最小元素的下标，再做一次交换就行了

void chooseSort(int s[], int len)
{
    int i, j, minIndex;
    for (i = 0; i < len; i++)
    {
        minIndex = i;
        for (j = i + 1; j < len; j++)
        {
            // 找出未排序中最小元素的下标
            if (s[j] < s[minIndex])
            {
                minIndex = j;
            }
            // 交换最小元素和s[j];
            if (minIndex != i)
            {
                swap(s[minIndex], s[i]);
            }
        }
    }
}
```

### 选择排序和插入排序有点像

- 看上去确实有点像，都是从无序序列中选择一个放入到有序序列中，但操作步骤还是有本质上的区别的

- 选择排序是，从无序序列中把`最小的带过来`，放进去，就放到有序序列最后面 arr[n]，坑位是确定的

- 插入排序是，从无序序列中`把下一个带过来`，再决定哪个坑位适合它，然后挪动一下

## ★ 堆排序

![堆排序](https://camo.githubusercontent.com/374302b5edfc5aa8f7f811437d966841f29bcd67643a918542ef3e7a4bfe275a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d303437613930376431363261346130622e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

### 算法过程

> - 如何将 n 个待排序的数建成堆
> - 输出堆顶元素后，怎样调整剩余 `n-1` 个元素，使其重新满足大/小根堆的特性

#### 理论基础

> - 大根堆：每个节点的值都 `大于或等于` 左右孩子节点的值
> - 堆的子树不像二叉查找树那样，子树也要满足二叉查找树的特性；而是在移除堆顶后，要把剩下节点调整成堆
> - 堆是一颗`完全二叉树`（即：最右边位置上有一个或者几个叶结点缺少外，其他是丰满的）

- 将待排序的序列构造成一个大根堆，此时整个序列的最大值就是堆顶的根结点

- 将它移走(其实就是将其堆数组的末尾元素交换, 此时末尾元素就是最大值)

- 然后将剩余的 `n-1` 个序列重新构造成一个堆,这样就会得到 `n` 个元素的次大值

- 如此反复执行，便能得到一个有序序列了

- 下标为 `i` 或 `i + 1` 的父节点是 `i / 2`

- 下标为 `i` 的子节点为 `2 * i` 和 `2 * i + 1`

#### 推演过程

> - 未排序序列构建成堆
> - 升序：大根与末尾元素交换，或 小根与首位元素交换
> - 调整未排序序列，继续上诉过程

现有未排序序列 `int arr = [5, 2, 7, 3, 6, 1, 4]`

##### 排序过程

- 根据节点下标关系可以对应一棵`完全二叉树`

  ```sh
  # 待排序序列 5, 2, 7, 3, 6, 1, 4
  # 下标      1, 2, 3, 4, 5, 6, 7
  # 对应以下这棵树
             5
          /     \
         2       7
       /   \   /   \
      3     6 1     4
  ```

- 对未排序序列 `arr[0] ~ arr[len - 1]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
          7
       /      \
      6         5
    /   \     /   \
  3      2   1     4
  ```

- 因为构造的是大根堆，所以第一个元素肯定是最大的；要升序排序，就要把最大的元素放到最后，`swap(arr[0], arr[len - 1])`

  ```sh
  # 交换 arr[0] 和 arr[len - 1]
          4
       /      \
      6         5
    /   \     /   \
  3      2   1     (7)   # 括号表示已经调整后的元素
  ##此时序列变成了 4, 6, 5, 3, 2, 1, (7)
  ```

- 对剩下的未排序序列 `arr[0] ~ arr[len - 2]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
           6
       /      \
      4         5
    /   \     /   \
  3      2   1     (7)
  ```

- 再把堆的首尾元素做交换 `swap(arr[0], arr[len - 2])`

  ```sh
           1
       /       \
      4          5
    /   \      /    \
  3      2   (6)    (7)
  ## 此时序列变为  1, 4, 5, 3, 2, (6, 7)
  ```

- 对剩下的未排序序列 `arr[0] ~ arr[len - 3]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
          5
       /      \
      4         1
    /   \      /   \
  3      2   (6)    (7)
  ```

- 再把堆的首尾元素做交换 `swap(arr[0], arr[len - 3])`

  ```sh
          2
       /      \
      4         1
    /   \      /   \
  3     (5)  (6)    (7)
  # 此时序列变为 2, 4, 1, 3, (5, 6, 7)
  ```

- 对剩下的未排序序列 `arr[0] ~ arr[len - 4]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
           4
       /        \
      3           1
    /   \       /   \
  2     (5)   (6)    (7)
  ```

- 再把堆的首尾元素做交换 `swap(arr[0], arr[len - 4])`

  ```sh
            2
       /          \
      3             1
    /   \         /   \
  (4)     (5)   (6)    (7)
  # 此时序列变为 2, 3, 1, (4, 5, 6, 7)
  ```

- 对剩下的未排序序列 `arr[0] ~ arr[len - 5]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
            3
       /          \
      2             1
    /   \         /   \
  (4)     (5)   (6)    (7)

  ```

- 再把堆的首尾元素做交换 `swap(arr[0], arr[len - 5])`

  ```sh
            1
       /         \
      2            (3)
    /   \         /   \
  (4)     (5)   (6)    (7)
  # 此时序列变为 1, 2, (3, 4, 5, 6, 7)
  ```

- 对剩下的未排序序列 `arr[0] ~ arr[len - 6]` 调整节点，保持大根堆特性

  ```sh
  # 调整之后的大根堆为：
            2
       /         \
      1            (3)
    /   \         /   \
  (4)     (5)   (6)    (7)
  ```

- 再把堆的首尾元素做交换 `swap(arr[0], arr[len - 6])`

  ```sh
            1
       /        \
      (2)         (3)
    /   \         /   \
  (4)     (5)   (6)    (7)
  # 此时序列变为 1, (2, 3, 4, 5, 6, 7)
  ```

- 最后只剩下一个节点，排序结束

  - 整个过程跟`直接选择排序`确实很像（一开始还不理解为什么堆排属于选择排序）
  - 升序排序，这里用了`大根堆 + 大根与未排序列末尾交换`，也可以 `小根堆 + 小根与未排序列首位元素交换`

##### 堆构建过程

- 把未排序序列 `int arr = [5, 2, 7, 3, 6, 1, 4]` 构建一个大根堆

  ```sh
  # 待排序序列 5, 2, 7, 3, 6, 1, 4 对应着一棵完全二叉树，现在要把这棵树调整成大根堆
  # 下标      1, 2, 3, 4, 5, 6, 7
             5
          /     \
         2       7
       /   \   /   \
      3     6 1     4
  ```

- `n` 个结点的完全二叉树，则最后一个结点是第 `⌊n/2⌋ (向下取整)` 个结点的子树

##### 堆调整过程

- 把未排序序列 `int arr = [5, 2, 7, 3, 6, 1, 4]` 调整成大根堆

  ```sh
  # 上一个步骤已经得到了一个大根堆
              7
           /      \
          6         5
        /   \     /   \
      3      2   1     4

  # 大根堆的根与最后一个元素交换，然后进行堆调整
             4
          /     \
         6       5
       /   \   /   \
      3     2 1     (7)
  ```

- 将根结点与左、右子树中较大元素的进行交换

  ```sh
  # [4] < 5 < 6; [4] 表示 4 是根；交换 6 和 4
             6
          /     \
         4       5
       /   \   /   \
      3     2 1     (7)
  ```

- 交换后，递归调整根为 `6 的右子树`（即根为 5 的树），发现右子树已经是大根堆

- 调整根为 5 右子树（为空）

- 调整根为 5 左子树（树根为 1）

- 调整根为 1 的右子树（为空）

- 调整根为 1 的左子树（为空）

- 同理，递归调整根为 `6 有左子树`（树根为 4）

- 至此，堆调整完成

- 然后，继续`【交换】大根堆堆顶和未排序序列末尾元素、交换后【调整堆】` 步骤

### 稳定性

> `不稳定`

- 有未排序序列 `int arr = [5, 2, 7, 3, 6, 1, _5]`

  ```sh
  # 构建大根堆
                7
             /      \
            6         5
          /   \     /   \
        3      2   1     _5
  ```

- 交换堆顶与末尾元素

  ```sh
                _5
             /      \
            6         5
          /   \     /   \
        3      2   1    (7)
  ```

- 调整堆

  ```sh
                6
             /      \
            _5        5
          /   \     /   \
        3      2   1    (7)
  ```

- 交换堆顶与末尾元素

  ```sh
                1
             /      \
            _5        5
          /   \     /   \
        3      2  (6)   (7)
  ```

- 调整堆

  ```sh
  # 与第一次调整步骤保持一致，先调整左子树
                _5
             /      \
            1         5
          /   \     /   \
        3      2  (6)   (7)

                _5
             /      \
            3         5
          /   \     /   \
        1      2  (6)   (7)
  ```

### 时间复杂度

> `O(nlogn)`

#### 最好的情况

#### 最坏的情况

### 空间复杂度

### 代码示例

```cpp
/**
 * 堆排序调整
 * 树下标从1开始, 则i结点的左儿子为 2*i , 右儿子为 2*i+1
 *
 * @param   : len 表示最大结点下标
 * @param   : k   表示子树根结点下标
 * @return  :
 */
void sink(int *s, int len, int k)
{
    // 这里为什么判断的是左儿子?
    // 如果判断右儿子，那么当k只有左儿子没有右儿子，而且左儿子比根大，则不会交换了
    while (2 * k <= len) // k的儿子结点下标不能超过总结点数
    {
        // 左儿子
        int j = 2 * k;
        if (j < len && s[j] < s[j + 1])
            // 不能是=，为了不让j+1操作越界; 找树根下标为k的大儿子
            j++;

        if (s[k] > s[j])
            // 这里不需要j<len了，j已是大儿子了，直接作比较, 根比大儿子还大, 无需交换
            break;

        swap(s[j], s[k]);
        k = j;
        // 调整子树，此时j已等于大儿子下标了（因为大儿子和根做交换，所以会导致大儿子的子树不满足堆结构）
    }
}

/**
 * @function: 堆排序
 * @brief   : 这里构建的二叉树下标是从 1 开始的
 *            下标为 i 或 i+1 的父节点都是 i/2
 *            下标为 i 的子节点为 2*i、2*i + 1
 * @param   : len 为节点数
 * @return  :
 */
void heapSort(int *s, int len)
{
    // step1: 构建堆
    // 1. 从最后一个叶子结点的父节点开始
    for (int k = len / 2; k >= 1; k--)
    {
        sink(s, len, k);
    }
    // 既然 sink 函数会调整子树，为什么不直接sink(s, len, 1)?
    // 不可以这样，因为如果根都比左右儿子大的话，就不会做后面的调整了，
    // 所以需要从下往上调整

    // step2: 调整交换
    for (; len > 1;)
    {
        // 将堆顶元素与末尾交换，使最大元素沉到数组末尾
        //（因为是小根堆，所以末元素肯定是最大的）
        swap(s[1], s[len]);
        // 已交换元素不用再参与调整(此时s[len]元素已经就位了)
        len--;
        // 重新调整剩下的元素，使其满足堆定义
        sink(s, len, 1);
    }
}
```

### 优化

```cpp
// 【下标从0开始进行堆排】
/*
i结点的左右孩子分别为： 2i+1 2i+2
i结点的父节点为：
i/2：       i 为左孩子结点；
i/2-1：     i 为右孩子结点；
*/
void sink2(int *s, int len, int k)
{
    // 结点k的子结点下标不超过总结点, 叶子节点不处理(和下标从1开始的逻辑就这里有差异)
    while (2 * k + 1 <= len)
    {
        int j = 2 * k + 1;
        if (j < len && s[j] < s[j + 1])
        {
            j++;
        }
        if (s[k] > s[j])
        {
            break;
        }
        swap(s[j], s[k]); // 这里下标从0 ~ len-1，不会越界，可放心用swap函数
        k = j;
    }
}

void heapSort2(int *s, int len)
{
    len -= 1; // 下标从0开始

    // 如果len为左结点, 则父节点为len/2，如果为右节点，则父节点为len/2 - 1
    // 这里从len/2开始调整，因为即使len为右节点，len/2为父节点的下一个结点(肯定是最后一层的最左边的叶子结点,sink函数不处理叶子结点，所以可以以len/2开始)
    // 所以为了保持和下标从1开始的代码一致，这里也可以写成len/2
    //  for (int k = len / 2 - 1; k >= 0; k--) // 这样也可以
    for (int k = len / 2; k >= 0; k--) // 和下标从1 开始差异是k>=0
    {
        sink2(s, len, k);
    }

    // 和下标从1开始差异是，这里是0
    for (; len > 0;)
    {
        swap(s[0], s[len]);
        len--;
        sink2(s, len, 0);
    }
}
```

# 插入排序

## 直接插入排序

### 算法过程

- 已排序的序列为 A,刚开始只有一个元素,从 s 中取元素与已排序的 a 中的元素做比较

- 找到合适的位置，最后插入到 a 中

- 移动元素可以不断做交换或者用前一个元素直接将后一个元素覆盖

- 最形象的比喻就是算法导论里的整理扑克牌的例子了

  - 从牌堆里拿出一张牌

  - 与手里的牌做比较，不断向后/前挪动牌的位置，插入到其应在的位置

    插入排序效率瓶颈就在这：比较牌大小、向后/前挪动牌的位置

### 代码示例

```cpp
void insertSort1(int s[], int len)
{
    int tmp, i, j;
    // for (i = 1; i < len; i++)
    for (i = 0; i < len; i++)
    {
        tmp = s[i]; // 需要插入的数据
        /*
         * 取出下一个元素，在已排序的序列中从后向前扫描直到找到一个比 s[i] 小的值
         * 为什么要用减减呢?
         * 因为左侧是有序序列，右侧是待插入序列，这个将要插入的元素在有序序列右侧
         * 有序序列可以占用这个待插入元素的位置
         */
        for (j = i - 1; j >= 0 && s[j] > tmp; j--)
        {
            // 第一个元素当然也要比较，所以 j 可以为 0
            // 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
            // 直到找到已排序的元素小于或者等于新元素的位置
            s[j + 1] = s[j];
        }
        /*
        // 这样写看的清晰点
        // 从有序序列从后往前遍历，寻找插入位置
        for (j = i - 1; j >= 0; --j)
        {
            if (s[j] >= tmp)
                s[j + 1] = s[j];
            else
                break; // 找到插入位置就可以退出
        }
        */
        // 循环退出的时候, j指向 < tmp 的值的下标
        // 因为把元素复制后移了, 所以s[j+1]就是腾给tmp的
        s[j + 1] = tmp; // 注意j要在for外定义
    }
}

// 另一种写法
void insertSort2(int a[], int len)
{
    for (int i = 1; i < len; i++)
    {
        if (a[i] < a[i - 1])
        {
            //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
            int j = i - 1;
            int x = a[i];    //复制为哨兵，即存储待排序元素
            a[i] = a[i - 1]; //先后移一个元素
            while (x < a[j])
            { //查找在有序表的插入位置
                a[j + 1] = a[j];
                j--; //元素后移
            }
            a[j + 1] = x; //插入到正确位置
        }
    }
}
```

### 稳定性

> 稳定

- 关键操作是挪动有序序列中的元素，可以控制相等就不挪动，所以还是稳定的

```cpp
 int arr = [3, 5, 6, _3, 2, 9]

 0. 有序序列初始只有一个元素，即 int sorted_arr = [3]
 1. 按照插入排序的过程，取 5 插入到有序序列中，sorted_arr = [3, 5]
 2. 继续取 6 插入到有序序列，sorted_arr = [3, 5, 6]
 3. 继续取 _3 插入到有序序列，sorted_arr = [3, _3, 5, 6]
 4. 和 冒泡一样，元素相同，可以不挪动，所以是稳定的排序
```

### 时间复杂度

> `O(n) -> O(n^2)`

- 最坏的情况是序列原本就基本有序

### 空间复杂度

> `O(1)` 借用了一个元素临时存储值

### 优化

- `优化找位置的过程`

  因为是把牌插入到有序的序列中，所以可以通过 **二分查找** 来快速找到其应在的位置

- `优化插入过程`

  用数组存储，肯定要一个个来挪动啊，但是如果用链表就剩去挪动操作了

### 二分插入排序

> 优化插入排序的 `寻找插入位置` 的过程

#### 算法过程

二分插入排序比直接插入排序好就好在可以用二分法较快地查找到需要插入的元素在已经排好序的序列中的位置, 比较次数为 O(log2(n))

#### 代码示例

```cpp
void binSort(int a[], int len)
{
    int i, j, left, mid, right, tmp;
    for (i = 1; i < len; i++)
    {
        tmp = a[i];
        left = 0;
        right = i - 1;
        while (left <= right)
        {
            mid = (left + right) / 2;
            if (a[mid] <= tmp)
                left = mid + 1;
            else
                right = mid - 1;
        }
        // 二分查找结束的时候, left肯定就是应该插入的位置

        for (j = i - 1; j >= left; j--)
            // 把left后面的元素往后挪动
            a[j + 1] = a[j];

        // 如果新插入的元素要比已排序序列中的元素都大,就没有必要做对换了
        if (left != i)
            a[left] = tmp;
    }
}
```

### 表排序

> 优化插入排序的 `插入元素` 的过程

#### 算法过程

#### 代码示例

```cpp
typedef int DataType;
struct Node;
typedef struct Node* PNode;

struct Node
{
    DataType info;
    PNode link;
};
typedef struct Node* LinkList;

void ListSort(LinkList llist)
{
    Node *pre, *p, *q, *now, *head;
    head = llist;
    pre = head->link;
    if (pre == NULL)
        return;
    now = pre->link;
    if (now == NULL)
        return;
    while (now != NULL)
    {
        q = head;
        p = head->link;
        while (p != now && p->info <= now->info)
        {
            q = p;
            p = p->link;
        }
        if (p == now)
        {
            pre = pre->link;
            now = pre->link;
            continue;
        }
        pre->link = now->link;
        q->link = now;
        now->link = p;

        now = pre->link;
    }
}
```

## 希尔排序

### 算法过程

### 代码示例

### 稳定性

> 不稳定

### 时间复杂度

### 空间复杂度

### 优化

# 归并排序

> 适用于大文件排序，分而治之，拆分成小文件再排序

![归并排序](https://camo.githubusercontent.com/f1271f5697f6d1c3d4b37ee800c5324222bc858549cafa1b4d42cbb68c5f3e7f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d643364343030363836626336316333302e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970)

![alt](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

## ★ 二路归并排序

### 算法过程

> 归并排序 = 分治策略 + 合并两个有序序列

- 假设初始序列含有 n 个记录, 则可以看成 n 个有序的子序列, 每个子序列的长度为 1

- 然后两两归并, 得到(不小于 n/2 的最小整数)个长度为 2 或 1 的有序子序列

- 如此重复,直至得到一个长度为 n 的有序序列为止, 这种排序方法称为 2 路归并排序

### 代码示例

```cpp
void merge(int *a, int start, int mid, int end)
{
    if (start > mid || mid > end)
        return;

    // step 1. 申请空间
    // 大小为两个已经排序序列之和，该空间用来存放合并后的序列
    int *L = (int *)malloc((end - start + 1) * sizeof(int));

    // step 2. 设定两个指针
    // 最初位置分别为两个有序序列的起始位置，还有一个指向合并后的新序列
    int i = start;
    int j = mid + 1;
    int k = 0;

    // step 4. 重复步骤3直到某一指针超出序列尾
    while (i <= mid && j <= end)
    {
        // step 3. 比较两个指针所指向的元素
        // 选择相对小的元素放入到合并空间，并移动指针到下一位置

        // arr1 =[1 2 5 7]; arr2 = [3 4 6 9]
        // arr1[0] < arr2[0] 所以把 arr1[0] 的值赋值给新序列的第一个元素 L[0]
        // 然后 k++，去寻找第二个元素；此时因为 arr1[0] 已经被拿走了，所以 i++ 开始比较下一个元素
        // 但是 arr2 序列由于 pk 失败，所以 j 还指着第一个元素，要和 arr1 剩下的元素做 pk
        if (a[i] < a[j])
            L[k++] = a[i++];
        else
            L[k++] = a[j++];
    }
    // step 5. 将另一序列剩下的所有元素直接复制到合并序列尾

    // 如果是因为 j > end 退出上面那个循环，即 左侧序列比右侧序列长
    while (i <= mid)
        L[k++] = a[i++];

    // 如果是因为 i > mid 退出上面那个循环，即 右侧序列比左侧序列长
    while (j <= end)
        L[k++] = a[j++];

    //将排序好的序列从临时L重新复制到a中
    for (i = start, j = 0; i <= end; i++, j++)
        a[i] = L[j];
    free(L);
}

/**
 * 二路归并排序
 *
 * @param arr 待排序序列
 * @param start 序列开始下标 0
 * @return end  序列结束下标 n-1
 */
void mergeSort(int *arr, int start, int end)
{
    if (start < end)
    {
        // 取中间数对待排序序列进行拆分
        int mid = (start + end) / 2;
        // 递归左侧序列
        mergeSort(arr, start, mid);
        // 递归右侧序列
        mergeSort(arr, mid + 1, end);
        // 最后做合并
        merge(arr, start, mid, end);
    }
}
```

### 稳定性

> 稳定

### 时间复杂度

> `O(nlogn)`

### 空间复杂度

> - `O(n+logn)`
> - 如果非递归实现归并,则避免了递归时深度为 logn 的栈空间 `O(n)`

### 优化

## 多路归并排序

# 分配排序

## 基数排序

### 算法过程

### 代码示例

### 稳定性

### 时间复杂度

### 空间复杂度

### 优化

## 桶排序

### 算法过程

### 代码示例

### 稳定性

### 时间复杂度

### 空间复杂度

### 优化

# 其他排序

## 计数排序

> 位图: 通过标记二进制位来表示数据的状态

### 算法过程

#### 理论基础

把未排序元素标记到位图中就行了，然后按照位图顺序输出，就是有序的了

#### 推演过程

- 把未排序序列 `int arr = [5, 2, 8, 3, 6, 1, 4]` 进行排序

- 序列中元素最大值为 7， `7 / 8 + 1 = 1`，一个字节有 8 位，用一个字节即可表示完

- `bitmap[0] = {0};`，一个字节有 8 位 `[0 0 0 0 0 0 0]` 通过把第 5 位标记为 1 表示数字`5`

- 全部标记完后，位图变为 `[1 0 1 1 1 1 1 1]`，然后再遍历位图输出对应的元素，`8 6 5 4 3 2 1` 即可

### 稳定性

### 时间复杂度

> `O(n)`

- 需要遍历所有数据，对位图进行初始化

- 需要遍历位图，输出所有数据

  数字范围是 1 到 10 亿，用位图存储 125M 就够了，然后将 1 亿个数字依次添加到位图中，再将位图按下标从小到大输出值为 1 的下标，排序就完成了，时间复杂度为 O(n)

### 空间复杂度

### 代码示例

```cpp
void countSort(int &array)
{
    int N = 1000000;
    int i ;
    double bit = 0 ;
    //用一个字符串来表示位图
    //先初始化位向量
    //使用逻辑运算实现位向量，在保证其他位不变的情况下，将某位变成1，应该使用或运算，改变位为1，其他位都为0。使用移位运算
    for( i = 0 ; i < N ; ++i)
    {
        bit |= (1 << array[i]);
    }
    //再进行输出
    for( i = 0 ; i < N ; ++i )
    {
        //判断某一位是否是1，同样用移位运算，用1对该位进行“与”运算
        if(bit & (1<<i))
        {
            printf("%d", i);
        }
    }
}
```

### 优化

## 煎饼排序

# 其他
