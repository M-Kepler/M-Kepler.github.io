- [数据结构与算法复习](#数据结构与算法复习)
  - [前面](#前面)
    - [基础知识](#基础知识)
      - [数据结构分类](#数据结构分类)
      - [时空复杂度](#时空复杂度)
  - [数组和矩阵](#数组和矩阵)
  - [广义表](#广义表)
  - [线性表](#线性表)
    - [顺序表](#顺序表)
    - [链表](#链表)
  - [栈和队列](#栈和队列)
    - [栈](#栈)
      - [链式存储](#链式存储)
      - [顺序存储](#顺序存储)
      - [表达式计算](#表达式计算)
      - [出栈顺序和序列总数](#出栈顺序和序列总数)
    - [队列](#队列)
      - [链式存储](#链式存储-1)
      - [顺序存储](#顺序存储-1)
  - [二叉树](#二叉树)
    - [基本](#基本)
    - [二叉树和森林的转换](#二叉树和森林的转换)
    - [线索二叉树](#线索二叉树)
    - [森林的遍历](#森林的遍历)
    - [概念、性质](#概念性质)
    - [二叉树的表示方法](#二叉树的表示方法)
    - [先序、层次创建](#先序层次创建)
    - [层次遍历](#层次遍历)
    - [完全二叉树](#完全二叉树)
    - [满二叉树](#满二叉树)
    - [扩充二叉树](#扩充二叉树)
    - [哈夫曼树（最优二叉树）](#哈夫曼树最优二叉树)
    - [堆](#堆)
    - [优先队列（堆）](#优先队列堆)
    - [二叉排序树](#二叉排序树)
      - [删除](#删除)
    - [AVL(平衡二叉树)](#avl平衡二叉树)
      - [LL 型](#ll-型)
      - [RR 型](#rr-型)
      - [LR 型](#lr-型)
    - [二叉树与森林](#二叉树与森林)
    - [哈希](#哈希)
    - [解决哈希冲突的方法](#解决哈希冲突的方法)
  - [字典的散列表示（散列表）](#字典的散列表示散列表)
    - [散列法](#散列法)
      - [解决碰撞](#解决碰撞)
  - [排序](#排序)
    - [不稳定的排序](#不稳定的排序)
    - [时间复杂度](#时间复杂度)
    - [辅助空间](#辅助空间)
    - [分配排序](#分配排序)
  - [图](#图)
    - [概念、性质](#概念性质-1)
    - [图的存储](#图的存储)
    - [图的周游](#图的周游)
      - [DFS](#dfs)
      - [BFS](#bfs)
    - [最小生成树](#最小生成树)
      - [Prime](#prime)
      - [Kruskal](#kruskal)
    - [最短路径算法](#最短路径算法)
      - [Dijkstra](#dijkstra)
      - [Floyed](#floyed)
    - [拓扑排序](#拓扑排序)
    - [关键路径 AOE](#关键路径-aoe)

# 数据结构与算法复习

- [可视化](https://visualgo.net/)

- [可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

## 前面

### 基础知识

- 算法设计的目标
  - 正确性、易读性、健壮性、较好的时空性能
- 算法设计的重要特征
  - 有穷性、确定性、可行性、0 个或多个输入、1 个或多个输出
- 数据

  - 数据的三个层次：数据、数据元素（数据的基本单位）、数据项（数据的最小单位）
  - 数据对象是 性质相同 的数据元素的集合
  - 数据结构是 带有结构 的数据元素的集合
  - 数据的物理结构：包括数据元素+元素间关系
  - 数据的逻辑结构：指数据的组织形式

- 语句频度

#### 数据结构分类

数据结构是由数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三方面组成的。

- 按照逻辑结构分
  包括线性结构、非线性结构（集合、树形、图形、网形）
- 按照存储（物理）结构分类
  顺序结构（如：有序表）、链式结构、索引、散列
- 运算
  包括检索、排序、插入、删除、修改

#### 时空复杂度

- [文章](http://m.blog.csdn.net/article/details?id=48013181)

- 加法规则

  ```sh
  两段程序上下连在一起
  T(n)=T1(n)+T2(n)=O(n^2)+O(n^5)=O(max(n^2, n^5))
  就是说时间复杂度是两端程序中最大的那段的时间复杂度
  ```

- 乘法规则

  ```sh
  如果程序出现循环，那就是要用乘法规则了
  T(n)=T1(n) _ T2(n)=O(n^2) _ O(n^5)=O(n^2 \* n^5)
  ```

- 常见复杂度
  ![alt](https://user-gold-cdn.xitu.io/2020/4/16/1718350727a28018?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  ```sh
  O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)
  c   <   log2n  <  n  <   n*log2n  <  n^2  <  n^3  <  2^n  < 3^n  <  n!
  |--------------------------|--------------------------|-------------|
          较好                           一般                  较差
  ```

- 如果程序中不存在循环，额，**其实是运算时间与输入规模无关**，那基本就是常数级别,时间复杂度为 O(1)

- O(n)是说算法需要的时间与 n 成正比，n 越大，所花时间越多

- 如果程序中，循环变量成倍增加或等比减少，那复杂度肯定是对数级了，既有 log

- 比如

  - 求阶乘的递归函数
    实质不按递归按程序看，展开就是 n 个数相乘，复杂度就是 O(n)
  - 双重循环

    ```sh
    for(i=0 →n-1)
        for(j=i→n-1)
            Jsjsjsjsjjs #被执行了 n\*(n+1)/2 次
    ```

## 数组和矩阵

- 数组元素下标计算 \*矩阵存储时求矩阵元素位置
- 稀疏矩阵是一般压缩存储方法为：三元组和十字链表

## 广义表

- 广义表也是由零个或多个元素组成的序列，但和线性表不同，广义表达元素类型不要求相同
- 广义表表头是广以表第一个元素，只有非空广义表才能取表头

- 广义表表尾总是一个广义表，表尾是指去除表头元素后剩余的元素所组成的表

- 定义和性质：
  广义表可简单表示为 LS=(a1,a2...，an)，其中 al,a2...an 是广义表的元素，可以是
  原子(不可能再分割)，也可以是广义表的子表。

广义表的长度定义为广义表的最高层所含元素的个数(即用逗号分开的最高层元素个
数，不包括子表)，最高层的元素(如上面的 al,a2，..，，an)具有线性关系(前驱和后继)。

广义表的深度定义为括号的层数，空广义表的深度是 1.

非空广义表的取头运算结果是广义表的第一个元素(原子或子表)，而取尾运算结果是非空广义表除去第一个元素后所剩元素的子表，肯定是广义表。

以 24 题为倒，说的明以上概念
已知广义表((), (a), (b, c, (d), ((d, f))))

表长 3，含 3 个元素, 深度是 4, 4 层括号，表头为空表(),

- 线性表中的元素具有相同性质，属于同一数据对象。广义表中的元素有原子，有子表，不具有同一性质，因此严格说，广义表不是线性结构。但是，当广义表中的元素都是原子时，广义表蜕变成线性表。

## 线性表

- 线性表是 0 个或多个元素的有穷序列
- 通常采用顺序存储和链式存储
- 线性表中所有数据元素的类型必须相同
- 顺序结构是通过结点物理上相邻来表示元素之间是关系的，而链式则是通过指针

### 顺序表

线性表是顺序存储结构是一种**可随机存取**的存储结构

### 链表

循环链表最大的优点是：从任一结点粗大都可以访问到链表中的每一个元素

- 头结点
  头指针指链表的指针，若链表有头结点则是链表的头结点的指针，头指针具有标识作用，故常用头指针冠以链表的名字。头结点是为了操作的统一、方便而设立的，放在第一元素结点之前，其数据域一般无意义(当然有些情况下也可存放链表的
  长度、用做监视哨等)。有头结点后，链表指针(即头指针)值是确定的，无论链表是否为空，头指针均不为空;对于链表操作，特别是插入或删除结点是第一元素结点的操作，就不用再作判断，与对其他结点的操作就统一了
- 静态链表
  用数组来存放，所以也是需要一片连续的区域的，结点中的指针表示的是下一个元素在数组里的位置
- 各种链表
- 带头/尾指针对单循环链表
- 双向链表/双向循环链表
- 👆 要知道在这些链表上的各种操作
  链表的逆置、插入、删除、查找、合并等

## 栈和队列

### 栈

#### 链式存储

![alt](http://images.51cto.com/files/uploadimg/20090706/150401842.jpg)

```cpp
//      push()
p ->data = x;
p ->link = plstack -> top; //新元素的指针域指向栈顶元素。
plstack -> top = p;     //新加入的元素作为栈顶。
//     pop()
p = plstack -> top;
plstack ->top = plstack -> top -> link; //栈顶元素的下一个元素作为新的栈顶。
```

#### 顺序存储

#### 表达式计算

- 前中后缀的表达式的转换：
- 人脑
  用括号把每个运算括起来，然后把括号里的运算符提出括号前/后，最后去掉所有括号就成了，多练

- 电脑
  读入中缀遇到数字就输出。如果读取到运算分量就输出。读到一般操作符 `+ - _ /` 要与栈顶操作符比较优先级，若优先级**高于栈顶**才有资格入栈，否则先让栈内的运算符输出你才可以入栈，另外，左括号被认为是优先级最低的运算符，所以 -(\_ 顺序是正确的，但遇到有括号的时候把有括号**弹出**，然后把右括号到左括号之间的运算符依次**输出**，然后把做括号也弹出，继续上述。

- 后缀表达式的运算
  读到分量就压入栈，读到符号就从栈里弹出两个运算分量进行运算，并把运算结果压入栈
  这里人脑和电脑过程一样，只不过做题的话可以直接看，不用画栈的示意图，从左往右看这个后缀表达式，看到运算符就对运算符左边的运算分量进行该运算，然后得到的结果作为一个数呆在那个位置，继续下去

#### 出栈顺序和序列总数

- 判断出栈顺序
  这个比较简单，假如在入栈序列中 `p < q < r` 且 p，q，r 也是入栈的顺序，那么在出栈序列中在 r 后面的比它小的元素按照降序排列。
  既：入栈是 升序/降序，那么出栈的话在元素 M 后面 小于/大于 M 的元素应该是 降序/升序 的（入账元素是字符的话，可以假设前面的都比后面的小啊）
- 所有可能的出栈序列数（卡塔兰数）

### 队列

- r 指向的是将要插入元素的下标，而不是队顶元素的位置

#### 链式存储

![alt](http://images0.cnblogs.com/blog2015/640685/201506/281011570806381.jpg)

```
//push()
//r表示尾，f表示头
if(plqueue ->f == NULL)
     plqueue->f = p;
else
     plqueue ->r -> link = p;
plqueue->r =p;

//pop()
p = plqueue ->f;
plqueue -> f = p ->link;
free(p);
```

#### 顺序存储

- 循环队列
  循环队列人队、出队、求元素个数的运算都要用取模运算。总共 m 个元素，若入队，则新元素位置 rear-(rear+1)%m，出队则 front=(front+1)%m，队空 front=rear，队满是
  (rear+1)%m=front，队列元素总数是 ( rear - front + m)%m
- 假溢出

## 二叉树

### 基本

- 度为 m 的树中，叶子结点个数的求解公式是 `n0=1+ ∑ ( i-1)\*ni`，其中 ni 是度为 i 的结点数。

### 二叉树和森林的转换

利用长子兄弟法（左长子，右兄弟）

### 线索二叉树

- ❌❌ 序线索树
  线索二叉树是对于左一右指针表示法的一种修改。它利用结点的空的左指针
  (llink)存储该结应在某种周游序列中的前驱结点的位置；利用结点的空的右指针
  (rlink)存储该结点在同种周游系列中后继结点的位置。这种附加的指向前驱结点和后的指针称为线索

### 森林的遍历

和二叉树的访问时一样的
比如先根序列，就先访问根节点，然后是最左子树然后从左到右的子树
如果是多棵树，就从左到右，访问完一棵然后下一棵

---

二叉树的性质：
(1) 在非空二叉树中，第 i 层的结点总数不超过 2^(i-1),i>=1；
(2) 深度为 h 的二叉树最多有 2^h-1 个结点(h>=1)，最少有 h 个结点；
(3) 对于任意一棵二叉树，如果其叶结点数为 N0，而度数为 2 的结点总数为 N2，则 N0=N2+1；
(4) 具有 n 个结点的完全二叉树的深度为 K =[log2n」+1(取下整数)
(5)有 N 个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若 I 为结点编号则 如果 I>1，则其父结点的编号为 I/2；
如果 2*I<=N，则其左儿子（即左子树的根结点）的编号为 2*I；若 2*I>N，则无左儿子； 如果 2*I+1<=N，则其右儿子的结点编号为 2*I+1；若 2*I+1>N，则无右儿子。 (6)给定 N 个节点，能构成 h(N)种不同的二叉树。h(N)为卡特兰数的第 N 项。h(n)=C(2\*n，n)/(n+1)。
（7）设有 i 个枝点，I 为所有枝点的道路长度总和，J 为叶的道路长度总和 J=I+2i

### 概念、性质

- 层数：从 0 开始(2^0)，高度 = 层数 + 1
- 度数 + 1 = 结点数
- 非空二叉树第 i 层结点至多`2^i`个结点
- 高度为 K 的二叉树中，最多有 `2^(k+1) - 1`个结点
- `n0 = n2 + 1`

### 二叉树的表示方法

1. 长子兄弟表示法
   ![alt](http://img.blog.csdn.net/20130613202310968)
2. 子表表示法
   ![alt](http://img.blog.csdn.net/20130923134244609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb3Rpbmc0NTEyOTI1MTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
3. 父指针表示法
   ![alt](https://upload.wikimedia.org/wikipedia/commons/c/ca/Sqll.jpg)

### 先序、层次创建

### 层次遍历

### 完全二叉树

> 叶子只出现在最后两层，最后一层结点都分布在左边
> 深度：log2(n) n 为结点数

- 因为 n=n0+n1+n2，n2=n0-1，所以
  是**n=2n0+n1-1**。在**完全二叉树**中，n1 取 1 或 0。而一般的树没有这个规定，在完全二叉树结点计算中，仅知一个量(总结点数，叶子数，度为 2 的结点数)求其他量，一般就利用该公式）
- 另外，如果题目给的是叶子结点的数目，根据上述公式，我怎么知道 n1 是取 0 还是取 1 呢？如果说给叶子结点数是偶数，根据完全二叉树的定义除 h 层以外 1 到 h-1 层的结点数都达到最大。**n0=2^m-a**，如果 a 为偶数那么 n1 取 0，为奇就取 1 不知道是不是正确的

### 满二叉树

> 度数只可能是 n0、n2
> 深度为 k 的完全二叉树去掉第 K 层就变为满二叉树了

### 扩充二叉树

添加外层结点，把原树中的结点的度数都补为 2

外部结点个数 m 比 内部结点个数 n 多一
N - n = 1
外部路径 E 内部路径 I
E=I + 2n
路径长度：根结点到该节点经过的边数

![alt](http://hi.csdn.net/attachment/201106/26/0_1309071565dUUp.gif)

### 哈夫曼树（最优二叉树）

WPL(带权外部路径长度) = 所有结点的左右儿子的和的和

构造哈夫曼树：
构造：每次都从给定权值的序列中选取最小的两个作为左右儿子，他们的和作为父亲。
把父亲放回原序列中，继续上述操作。
（因为肯定有一个内部结点是带着两个外部结点的啊，如果反过来，先放置最大的，由于树结构不确定，很难得到最优）

哈夫曼序列：
对哈夫曼树编码，连接左儿子的边标 0，右儿子的边标 1。A 结点的编码是从根节点往下到 A 节点读到的数值（如 0011）
![alt](http://images.cnblogs.com/cnblogs_com/xiaosuo/DataStructure/57.jpg)

不知道输入法候选字的排序是不是就是这个原理

### 堆

大小根堆：每个子二叉树的根均大于/小于其左右子树
堆排序

### 优先队列（堆）

遵从最小元素先出的原则

https://www.cnblogs.com/9dragon/p/10739121.html

### 二叉排序树

这里我居然什么都没写我靠
二叉树的创建、增删查改

- 查找
  注意：声明了一个变量 position，无论是否查找到，都会将 position 赋值为该节点应该在的位置的父节点

- 插入
  前面说过经过 search 函数后 position 就是应该插入的位置的父节点了，所以只要判断一下该插到左边还是右边就可以了

插入的先后次序不同，所构成的二叉排序树的形态和高度是不同的

插入的结点肯定是插到 🍃 叶子那里，绝不是说把结点插在某两个结点中间

#### 删除

- 没有要删除的结点
  return 0
- 所删除结点是叶结点
  直接将该结点的父结点的左/右赋值为 null
- 所删除结点没有左 / 右子树
  将用该结点的右 / 左儿子替代它的位置
- 所删除结点为根结点

- 所删除结点非根结点，且左右子树非空
- 用该结点左子树里最大的结点替换该结点
  如果该结点还有左子树的话，就相当于删除结点没有右子树的情况。还需要调整

- 用该结点右子树里最小的结点替换该结点，由于这个最小的结点肯定是叶结点，所以和用左子树最大结点替换不同，这里不存在需要调整的情况

- 用被删除结点左子树的根结点替换，并且将被删除节点的右子树接到左子树的最右结点上

- 可上面的雷同

越靠近根，ASL 越小
最佳排序树，让 ASL 尽可能得小 (结点尽可能靠近根)
ASL = [(层数 * 结点数)的和] / n
(每个结点被找到都要经过层数 n 次的比较)

### AVL(平衡二叉树)

树中每个结点的 左右子树高度之差 <= 1
这个差的多少决定了这棵树是不是平衡的，就叫这个差值为平衡因子吧（前面学习散列的时候有个碰撞因子记得吗）

在平衡二叉排序树中插入新结点有可能会影响到该结点的父结点为根的子树的高度。可能会导致这棵树不再平衡

AVL 树的调整，调整并不会影响到树的深度
最小不平衡子树：指离插入结点最近，且其左右子树的高度差大于 1 的树

> 平衡因子 bf

#### LL 型

如果在最小不平衡子树的左儿女的左子树添加一个结点就会不平衡

LL 型：![ll](http://hi.csdn.net/attachment/201104/6/106689_1302084936IP2I.jpg)

> b:h+1+1 a:h avg = h+1
> A->llink = B->rlink;
> B->rlink = A
> A->bf = B->bf = 0

#### RR 型

![alt](http://hi.csdn.net/attachment/201104/6/106689_1302084939o44u.jpg)

#### LR 型

![alt](http://hi.csdn.net/attachment/201104/6/106689_13020849378y93.jpg)

> c:h+2 b:h+1 a:h avg = h+1
> A->llink = C->rlink;
> B->rlink = C->rlink;
> C->llink = B; C->rlink = A;

### 二叉树与森林

> 通过长子兄弟表示法来相互转换（左儿子，右兄弟）

### 哈希

> 数组的特点: 查找容易, 插入删除困难
> 链表特点: 查找困难, 插入删除容易

- 原理

  - 哈希表（也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。
  - 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度; 这个映射函数叫做散列函数，存放记录的数组叫做散列表。 `string --> key = hash(string)`

- 哈希表的应用
  - 安全领域
    如 md5、sha1 等消息摘要算法, 用来判断文件完整
  - 查找
    拿到 string 的 key 值后, 就能知道该 string 存储在哪了
  - 词频问题
  - top-k 问题
  - 查找问题

### 解决哈希冲突的方法

> 不同的内容经过同一个散列函数后得到的 key 值可能是相同的, 这样叫发生冲突(碰撞)

- 缓冲区
  把有冲突的数据都放到缓冲区, 如果在哈希表查不到就去缓冲区找
- 二次探测法
  如果发现数组下标为 hash(string)中已有值了, 就往右找(或者同时往左找)第一个没值的位置存放
- 再次哈希法
  这种方法是同时构造多个不同的哈希函数： Hi=RH1（key） i=1，2，…，k
  当哈希地址 Hi=RH1（key）发生冲突时，再计算 Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。
- 拉链法
  对于相同的 key = hash(string)值的数据, 则以 key 为链表头结点, 往后拉出一条链表, 所有 key 相同的数据都插入到链表中

## 字典的散列表示（散列表）

- 动态字典：
  一般用平衡二叉排序树构造
  为了在插入删除元素的操作时，较快得对二叉排序树进行调整，在检索率 asl 和调整速度上 🤣 🉐适当取舍，这里通常不要求二叉排序树总是保持最佳的检索效率而希望二叉树可以比较容易快速调整好。

- 静态字典：
  一般用最佳二叉排序树构造
  因为最佳二叉排序树的 asl 是较小的，但是如果经过几次插入结点删除结点的操作的话都要在此构造排序树这种构造的时间代价是很高的，所以最好不要频繁更改删除，所以更适合用来表示一旦构造后就不做改动的静态字典

- `ASL = ASL=∑PiCi (i=1,2,3,…,n)` 平均检索长度

  Pi 为查找表中第 i 个数据元素的概率，Ci 为找到第 i 个数据元素时已经比较过的次数

散列法表示的字典中执行元素的检索运算平均可能达到常数的时间

### 散列法

散列函数： h(key)
就是关键码到地址的映射函数，散列函数要考虑的就是怎么处理好这种关系，才能唯一确定这个值

key ------h(key)------> 地址(也叫基本区域)
把计算出来的 h(key)存放到指示的地址上
碰撞 h(key1) = h(key2)

> 可以用负载因子来评估是否会发生碰撞
> a=字典节点数 / 地址空间能容纳的节点数
> 显然 a>1 就肯定会发生碰撞

- 除余法
  选择一个适当的整数 P，用 P 去除关键码，余数作为散列地址，既 h(key)=key%P

#### 解决碰撞

- 线性探查法：
  选定散列函数后计算出所有关键码对应的散列地址，假设基本区域(地址空间)用数组 elements 来表示，h(key)作为数组下标，key 作为元素的值，将刚才算出来的散列地址对应填到数组中，如果没有发生重复最好，发生重复也就是碰撞 💥，就需要用线性探查法来解决碰撞，解决的方法是：比如 A 经过散列对应的空间为 elements[3]，B 对应的地址空间也是 elements[3]，那就对下一个空间 elements[4]...进行探查，直至找到一个空的地址空间然后把 B 安置进去
  ![alt](http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg)

> ASL = 所有 h(key)的和除以 n

- 拉链法
  本来想说说线性探查法的弊端的，但是发现它的思路过程和这个拉链法是一样的，只不过用的数据结构不同而已。
  同样，先根据散列函数计算出关键码对应的散列值，然后以这个散列值为头节点的数据域拉出一条链表，所有散列值一样的关键码作为新节点的数据域插入到这条链表后面。
  这样，有多少个散列地址就会有多少条链表了
  ![alt](http://img.blog.csdn.net/20150916151516136)

---

## 排序

http://www.cnblogs.com/w-wanglei/p/3314459.html
![alt](http://www.2cto.com/uploadfile/Collfiles/20140814/20140814091634272.png)

### 不稳定的排序

> Shell、直接选择、堆排序、快速排序

### 时间复杂度

> Shell:O(n^3/2)、堆和快排和归并 O(nlog2(n))、直接插入和
> 二分插入、表插入、直接选择、冒泡都是 O(n^2)

### 辅助空间

> - 所有的简单排序方法（包括：直接插入、起泡和简单选择）和堆排序的空间复杂度为 O(1)；
> - 快速排序为 O(log2n )，为栈所需的辅助空间；
> - 归并排序所需辅助空间最多，其空间复杂度为 O(n )；
> - 链式基数排序需附设队列首尾指针，则空间复杂度为 O(rd )。

### 分配排序

## 图

### 概念、性质

> 一些约定：
> <Vi, Vj>表示由 Vi 到 Vj 的有向边
> (Vi, Vj) 表示 i 和 j 之间的一条无向边
> V(G) 表示点集 E(G)表示边集
> D(v)表示度，ID(v)表示出度，OD(v)表示出度，有向图的度=ID+OD

- 连通图
  每个点之间都是（直接或间接）连通的

- 连通分量
  即图 G 的最大连通子图
- 如果 G 不是连通图，而这子图是连通的，而当把图 G 中的一些点边加入到这个子图后它就不连通了，所以 G 的连通分量并不是唯一的
- 如果 G 是连通图，那它只有一个连通分量，就是它本身

- **强**连通图
  对于**有向**图而言，即有 Vi 到 Vj 的路径 也有 Vj 到 Vi 的路径则，则称 G 为强连通图（有向连通图中有的不是强连通的）
- 强连通分量
  强连通图的最大强连通分量就是其本身
  非强连通图的连通分量有多个

- 完全图
  每个点之间都是直接连通的

- 生成树
  用最少的边把所有的点（间接或直接）连接起来

- 有向**完全图**的边数：e = n(n-1)

- 无向完全图的边数：e = n(n-1)/2

  因为完全图的定义是每两个点之间都是有边相连，所以一个点就有 n-1 条边与之相连，但是对于无向图，这样算肯定算重复了 i -j 和 j-i 的，所以对于有向完全图 n 个点总和就是 E = n \* (n-1)，对于无向完全图 e =E/2

- 有向无向图：边数 = 度数和 / 2

- 图中度数为奇数的结点个数为偶数

- 子图：图的顶点和边组成的图

- 生成子图：顶点数不变 + 边数变少

- 简单路径：路径中没有经过重复的点

- 回路(环)：起点和终点相同的简单路径

- 有根图
  有向图中，从定点 V 出发，可以走遍图的所有顶点，称 V 为这个有根图的根（这不就是连通图吗）

- 生成树：周游时经过的边 + 图的所有顶点
- 最小生成树：权值最小的生成树

- DFS/BFS 生成树

### 图的存储

- 邻接矩阵

- 邻接表
  ![alt](http://images.cnblogs.com/cnblogs_com/xiaosuo/DataStructure/44.jpg)

### 图的周游

#### DFS

深度优先搜索是类似于树的一种先序遍历：V1，V2，V4，V8，V5，V3，V6，V7.
![alt](http://img.blog.csdn.net/20130603151418281)

#### BFS

广度优先搜索类似于树的层次遍历，广度优先搜索次序为：V1，V2，V3，V4，V5，V6，V7,,V8.
![alt](http://img.blog.csdn.net/20130603151426015)

### 最小生成树

- 生成树：用最少的边把所有的点连接起来
- 最小生成树：权值和最小的生成树
- 最小生成树存在 ↔ 图是连通的
  很明显啊，最小生成树需要包含图的所有顶点，如果不连通怎么包含？
- 图有 n 个顶点，那最小生成树肯定是有 n-1 条边
- 不可以构成回路
  声明：
  图 G 的点集 V(G)、边集 E(G)
  生成树的点集 V1(G)、边集 E1(G)

#### Prime

- Prime(每次选取`距离最近的点`加入到集合 U 中)是动态规划的思想，所谓动态规划，就是记住自己已知的未知的，不要混淆已知与未知的界限，同时不断利用已知的知识以及自己对当前情况的判断去扩展已知的花式技法。重要的是你要有一个起点，一个能够不断等新已知与未知边界的迭代函数。这既是动态规划算法的精要。
  步骤：
  0 初始化邻接矩阵，把 🐟 与非邻接点的边权值置为 65535
  1 从图的点集中随便选择一个初始点 V0 加入到点集，V1(G)={v0}
  2 从以点集 V1(G)中的点为起点的边中选择权值最小的 e1 加入到边集 E1(G)、这条边的另一个端点 v2 如果不在点集 V1(G)中(如果在集合中还选这条边的话就构成回路了)，就加入到 V1(G), V1(G)={v0, v1}
  3 如此反复，直到所有点都加入到 V1(G)中

- Prime 普利姆算法求最小生成树时候，**适合求稠密图**所以使用邻接矩阵来存，时间复杂度为 O（n\*n）。

- 是不是和求最短路径的 Dijkstra 算法有点像？都是把一步一步把图中点划到集合来求解，**动态规划**啊

- 怎么找到生成树中所有点的邻接点中，边的权值最小的邻接点的？
  出现这个问题是因为一开始就假设 V 中有了很多点，所以要找到下一个合适的点的话就要考虑 V 中所有点的邻接点，还要保证这些邻接点不在 V 中，然后还要从中找到权值最小的点，确实很复杂！
  但实际上不是这样的，这是一个动态规划的思想，是一个动态的过程。比如 V={v0}，初始化时已经有了 v0 到所有点的权值，然后扫一边 Edge 数组，发现(v0, v1)权值最小，就把 v1 加到 V 中，这时 V={v0, V
  1}，然后比较(v1, v2)和(v0, v2)，如果发现(v1, v2)的权值比较小就把(v0,v2, weight-02)改为(v1,v2,weight-12)，同样去 更新到其他点的起点和权值 ，所以当加入下一个节点的时候同样去操作，这是动态地更新。

![alt](http://images.cnitblog.com/blog/497120/201404/101459086223439.jpg)

#### Kruskal

每次选取`权值最小的边`加入到集合 U 中
贪心的思想
对图中所有的权值进行排序，每次选择权值最小的边，如果和已选的边形成了环路就舍弃这条边，如此反复直到图中所有的边都被选择过

### 最短路径算法

#### Dijkstra

和 prime 算法很类似，也是 BFS 思想，也是贪心和动态规划
[Dijkstra 详解](http://m.blog.csdn.net/article/details?id=51014824)

#### Floyed

### 拓扑排序

- AOV（Activity On Vertex network）
- 用于描述工程中各种活动间的约束关系
  就比如排课系统(在学习数据库的时候接触过)：想修数据结构的话继续先修程序设计语言和离散数学，想修编译技术的话需要先修数据结构和算法语言，高等数学没有先修课程.....，那怎么对这些课程进行合理安排教学呢，这就是拓扑排序需要做的

- 将这些关系对应到图上
  这将是个**有向无环的图**，所以不会是连通图，有向边表示课程和课程之间的关系(如 A→D 表示需要先修 A 课程才能修 D 课程）

- 算法思想

- 从 aov 网中选择一个**入度为 0 的顶点**将其输出

- 在 aov 网中删掉这个顶点以及它所有的出边，删掉后可能存在几个入度为 0 的顶点，所以拓扑排序是不唯一的

- 如此反复，直到所有顶点都输出，排序结束

- 如果剩下的顶点的入度都不为 0，那证明这个 aov 网存在回路，拓扑排序无法进行

### 关键路径 AOE

- 上面 aov 网是用来表示活动的安排，aoe 网则是用来表示活动的计划过程。上面虽然啊是带权有向边，但是权值的作用没有发挥出来。

- 比如：A---5--→B---9→C 表示崇从 A 活动开始着，需要 5 天完成才能进入活动 B，活动 B 需要 9 天完成才能进入活动 C

  所以可以知道：aoe 也是一个**带权有向无权图**，而且**只有一个入度为 0 的开始顶点和一个出度为 0 的完成顶点**。

- 那么对于这个工程施工图

- 完成这项工程需要多少时间？

- 那些活动是影响工程进度的关键活动？
