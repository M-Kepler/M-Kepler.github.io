- [为什么要使用消息队列](#为什么要使用消息队列)
  - [消息队列的本质](#消息队列的本质)
    - [解耦](#解耦)
    - [异步](#异步)
    - [流量削峰](#流量削峰)
- [各消息队列产品比较](#各消息队列产品比较)
- [各消息队列选型总结](#各消息队列选型总结)
- [消息队列的优点和缺点](#消息队列的优点和缺点)
- [如何保证消息队列的高可用性](#如何保证消息队列的高可用性)
  - [rabbitMQ 的高可用性](#rabbitmq-的高可用性)
    - [rocketMQ 的高可用性 - 双主双从](#rocketmq-的高可用性---双主双从)
- [如何保证消息不【丢失】](#如何保证消息不丢失)
  - [消息丢失的原因](#消息丢失的原因)
  - [确保消息不丢失方案](#确保消息不丢失方案)
- [如何保证消息不被【重复消费】](#如何保证消息不被重复消费)
  - [发送时消息重复](#发送时消息重复)
  - [消费时消息重复](#消费时消息重复)
  - [解决消息重复发送问题（消幂次等性）](#解决消息重复发送问题消幂次等性)
- [如何保证消息的【顺序】性](#如何保证消息的顺序性)
- [大量消息【堆积】怎么处理](#大量消息堆积怎么处理)
  - [堆积消息的原因](#堆积消息的原因)
  - [消息堆积的处理方案](#消息堆积的处理方案)
- [消息【过期】怎么处理](#消息过期怎么处理)
  - [消息过期的原因](#消息过期的原因)
  - [消息过期的处理方案](#消息过期的处理方案)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/weixin_39265427/article/details/107418735)

## 为什么要使用消息队列

> 这个问题主要考察为什么使用消息队列？在项目中为了解决什么问题？

### 消息队列的本质

- 消息队列是一种 “先进先出” 的数据结构

- 常见应用场景：解耦、异步、削峰

#### 解耦

订单系统强依赖 “支付系统”、“库存系统”、“物流系统” 的返回结果。图一为强耦合关系，图二为消息队列解耦后。

![alt](https://img-blog.csdnimg.cn/20200717222615800.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

![alt](https://img-blog.csdnimg.cn/20200717222615839.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

#### 异步

![alt](https://img-blog.csdnimg.cn/2020071722314997.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

![alt](https://img-blog.csdnimg.cn/2020071722330135.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

#### 流量削峰

![alt](https://img-blog.csdnimg.cn/20200717223436126.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

![alt](https://img-blog.csdnimg.cn/20200717223512440.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

## 各消息队列产品比较

| 特性       | `activeMQ`                                                    | `RabbitMQ`                     | `rocketMQ`             | `Kafka`                                          |
| ---------- | ------------------------------------------------------------- | ------------------------------ | ---------------------- | ------------------------------------------------ |
| 特性       | activeMQ                                                      | rabbitMQ                       | rocketMQ               | kafka                                            |
| 开发语言   | java                                                          | erlang                         | java                   | scale                                            |
| 单机吞吐量 | 万级                                                          | 万级                           | 十万级                 | 十万级                                           |
| 时效性     | ms                                                            | us                             | ms                     | ms 以内                                          |
| 可用性     | 高 （ 主从模式 ）                                             | 高（主从模式）                 | 非常高（集群模式）     | 非常高（集群模式）                               |
| 功能特性   | 成熟的产品 ，在很多公司得到应用 ， 有较多的文档，各种协议支持 | 并发性很强，性能极好，延时很低 | 功能比较完备，扩展性佳 | 只支持一些主要的 mq 功能，在大数据领域使用非常广 |

## 各消息队列选型总结

- `ActiveMQ`

  早期使用较多，没经过大规模吞吐量场景验证，社区不是很活跃，现在使用的不多，不推荐

- `RabbitMQ`

  - 开发语言使用 erlang，对于 java 开发工程师二次开发门槛较高，但 rabbitMQ 是开源的，社区活跃度较高，追求性能和稳定性的话，推荐使用。

  - 开发语言是 java，在阿里内部经受过高并发的考验，稳定性和性能军不错，若考虑二次开发，推荐使用。

- `Kafka`

  大数据领域的实时计算、日志采集等场景。用 kafka 业内的标准，社区活跃，推荐使用。大数据领域、日志采集等业务推荐使用。

## 消息队列的优点和缺点

- 优点

  解耦、异步、流量削峰

- 缺点

  系统可用性降低、系统复杂性提高、一致性问题

## 如何保证消息队列的高可用性

### rabbitMQ 的高可用性

- 普通集群模式

  消息只存贮在 mq 某个实例上，其他节点从通过 queue 的元数据从该实例的 queue 取数据

  **特点**：没有做到真正的高可用；数据拉取开销和单实例的瓶颈问题。

  ![alt](https://img-blog.csdnimg.cn/20200717231014291.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

- 镜像集群模式

  ![alt](https://img-blog.csdnimg.cn/20200717231446212.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

#### rocketMQ 的高可用性 - 双主双从

![alt](https://img-blog.csdnimg.cn/20200717231721529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

## 如何保证消息不【丢失】

### 消息丢失的原因

- 消息生产者没有成功发送到 MQ broker

- 消息发送到 mq broker 后，broker 宕机导致内存中的消息数据丢失

- 消费者消费了消息，但是没有处理完毕就发生异常导致消息丢失。

  ![alt](https://img-blog.csdnimg.cn/20200717232520996.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

### 确保消息不丢失方案

- 发送方可靠发送

- mq 进行消息持久化

- 消费放完成消费后进行 ack 确认，mq 收到 ack 确认再删除本地消息

  ![alt](https://img-blog.csdnimg.cn/20200717232625265.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

## 如何保证消息不被【重复消费】

> 即保证消息的幂等性

重复消息产生的根本原因：网络不可达

### 发送时消息重复

![alt](https://img-blog.csdnimg.cn/20200717233321459.PNG#pic_center)

### 消费时消息重复

![alt](https://img-blog.csdnimg.cn/20200717233353654.PNG#pic_center)

### 解决消息重复发送问题（消幂次等性）

- 消息发送者发送消息时携带一个全局唯一的消息 id

- 消费者获取消费后先根据 id 再 db/redis 查询消息是否成功消费

- 如果没有消费过直接消费，消费完成后写入 db/redis

- 如果消费过则不予处理

## 如何保证消息的【顺序】性

- **全局顺序消费**：`生产者 : MQ : 消费者 = 1 : 1 : 1`

- **局部顺序消费**

- 生产者根据消息 id 将同一组消息发送到一个 queue 中

- 多个消费者同时获取 queue 中的消息进行消费

- mq 使用分段锁保证单个 queue 中的有序消费

  ![alt](https://img-blog.csdnimg.cn/20200718000317811.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

## 大量消息【堆积】怎么处理

### 堆积消息的原因

- 网络故障

- 消费方处理消息后没有给 mq broker 正常应答

  ![alt](https://img-blog.csdnimg.cn/20200718000655339.PNG#pic_center)

### 消息堆积的处理方案

- 检查并修复消费方的正常消费速度

- 将堆积的消息转存到容量更大的 mq 集群

- 增加多个消费者节点并行消费堆积消息

- 消费完毕后，回复原始架构

  ![alt](https://img-blog.csdnimg.cn/20200718001104491.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

## 消息【过期】怎么处理

### 消息过期的原因

给消息设置了过期时间，如果超时还未被消费，则视为消息过期。过期消息可以转存到死信队列。

![alt](https://img-blog.csdnimg.cn/20200718001622811.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)

### 消息过期的处理方案

- 过期消息进入到死信队列

- 启动专门的消费者消费死信队列消息，并写入数据库记录日志

- 查询数据库消息日志，重新发送消息到 mq

  ![alt](https://img-blog.csdnimg.cn/20200718002120286.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI2NTQyNw==,size_16,color_FFFFFF,t_70#pic_center)
