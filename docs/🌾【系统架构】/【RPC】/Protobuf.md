- [参考资料](#参考资料)
- [Protobuf](#protobuf)
  - [★ `protobuf` 比 `json` 好在哪](#-protobuf-比-json-好在哪)
  - [数据压缩演变过程](#数据压缩演变过程)
    - [【优化方案一】去除 JSON 字符串中的多余空格](#优化方案一去除-json-字符串中的多余空格)
    - [【优化方案二】按约定数据结构传输，节省 KEY 的空间占用](#优化方案二按约定数据结构传输节省-key-的空间占用)
    - [★【优化方案三】采用 TAG 技术来标识每一个字段](#优化方案三采用-tag-技术来标识每一个字段)
    - [【优化方案四】 增加 VALUE 值长度信息](#优化方案四-增加-value-值长度信息)
- [其他](#其他)

# 参考资料

- [Protobuf 原理分析小结](https://www.jianshu.com/p/522f13206ba1)

- [protobuf 序列化 / 反序列化性能及问题](https://blog.csdn.net/s_sunnyy/article/details/69242098)

- [protobuf 中会严重影响时间和空间损耗的地方](http://blog.chinaunix.net/uid-26922071-id-3723751.html)

- [protobuf 为什么那么快](https://www.jianshu.com/p/72108f0aefca)

# Protobuf

## ★ `protobuf` 比 `json` 好在哪

> - 尽量去削减传输 KEY 所产生的花销
> - 感觉像位图那样，用二进制位来表示 KEY 的类型和数据的位置

- 在高性能和大数据通信的系统当中，如果有办法可以`压缩数据量，提高传输效率`，显然会给用户带来更快更流畅的体验。

- `protobuf、json、xml` 三者比较

  - `xml` 规范下的每一个属性和值都是固定的标签形式，导致序列化后的字节流文件很大

  - 相对于 `xml` 来说，`json` 格式语法简单，自由度较高，有很高的可读性，并且在 `JSON` 序列化后的字节流小于 `xml` 序列化的结果，解析起来更方便

  - `protobuf` 优点在于性能开销很小，压缩率很高，但是缺陷也很明显，`可读性很差`，并且需要使用特定语言的库进行翻译转换，使用起来较为麻烦

## 数据压缩演变过程

假设我们要传递这个数据到对端，如果用 json 格式字符串来传，一个字符一个字节，则会占用 67 个字节

```py
data = '{ "age": 30, "name": "zhangsan", "height": 175.33, "weight": 140 }'
```

### 【优化方案一】去除 JSON 字符串中的多余空格

中间空格太多了，浪费空间，去掉空格之后占用多少 57 个字节

```py
data = '{"age":30,"name":"zhangsan","height":175.33,"weight":140}'
```

### 【优化方案二】按约定数据结构传输，节省 KEY 的空间占用

上面都传了 `key-value` 数据过去，但是如果对端知道传过来的数据格式，就没必要传 KEY 了，直接按约定传 VALUE 就好了

比如 c 里面大家都定义好了结构体，发送端直接发数据过去，接收端按照也用同样的结构体来接收，由于字节对齐的原因，以下结构将占用 40 个字节

```cpp
struct people {
    int age;
    char name[20];
    double height;
    int weight;
};

// 对于 32 位机器: 一个字节 8 位，一段表示一个字节， 字节对齐原则，放不下就不要了
//
// ******** ******** ******** ********  age 4 字节
//
// ******** ******** ******** ********
// ******** ******** ******** ********
// ******** ******** ******** ********
// ******** ******** ******** ********
// ******** ******** ******** ********  name 20 字节
//
// ******** ******** ******** ********
// ******** ******** ******** ********  height 8 字节
//
// ******** ******** ******** ********  weight 4 字节
// 一共占用 40 字节
```

### ★【优化方案三】采用 TAG 技术来标识每一个字段

还有个问题，比如 name 为空时，也会`占`用 20 个字节，明显浪费了，可是不要又不行，因为已经跟对端说了按照这个结构体来接受数据，Protobuf 采用 tag 技术，主要作用是用来标识每一个字段

```cpp
message get_data_req
{
    int32 age = 1; // 这里的序号 1 和数据类型 int32 构成了 age 字段的 tag

    // 类型有一个二进制与其映射，序号也有一个二进制与其映射
    // 比如 string name = 2;
    // 假设 string 类型映射后为 1，二进制为 0001；值 2 二进制位 0010
    // 所以 name 字段的 tag 为 0001 0000 + 0000 0010 = 0001 0010
    string name = 2;
    double height = 3;
    int32 wright = 4;
}
```

每个字段我们都用 `tag|value` 的方式来存储的，在 `tag` 当中记录两种信息，一个是 `value` 对应的字段的编号，另一个是 `value` 的数据类型（比如是整形还是字符串等）

因为 tag 中有字段编号信息，所以即使没有传递 `name` 字段的 `value` 值，根据编号也能正确的配对，取数据时就不会发生错位

`tag|value` 和 `key-value` 区别在于 json 中的 key 使用字符串来表示的，一个字符就一个字节了，而 **`tag 用的是二进制来存储的`**，一个字节就有八位了

### 【优化方案四】 增加 VALUE 值长度信息

虽然上一层已经对 k-v 做了优化，但是我们现在也只是优化了 key 部分，比如 string name = 2; 我们并不知道 name 有多长，因此就不得不去做字符串匹配操作，把值取出来，优化方法也很明显，我只要告诉你字段有多长就行了。

# 其他

- 区分大小写吗
