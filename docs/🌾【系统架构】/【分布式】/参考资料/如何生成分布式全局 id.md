- [1. 使用 UUID 生成全局 id](#1-使用-uuid-生成全局-id)
- [2. 基于数据库自增或者序列生成全局 id](#2-基于数据库自增或者序列生成全局-id)
- [3. 基于 redis 生成全局 id](#3-基于-redis-生成全局-id)
- [4. 基于 Twitter 的雪花算法（snowflake）生成全局 ID](#4-基于-twitter-的雪花算法snowflake生成全局-id)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/ming-blogs/p/10453762.html)

### 1. 使用 UUID 生成全局 id

UUID 是一个字符串而且没有顺序，所以不适合做主键，可以 做 token 使用。

利用全球唯一 UUID 生成订单号 UUID 基本概念: UUID 是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。

UUID 组成部分: 当前日期和时间 + 时钟序列 + 随机数 + 全局唯一的 IEEE 机器识别号 全局唯一的 IEEE 机器识别号: 如果有网卡，从网卡 MAC 地址获得，没有网卡以其他方式获得。

- `优点`

  简单，代码方便 生成 ID 性能非常好，基本不会有性能问题 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对

- `缺点`

  没有排序，无法保证趋势递增 UUID 往往是使用字符串存储，查询的效率比较低 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。 传输数据量大

一般 UUID 在生成 Token 领域使用比较多

### 2. 基于数据库自增或者序列生成全局 id

如果使用数据库 id 自增生成订单号的话，如果数据库是集群的话 则有可能生成相同的订单号。

所以如果我们使用数据库 id 自增做为全局 id 的话我们需要设置**步长，**步长表示每次自动增长的数量。

假如现在有 3 台 MySql 数据库做集群，mysql1，mysql2，mysql3。

设置 mysql1 数据库 id 初始值为 0，mysql 数据库 id 初始值为 1，mysql3 数据库 id 初始值为 2。我们这时候需要设置步长为 3，

```
mysql1 每次自增结果为   0，3，6，9，12，15

mysql2 每次自动结果为   1，4，7，10，13，16

mysql3 每次自动结果为   2，5，8，11，14，17

........
```

- `缺点`

  如果后期增加数据库服务器集群数量的话，mysql 步长无法扩展，所以使用这种方法生成全局 id，需要前期确定好 mysql 数据库集群的数量，不然那到后期扩展集群数量会导致生成步长规则发生改变，可能会产生重复的 id。

- 在数据库集群环境下，默认自增方式存在问题，因为都是从 1 开始自增，可能会存在重复，应该设置每台节点自增步长不同。

查询自增的步长 `SHOW VARIABLES LIKE 'auto_increment%'`

修改自增的步长 `SET @@auto_increment_increment=10`

修改起始值 `SET @@auto_increment_offset=5;`

### 3. 基于 redis 生成全局 id

> 因为 Redis 是单线的，天生保证原子性，可以使用 Redis 的原子操作 `INCR` 和 `INCRBY` 来实现

- `优点`

  不依赖于数据库，灵活方便，且性能优于数据库。 数字 ID 天然排序，对分页或者需要排序的结果很有帮助。

- `缺点`

  如果系统中没有 Redis，还需要引入新的组件，增加系统复杂度。 需要编码和配置的工作量比较大。

注意: 在 Redis 集群情况下，同样和 Redis 一样需要设置不同的增长步长，同时 key 一定要设置有效期 可以使用 Redis 集群来获取更高的吞吐量。

假如一个集群中有 5 台 Redis。可以初始化每台 Redis 的值分别是 1,2,3,4,5，然后步长都是 5。

各个 Redis 生成的 ID 为：

A：1,6,11,16,21

B：2,7,12,17,22

C：3,8,13,18,23

D：4,9,14,19,24

E：5,10,15,20,25

比较适合使用 Redis 来生成每天从 0 开始的流水号。

比如订单号 = 日期 + 当日自增长号。可以每天在 Redis 中生成一个 Key，使用 `INCR` 进行累加。 如果生成的订单号超过自增增长的话，可以采用前缀 + 自增 + 并且设置有效期。

使用 redis 实现全局 id 生成，使用自动填充的方法实现。

### 4. 基于 Twitter 的雪花算法（snowflake）生成全局 ID

```c++
/**
 * Twitter_Snowflake<br>
 * SnowFlake的结构如下(每部分用-分开):<br>
 * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 -
 * 000000000000 <br>
 * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0<br>
 * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)
 * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。
 * 41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69<br>
 * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId<br>
 * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号<br>
 * 加起来刚好64位，为一个Long型。<br>
 * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，
 * SnowFlake每秒能够产生26万ID左右。
 */
```
