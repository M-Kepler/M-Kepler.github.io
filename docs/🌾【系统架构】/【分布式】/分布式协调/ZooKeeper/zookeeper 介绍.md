- [1.zookeeper 概述](#1zookeeper-概述)
- [2. 什么是 zookeeper](#2-什么是-zookeeper)
- [3. 为什么使用 zookeeper](#3-为什么使用-zookeeper)
- [4. zookeeper 的特性](#4-zookeeper-的特性)
- [5. 事务 Transaction 的 ACID 特性](#5-事务-transaction-的-acid-特性)
- [6. zookeeper 的应用场景主要是](#6-zookeeper-的应用场景主要是)
- [7. zookeeper 的角色与系统模型](#7-zookeeper-的角色与系统模型)
- [8. leader 角色与 leader 选举机制](#8-leader-角色与-leader-选举机制)
- [9. 二阶提交和三阶提交](#9-二阶提交和三阶提交)
- [10. 2PC-3PC 主要区别](#10-2pc-3pc-主要区别)
- [11. zookeeper 的主要协议](#11-zookeeper-的主要协议)
- [12. Paxos 协议概述](#12-paxos-协议概述)
- [13. zookeeper 系统模型](#13-zookeeper-系统模型)
- [14. 会话（Session）](#14-会话session)
- [15. 数据节点（Znode）](#15-数据节点znode)
- [16. zookeeper 的顺序号](#16-zookeeper-的顺序号)
- [17. zookeeper 的保证](#17-zookeeper-的保证)
- [18. zookeeper 工作原理](#18-zookeeper-工作原理)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/zhengna/articles/9321684.html)

### 1.zookeeper 概述

zookeeper 又叫做分布式过程协同服务技术，它是为用户的分布式应用程序提供协调服务的。

zookeeper 本身就是一个分布式程序，而且可以组建专门由 zookeeper 组成的集群。但是有一个条件就是他要满足半数以上节点必须是存活的 (因为这样它才能发起一种机制叫做投票机制)。

zookeeper 所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务等。

虽然说可以提供各种服务，但是 zookeeper 在底层只提供了 2 个功能：

a. 管理（存储、读取）用户程序提交的数据；

b. 并为用户程序提供数据节点监听服务。

通俗的来说，zookeeper 顾名思义就是动物园管理员，它是拿来管理大象（Hadoop）、蜜蜂（Hive）、小猪（Pig）的管理员。

Apache Hbase 和 Apache Solr 以及 LinkedIn sensei 等项目（还有 kafka、spark 等）中都采用到了 zookeeper。

zookeeper 是一个分布式的、开放源码的分布式应用程序协调服务，zookeeper 是以 Fast Paxos 协议为基础，实现同步服务，配置维护和命名服务等分布式应用。

zookeeper 意欲设计一个易于编程的环境，它的文件系统使用我们所熟悉的目录树结构（zookeeper 不依赖于 hdfs，也就是说它在本地文件系统上就能搞定，它有单独属于自己的一套所谓文件系统目录树，不过这个需要我们进入客户端才能看到）。

zookeeper 使用 Java 所编写，但是支持 Java 和 c 两种编程语言。

众所周知，协调服务非常容易出错，但是却很难恢复正常（为什么？因为协调服务需要管理所有人的动作，一旦出现了所谓的协调不一致，或者说步调不一致，整个协调服务就面临失败的风险，整个集群可能就会崩溃）。例如，协调服务很容易处于竞态以至于出现死锁（什么叫做竞态？比如说发生了资源争抢，此时共享式资源为了保护自身就会加锁，那么就会出现死锁）。设计 zookeeper 的目的是为了减轻分布式应用程序所承担的协调任务。

在分布式系统中，每一个机器节点虽然都能明确的知道自己在进行事物操作过程中的结果是成功还是失败，但是无法直接获取到其他分布式节点的操作结果（结果需要通过网络进行结果传输）。因此，当一个事物操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability））特性，就需要引入一个称之为 “协调者（Coordinator）” 的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为“参与者（Participant）”。协调者负责调度参与者的行为，并最终决定了这些参与者是否要把事务真正提交。基于这个思想，衍生出了**二阶段提交**和**三阶段提交**两种协议一致性算法。

### 2. 什么是 zookeeper

zookeeper 是 Google 的 Chubby 一个开源的实现，是 Hadoop 的分布式协调服务。它包含一个简单的原语集，分布式应用程序可以基于它实现同步服务，配置维护和命名服务等。

### 3. 为什么使用 zookeeper

大部分分布式应用需要一个主控、协调器或控制器来管理物理分布的子进程（如资源、任务分配等）；

目前，大部分应用需要开发私有的协调程序，缺乏一个通用的机制；协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器；zookeeper 提供通用的分布式锁服务，用以协调分布式应用。

### 4. zookeeper 的特性

- zookeeper 是简单的

- zookeeper 是富有表现力的

- zookeeper 具有高可用性

- zookeeper 采用松耦合交互方式

- zookeeper 是一个资源库

### 5. 事务 Transaction 的 ACID 特性

- 原子性（Atomicity）

  事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。

- 一致性（Consistency）

  事务在完成时，必须使所有的数据都保持一致状态。
  例如，当开发用于转账的应用程序时，应避免在转账过程中任意移动小数点。

- 隔离性（Isolation）

  由并发事务所作的修改必须与任何其他并发事务所作的修改隔离。

- 持久性（Durability）

  事务完成后，它对于系统的影响是永久的。

### 6. zookeeper 的应用场景主要是

**服务器状态的动态感知**

主从模式：（master 选举机制）HBASE 主从集群 HADOOP 2.x HA 机制

Hadoop2.0，使用 zookeeper 的事务处理确保整个集群只有一个活跃的 NameNode，存储配置信息等。

HBase，使用 zookeeper 的事务处理确保整个集群只有一个 HMaster，察觉 HRegionServer 联机和宕机，存储访问控制列表等。
zookeeper 集群自身群首保证：（leader 选举机制）zookeeper 集群自身，但是要满足半数以上存活

**统一配置管理统一名称服务**

分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住。通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。

NameService 是 zookeeper 内置的功能，只要调用 zookeeper 的 API 就能实现。

**分布式共享锁管理**

### 7. zookeeper 的角色与系统模型

Leader 群首；Follower 追随者；Observer 观察者

如果是单机使用的话，只有一种角色就是 standalone

角色检查命令速记： `$ZOOKEEPER_HOME/bin/zkServer.sh status`

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717110522072-978555454.png)

### 8. leader 角色与 leader 选举机制

leader 作为整个 zookeeper 集群的主节点，负责响应所有对 zookeeper 状态变更的请求。它会将每个状态更新请求进行排序和编号，以便保证整个集群内部消息处理的 FIFO（First In First Out）。

一个 zookeeper 集群里只有一个 leader，当这个 leader 死了之后，剩下的 follower 需要再选举一个 leader。此时剩余的节点必须超过半数以上。集群容灾公式 = 集群个数 / 2-1（这里可以看到他的值是奇数）；集群容灾允许集群损坏一半的机器（生成系统中）（但是这只是一个阈值，最好不要在实际中发生损坏一半这种事）

**leader 选举**

每个 server 启动以后都询问其他的 server 它要投票给谁。
对于其他 server 的询问，server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系统启动时每个 server 都会推荐自己）。
收到所有 server 回复后，就计算出 zxid 最大的那个 server，并将这个 server 相关信息设置成下一次要投票的 server。
计算这过程中获得票数最多的 server 为获胜者，如果获胜者的票数超过半数，则该 server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来。

leader 就会开始等待 server 连接
follower 连接 leader，将最大的 zxid 发送给 leader
leader 根据 follower 的 zxid 确定同步点
完成同步后通知 follower 已经成为 uptodate 状态
follower 收到 uptodate 消息后，又可以重新接受 client 的请求服务了

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717132817427-42012222.png)

### 9. 二阶提交和三阶提交

> 二阶段提交协议简称 2PC，即 Two-Phase Commit 的缩写。顾名思义，二阶段协议一共分为 2 个阶段。

**阶段一：提交事务请求**

协调者向所有参与者询问，是否可以执行事务操作？如果所有参与者的回答都是可以，那么就进入下一个阶段，真正执行事务提交。

注意：如果这个阶段有参与者没有回答，则将一直等待其回答或者依赖协调者自身的超时机制进行事务中断。

**阶段二：执行事务提交**

将事务提交执行，各个参与者负责自己的部分，最终都将自己的执行结果反馈给协调者。

注意：如果所有参与者都正确回答，在协调者向所有参与者分配其要提交的任务时网络出现问题，将会造成只有一部分接收到协调者信息的参与者执行自身所负责的那部分事务。这样就会导致整个分布式系统出现数据不一致的情况，俗称脑裂。

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717100025652-613287531.png)

> 三阶段提交（Three-Phase commit），也叫三阶段提交协议（Three-Phase commit protocol），是二阶段提交（2PC）的改进版本。

**阶段一：询问是否可以执行事务**

这个阶段协调者向所有的参与者询问是否可参加执行事务。参与者接收到来自协调者的请求后如果自身可以执行，就进入准备阶段。

**阶段二：准备提交事务**

如果阶段一中的所有参与者回答的结果都是正常的，就执行事务的预提交。

注意：如果有任何一个参与者向协调者反馈的是非正常的，或者在等待超时之后协调者无法接收到所有参与者的反馈响应，那么就会中断事务。

**阶段三：执行事务**

真正进行事务提交。

注意：如果此时协调者出现问题或者协调者和参与者之间的网络出现问题，参与者都会在等待超时之后，继续进行事务提交，这种情况必然会导致分布式数据的不一致性。

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717101058996-517443642.png)

二阶提交举例：

你喜欢一个女孩，有一天你鼓起勇气去问这个女孩？
第一阶段：我可以追你吗？
女孩同意了！（当然，只收乐观的去想）
第二阶段：女孩追到手进入到恋爱阶段。

三阶段提交举例：
可以参考 TCP 协议的三次握手

与二阶段提交不同的是，三阶段提交有 2 个改动点：
(1) 引入超时机制。同时在协调者和参与者中都引入超时机制。
(2) 在第一阶段和第二阶段中插入了一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。

### 10. 2PC-3PC 主要区别

相对于 2PC，3PC 主要解决的是单点故障问题，并减少阻塞.。因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题。因为由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作，这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。

了解了 2PC 和 3PC 之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby 的作者 Mike Burrows 说过，there is only one consensus protocol,and that's Paxos-all other approaches are just broken versions of Paxos. 意即世上只有一种一致性算法，那就是 Paxos，所有其他一致性算法都是 Paxos 算法的不完整版。

### 11. zookeeper 的主要协议

二阶段提交、三阶段提交协议和 Paxos 协议都是分布式应用程序的通用协议，即在大部分的分布式应用程序中都可以使用。ZAB（zookeeper Atomic Broadcast，zookeeper 原子消息广播协议）协议是 zookeeper 设计之初专门为雅虎内部那些高吞吐量、低延迟、健壮、简单的分布式场景设计的。所以 ZAB 不是一种通用型算法，而是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。ZAB 算法可以看成是 Paxos 协议的一种具体实现。
zookeeper 中将自己的角色设置主要为 Leader、Follower、OBserver。Leader 和 Follower 都是 zk 的 server，只不过由 Leader（只有一个，类似于 Hadoop 中的 NameNode）对外提供服务，众多 Follower（类似于 Secondary NameNode，不过 Follower 会有多个）随时等 Leader 出现问题时选举出一个新 Leader 来继续对外提供以保证 zk 服务的高可用。

### 12. Paxos 协议概述

举一个简单的例子来说明整个选举的过程：
假设有五台服务器组成的 zookeeper 集群，它们的 id 从 1-5。同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么？
(1) 服务器 1 启动，此时只有它一台服务器启动了，它发出去的包没有任何响应，所以它的选举状态一直是 LOOKING 状态。
(2) 服务器 2 启动，它与最开始启动的服务器 1 进行通信，互相交换自己的选举结果，由于两者都没有历史记录，所以 id 值较大的服务器 2 胜出，但是由于没有达到超过半数以上的服务器都同意选举它（这个例子中的半数以上是 3），所以服务器 1,2 还是继续保持 LOOKING 状态。
(3) 服务器 3 启动，根据前面的理论分析，服务器 3 成为服务器 1,2,3 中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的 leader。
(4) 服务器 4 启动，根据前面的分析，理论上服务器 4 应该成为服务器 1,2,3,4 中最大的，但是由于前面已经有半数以上的服务器选举了服务器 3，所以它只能接受当小弟的命了。
(5) 服务器 5 启动，同 4 一样，当小弟。

### 13. zookeeper 系统模型

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717124511855-2132474478.png)

### 14. 会话（Session）

Session 是指客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。zookeeper 对外的服务端口默认是 2181，客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期就开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 watch 事件通知，Session 的 sessionTimeOut 值用来设置一个客户端会话的超时间。

当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致的客户端连接断开时，只要在 sessionTimeOut 规定的时内能重新连接上集群中的任意一台服务器，那么之前创建的会话仍然有效。

### 15. 数据节点（Znode）

在分布式中我们通常说的 “节点” 是指组成集群的每一台机器。然而，在 zookeeper 中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点。第二类则是指数据模型中的数据单元，我们称之为数据节点 Znode。

zookeeper 将所有数据存储在内存中，数据模型是一棵树（ZNode Tree），由斜杠（/）进行分割的路径，就是一个 Znode，例如 /foo/path1。每个 ZNode 都会保存自己的数据内容，同时还会保存一系列属性信息。

Znode 有 4 种形式的目录节点，持久节点 `PERSISTENT`、持久且有序节点 `PERSISTENT_SEQUENTIAL`、临时节点 `EPHEMERAL`、临时且有序节点 `EPHEMERAL_SEQUENTIAL`

在 zookeeper 中，ZNode 可以分为持久（persistent）节点和临时（ephemeral）节点两类。

- 所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则 ZNode 将一直保存在 zookeeper 上。

- 而临时节点就不一样了，他的生命周期和客户会话绑定，一旦客户端会话失败，那么这个客户端创建的所有临时节点都会被删除。

- 临时节点不可以有子节点。另外，zookeeper 还允许用户为每一个节点添加一个特殊的属性 `SEQUENTIAL`。一旦节点被标记上这个属性，那么在这个节点被创建的时候，zookeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是由父节点维护的自增数字。

==zookeeper 在各种分布式场景下发挥作用的主要方式就是数据节点和监控器==，我们可以给数据节点赋予任意我们想赋予的含义，来协助我们更好的处理分布式程序中所面临的问题。具体案例详见后文中的 zookeeper 的其他典型应用场景。

![alt](https://images2018.cnblogs.com/blog/1375459/201807/1375459-20180717113725300-648411546.png)

### 16. zookeeper 的顺序号

创建 Znode 时设置顺序标识，Znode 名称后会附加一个值；顺序号是一个单调递增的计数器，由父节点维护；在分布式系统中，顺序号可以被用于为所有的事件进行劝解排序，这样客户端可以通过顺序号 `推断事件的顺序`

### 17. zookeeper 的保证

更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行

数据更新原子性，一次数据更新要么成功，要么失败；

全局唯一数据视图，client 无论连接到哪个 server，数据视图都是一致的

实时性，在一定时间范围内，client 能读到最新数据

### 18. zookeeper 工作原理

zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 ZAB 协议。ZAB 协议有两种模式，它们分别是恢复模式和广播模式。

当服务启动或者 leader 崩溃后，ZAB 就进入了恢复模式，当 leader 被选举出来，且大多数 server 完成了和 leader 的状态同步后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。

广播模式需要保证 proposal（提议） 被按顺序处理，因此 zk 采用了递增的事务 id 号（zxid）来保证。所有的提议（proposal）都在被提出的时候加上了 zxid。实现中 zxid 是一个 64 位的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。

当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。

一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。zookeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。
