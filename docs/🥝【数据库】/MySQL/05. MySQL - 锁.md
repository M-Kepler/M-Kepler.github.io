- [MySQL - 锁](#mysql---锁)
  - [按锁的模式划分](#按锁的模式划分)
    - [间隙锁 `GapLock （GK）`](#间隙锁-gaplock-gk)
      - [产生间隙锁的条件](#产生间隙锁的条件)
      - [测试一下](#测试一下)
    - [记录锁（行锁） `record lock(RK)`](#记录锁行锁-record-lockrk)
      - [测试一下](#测试一下-1)
    - [临键锁 `next-key lock`](#临键锁-next-key-lock)
    - [意向锁](#意向锁)
      - [为什么意向锁是表级锁](#为什么意向锁是表级锁)
      - [意向锁怎么支持表锁和行锁](#意向锁怎么支持表锁和行锁)
  - [按锁的兼容性划分](#按锁的兼容性划分)
    - [共享锁](#共享锁)
    - [排他锁](#排他锁)
  - [按颗粒度划分](#按颗粒度划分)
    - [行级锁](#行级锁)
    - [表级锁](#表级锁)
  - [按加锁机制划分](#按加锁机制划分)
    - [悲观锁](#悲观锁)
    - [乐观锁](#乐观锁)
  - [死锁](#死锁)
    - [怎么判断数据库死锁](#怎么判断数据库死锁)
    - [死锁怎么定位排查](#死锁怎么定位排查)
    - [什么是死锁, 怎么解决](#什么是死锁-怎么解决)

# MySQL - 锁

- [Mysql 锁详解（行锁、表锁、意向锁、Gap 锁、插入意向锁）](https://blog.csdn.net/u010841296/article/details/84204701)

- [MySQL 行级锁、表级锁的区别](https://blog.csdn.net/hxpjava1/article/details/79407961)

- [MySQL 的锁机制 - 记录锁(record lock)、间隙锁(gap lock)、临键锁(next-key lock)](https://zhuanlan.zhihu.com/p/48269420)

![alt](https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzHb5ZvMdLOvjicVicD6zLAPaB9oUmB4sl8UInZmTY5o7EztQicicPHZNHtCmZCZR0tYsqxwT5szBbhIOw/640?wx_fmt=png)

> - 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。
> - 锁是数据库`为了保证数据的一致性`，而使各种共享资源在被并发访问变得有序所设计的一种规则
> - MySQL 数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。MySQL 各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。

## 按锁的模式划分

### 间隙锁 `GapLock （GK）`

锁定一个范围，但不包括记录本身。GAP 锁的目的是为了`防止出现幻读`

![alt](https://img-blog.csdnimg.cn/20200316170837134.png)

- 间隙锁是 `锁索引记录中的间隔`，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围

- 间隙锁是 MySQL 自动加的，不需要开发人员干预；可以尝试通过间隙锁来解决 `幻读问题`

#### 产生间隙锁的条件

`RR 事务隔离级别下` 才有间隙锁

- 使用普通索引锁定

- 使用多列唯一索引

- 使用唯一索引锁定多行记录

**`结论`**

- `唯一索引的间隙锁`

  - 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：`WHERE id = 5 FOR UPDATE;`

  - 对于查找某一范围内的查询语句，会产生间隙锁，如：`WHERE id BETWEEN 5 AND 7 FOR UPDATE;`

- `普通索引的间隙锁`

  - 在普通索引列上，不管是何种查询，`只要加锁，都会产生间隙锁`，这跟唯一索引不一样；

  - 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。

#### 测试一下

- `看下是否打开了间隙锁`

  ```sql
  show variables like 'innodb_locks_unsafe_for_binlog';
  ```

- `创建测试数据`

  ```sql
  -- 创建一张测试表
  CREATE TABLE user (
      id int(1) NOT NULL AUTO_INCREMENT,
      name varchar(8) DEFAULT NULL,
      PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

  -- 插入一些测试数据
  INSERT INTO test.user VALUES ('1', '小罗');
  INSERT INTO test.user VALUES ('5', '小黄');
  INSERT INTO test.user VALUES ('7', '小明');
  INSERT INTO test.user VALUES ('11', '小红');

  -- 表中隐藏的间隙：
  (-∞, 1]
  (1, 5]
  (5, 7]
  (7, 11]
  (11, +∞]
  ```

- `只使用记录锁，不会产生间隙锁`

  ```sql
  -- 事务 1
  begin;
  -- 主键是唯一索引，所以只锁定了一条记录
  select * from test.user where id = 5 for update;
  -- 延时 30 秒，防止锁释放
  select sleep(30);

  -- 事务 2
  begin;
  -- 可以正常执行
  insert into test.user (id, name) values (4, '小张');
  commit;
  ```

- `锁定范围，产生间隙锁`

  | 事务 1                                                                                                     | 事务 2                                                                 | 事务 3                                                            |
  | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ----------------------------------------------------------------- |
  | `begin;`                                                                                                   |                                                                        |                                                                   |
  | `select * from test.user where id between 5 and 7 for update;` </br> 查询 id 在 5 - 7 范围的数据并加记录锁 |                                                                        |                                                                   |
  | `select sleep(30);` </br> 延时 30s 执行，防止锁释放                                                        |                                                                        |                                                                   |
  |                                                                                                            | `begin;`                                                               |                                                                   |
  |                                                                                                            | `insert into test.user (id, name) values (3, '小张');` </br> 正常执行` |                                                                   |
  |                                                                                                            | `commit;`                                                              |                                                                   |
  |                                                                                                            |                                                                        | `begin;`                                                          |
  |                                                                                                            |                                                                        | `insert into test.user (id, name) values (6, '小东');` </br> 阻塞 |
  | `commit; -- 提交事务`                                                                                      |                                                                        |                                                                   |
  |                                                                                                            |                                                                        | 阻塞结束                                                          |
  |                                                                                                            |                                                                        | `commit;`                                                         |

  可以看到 `(5, 7]、(7, 11]` 这两个区间都不可插入数据，其他区间则可以

- `查询一条不存在的数据，会产生间隙锁`

  | 事务 1                                                                        | 事务 2                                                            |
  | ----------------------------------------------------------------------------- | ----------------------------------------------------------------- |
  | `begin;`                                                                      |                                                                   |
  | `select * from test.user where id = 3 for update;` </br> 锁定一条不存在的记录 |                                                                   |
  | `select sleep(30);`                                                           |                                                                   |
  |                                                                               | `begin;`                                                          |
  |                                                                               | `insert into test.user (id, name) values (2, '小白');` </br> 阻塞 |
  | `commit;`                                                                     |                                                                   |
  |                                                                               | 阻塞结束                                                          |
  |                                                                               | `commit;`                                                         |

### 记录锁（行锁） `record lock(RK)`

锁直接加在索引记录上面，锁住的是 key

> - `InnoDB` 行锁分两种类型：共享锁(S LOCK)、排他锁(X LOCK)
> - `InnoDB` 是基于 **`索引（包括主键索引）`** 来完成行锁，`只有通过索引条件检索数据，才能使用行锁`，否则使用表锁

记录（一行，一条记录的意思）锁是锁定记录（行数据），也叫做行锁

- 行锁并不是直接锁记录，而是锁[索引]

  - 用到了主键索引，MySQL 会锁住主键索引

  - 操作了非主键索引，MySQL 会先锁住非主键索引，再锁定主键索引

#### 测试一下

```sql
-- 获取排他锁（X锁）
-- for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列
-- 如果查询的列 id 不是索引，那么InnoDB将完成表锁
select * from tb_with_index where id = 1 for update;

-- 获取共享锁（S锁）
select * from tb_with_index where id = 1 lock in share mode;
```

- 演示一下行锁不查询索引，导致锁表的情况，表 A 在 `device_id` 上没有索引

  | 事务 1                                                                                                  | 事务 2                                                                                             |
  | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
  | `begin;`                                                                                                | `begin;`                                                                                           |
  |                                                                                                         | `select * from test_tb where device_id in (1, 2) for update;`</br> `-- 行锁没有命中索引，造成锁表` |
  | `update test_tb set report_status = 0 where device_id = 10;`</br> `-- 更新记录为 device_id = 10 被阻塞` |                                                                                                    |
  |                                                                                                         | `commit;`                                                                                          |
  | `-- 阻塞解除，sql 执行完成`                                                                             |                                                                                                    |
  | `commit;`                                                                                               |                                                                                                    |

### 临键锁 `next-key lock`

- 记录锁和间隙锁组合称为 `next-key lock`，是一个 `左开右闭` 区间

### 意向锁

[意向锁](https://www.zhihu.com/question/51513268)

> 意向锁的存在是为了`【协调行锁和表锁的关系】`，支持多粒度（表锁与行锁）的锁并存

- 申请意向锁的动作是数据库完成的；事务 A 申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请

- 事务在请求 `共享（S）锁 / 排他（X）锁` 前，要先获得 `意向共享（IS）锁 / 意向排他（IX）锁`

- 意向锁表明 `某个事务正在某些行持有了锁、或该事务准备去持有锁`

  例子：事务 A 修改 user 表的记录 r，会给记录 r 上一把行级的排他锁（X），同时会给 user 表上一把意向排他锁（IX），这时事务 B 要给 user 表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。

#### 为什么意向锁是表级锁

当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）

- 如果意向锁是行锁，则需要遍历每一行数据去确认；

- 如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能

#### 意向锁怎么支持表锁和行锁

- 首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务 A 持有行锁、又有一个事务 B 持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。

- 如果事务 A 对某一行上锁，其他事务就不可能修改这一行。这与 “事务 B 锁住整个表就能修改表中的任意一行” 形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如 q1 的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。

## 按锁的兼容性划分

[MySQL 共享锁，排他锁](https://learnku.com/articles/12800/lock-in-share-mode-MySQL-shared-lock-exclusive-lock-for-update)

共享锁（读锁）、排他锁（写锁）、意向锁

### 共享锁

- 读锁是共享的，SQL 中可以通过 `lock in share mode` 来获取，此时只能读，不能写

### 排他锁

- 写锁是排他的，SQL 中可以通过 `for update` 来获取

## 按颗粒度划分

### 行级锁

- 锁定操作的那条记录，容易发生死锁

- 锁定对象的颗粒度很小，所以发生资源争抢的概率小，并发处理能力更高

- 但是每次获取锁、释放锁带来的消耗也更大

### 表级锁

- 操作时锁定整个表，很好避免了死锁的问题

- 表级锁实现逻辑简单、带来的系统负面影响最小，所以获取/释放锁的速度很快

- 但是因为锁定的是整个表，并发度大打折扣

- 使用表级锁的主要是 `MyISAM` 等一些`非事务性`存储引擎中

## 按加锁机制划分

并发控制的任务是 `确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性`。

乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段

**两种锁的使用场景**

多写用 `悲观`；多读用 `乐观`

- 乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

- 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适

### 悲观锁

- 假定会发生并发冲突，`屏蔽一切可能违反数据完整性的操作`。在查询完数据的时候就把事务锁起来，直到提交事务

- 使用数据库中的锁机制实现 `select ... for update;`

### 乐观锁

- 假设不会发生并发冲突，`只在提交操作时检查是否违反数据完整性`，在修改数据的时候把事务锁起来，通过版本号的方式来进行锁定

- 一般会使用`版本号机制或 CAS 算法`实现

## 死锁

### 怎么判断数据库死锁

[数据库死锁的检查和解决方法](https://www.cnblogs.com/huanyou/p/5775965.html)

[MySQL 死锁问题如何分析&锁表后查看死锁和去除死锁快速解决方法](https://zyc88.blog.csdn.net/article/details/110121016)

[并发插入引发的死锁问题排查](https://blog.csdn.net/qq_16681169/article/details/73359670)

[查询是否锁表：](https://www.cnblogs.com/jpfss/p/11491526.html)

```sql
SHOW OPEN TABLES WHERE In_use > 0;

SHOW PROCESSLIST;

-- 在 5.5 中，information_schema 库中增加了三个关于锁的表（innoDB 引擎）
-- innodb_trx         # 当前运行的所有事务
-- innodb_locks       # 当前出现的锁
-- innodb_lock_waits  # 锁等待的对应关系

-- 查看 MySQL 当前正在执行的事务情况
SELECT * FROM information_schema.innodb_trx;
```

### 死锁怎么定位排查

```sql
-- 查看最近的一条死锁日志
SHOW ENGINE INNODB STATUS;

-- 输出结果如下

------------------------
LATEST DETECTED DEADLOCK
------------------------

--------------------
-- 事务1
--------------------
*** (1) TRANSACTION:
-- 事务编号为 3925 ，活跃48秒，starting index read 表示事务状态为根据索引读取数据
TRANSACTION 3925, ACTIVE 48 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 360, 2 row lock(s)
mysql thread id 8, OS thread handle 0x7fc7ab8c7700, query id 242 0699cfbc3c12 172.25.0.2 root statistics
SELECT * FROM `kv` WHERE  `key` = 'a' FOR UPDATE

-- 事务1等待获取锁
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 12 page no 3 n bits 72 index `PRIMARY` of table `mytest`.`kv` trx id 3925 lock_mode X locks rec but not gap waiting

-- 事务1走的是主键索引PRIMARY，等待的锁类型是排他锁 lock_mode X，locks rec but not gap 说明是记录锁
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0

--------------------
-- 事务2
--------------------
*** (2) TRANSACTION:
TRANSACTION 3924, ACTIVE 61 sec inserting
MySQL tables in use 1, locked 1
4 lock struct(s), heap size 1184, 3 row lock(s)
MySQL thread id 7, OS thread handle 0x7fc7ab909700, query id 246 0699cfbc3c12 172.25.0.2 root update
INSERT INTO `kv` SET `key`='b',`val` = '2'

-- 事务2持有的锁
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 12 page no 3 n bits 72 index `PRIMARY` of table `mytest`.`kv` trx id 3924 lock_mode X locks rec but not gap waiting

-- 事务2持有的锁类型是排他锁 lock_mode X，同样是记录锁
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0

-- 事务2正在等待被授予插入意向锁
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 12 page no 3 n bits 72 index `PRIMARY` of table `mytest`.`kv` trx id 3924 lock_mode X insert intention waiting

Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0

-- 回滚了权重较低的事务1
*** WE ROLL BACK TRANSACTION (1)
```

### 什么是死锁, 怎么解决

[怎么解决 MySQL 死锁问题](https://mp.weixin.qq.com/s/pgixOBmI5WbHfqkilGpl8g)

> - 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
> - 防止死锁的途径就是避免满足死锁条件的情况发生

**死锁发生的条件**

- `资源不能共享`，需要只能由一个进程或者线程使用

- `请求且保持`，已经锁定的资源自给保持着不释放

- `不剥夺`，自给申请到的资源不能被别人剥夺

- `循环等待`

**预防死锁**

- 如果不同程序会并发存取多个表，`尽量约定以相同的顺序访问表`，可以大大降低死锁机会。

- 在同一个事务中，尽可能做到`一次锁定所需要的所有资源`，减少死锁产生概率

- 对于非常容易产生死锁的业务，可以`尝试升级锁定颗粒度`，比如通过表级锁来减少死锁产生的概率

- `保持事务简短`并在一个批处理中

  - 在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁

  - 事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁

  - 保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁
