- [MySQL - 事务](#mysql---事务)
  - [事务的特性 `ACID` 是指什么](#事务的特性-acid-是指什么)
  - [如何保证事务的隔离性](#如何保证事务的隔离性)
  - [事务并发带来的问题](#事务并发带来的问题)
    - [什么是脏读](#什么是脏读)
    - [什么是幻读](#什么是幻读)
    - [什么是不可重复读](#什么是不可重复读)
    - [不可重复读与幻读的区别是什么](#不可重复读与幻读的区别是什么)
  - [事务隔离级别有哪些](#事务隔离级别有哪些)
    - [读未提交 `read uncommited`](#读未提交-read-uncommited)
    - [读已提交 `read commited`](#读已提交-read-commited)
    - [可重复读 `repeatable read`](#可重复读-repeatable-read)
    - [串行化 `Serializable`](#串行化-serializable)
  - [★ 什么是 `MVCC`](#-什么是-mvcc)
    - [快照读和当前读](#快照读和当前读)
    - [MVCC 能否解决幻读](#mvcc-能否解决幻读)
    - [MySQL 如何实现 `读已提交`、`可重复读` 的](#mysql-如何实现-读已提交可重复读-的)
  - [`redolog` 和 `undolog` 是什么](#redolog-和-undolog-是什么)
    - [redolog](#redolog)
    - [undolog](#undolog)
  - [binlog 和 redolog 的区别](#binlog-和-redolog-的区别)
    - [为什么不用 binlog 数据恢复](#为什么不用-binlog-数据恢复)
    - [什么是两阶段提交](#什么是两阶段提交)
    - [为什么要分两阶段提交](#为什么要分两阶段提交)
- [参考资料](#参考资料)

# MySQL - 事务

## 事务的特性 `ACID` 是指什么

**原子性 Atomicity**

> 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节

- 事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体

**一致性 Consistency**

> 事务开始前和结束后，数据库的`完整性约束`没有被破坏

- 比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到

**隔离性 Isolation**

> 同一时间，只允许一个事务请求同一数据，`不同的事务之间彼此没有任何干扰`

- 比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。

**持久性 Durability**

- 事务完成后不能回滚，事务对数据库的所有更新将被保存到数据库

## 如何保证事务的隔离性

- 加锁（实现当前读）

- MVCC（实现快照读）

## 事务并发带来的问题

> 可以通过 `begin;` 或 `start transaction;` 开始一个事务

### 什么是脏读

在 `一个事务中` 可以随随便便读取到 `其他事务未提交的数据` ；读到的不是最终的数据，是`脏`的，会变化的

| 事务 1                                | 事务 2                                     |
| :------------------------------------ | :----------------------------------------- |
| `start transaction;`                  | `start transaction`                        |
|                                       | `update tset_tb set age = 10 where id = 1` |
| `select age from table where id = 1;` |                                            |
| `commit`                              |                                            |
|                                       | `commit`                                   |

### 什么是幻读

- 在一个事务中读取两次，得到的结果不一样；`就好像发生【幻觉】`一样，`周围`的东西都是假的（间隙锁就是锁住附近的数据，以解决幻读问题）

- `统计或批量查询` 的时候可以读到其他事务正在修改的数据，多次读取结果不一样

> `事务1` 中的两次查询得到的结果是不一样的

| 事务 1                                                                                           | 事务 2                                                                |
| :----------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------- |
| `start transaction`                                                                              | `start transaction`                                                   |
| `select age from table where id > 2`                                                             |                                                                       |
|                                                                                                  | `insert into table(id, age) value(5, 10)`                             |
|                                                                                                  | `commit`                                                              |
| `select age from table where id > 2`                                                             |                                                                       |
| `commit`                                                                                         |                                                                       |
| 事务 1                                                                                           | 事务 2                                                                |
| :----------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------- |
| `begin;`                                                                                         | `begin;`                                                              |
| `select age from table where id = 2; -- 不存在 id 为 2 的记录`                                   |                                                                       |
|                                                                                                  | `insert into table(id, age) value(2, 10); -- 插入一条 id 为 2 的记录` |
|                                                                                                  | `commit;`                                                             |
| `insert into table(id, age) value(2, 22); -- 报主键冲突`                                         |                                                                       |
| `select age from table where id = 2; -- 再查一下，确实不存在 id 为 2 的记录啊`                   |                                                                       |
| `commit;`                                                                                        |                                                                       |
| `select age from table where id = 2; -- 结束这个事务后，再查一下，发现 id 为 2 的居然已经存在了` |                                                                       |

### 什么是不可重复读

对于同一`行数据`，多次读取到的结果不一样

> 由于在读取中间变更了数据，所以 `事务1` 事务查询期间的得到的结果就不一样了。

| 事务 1                               | 事务 2                                   |
| :----------------------------------- | :--------------------------------------- |
| `start transaction`                  | `start transaction`                      |
| `select age from table where id = 1` |                                          |
|                                      | `update table set age = 10 where id = 1` |
|                                      | `commit`                                 |
| `select age from table where id = 1` |                                          |
| `commit`                             |                                          |

### 不可重复读与幻读的区别是什么

[不可重复读与幻读的区别是什么](https://www.cnblogs.com/itcomputer/articles/5133254.html)

> 从总的结果来看, 似乎两者都表现为两次读取的结果不一致. 但如果你`从控制的角度来看`, 两者的区别就比较大

- `对于不可重复读只需要锁住满足条件的记录`

  主要发生在 `update`、`delete`；避免不可重复读需要`锁行`就行

- `对于幻读要锁住满足条件及其相近的记录`

  主要发生在 `insert`；避免幻影读需要`锁表`

## 事务隔离级别有哪些

通过隔离事务，来解决或预防事务并发可能出现的脏读，幻读，不可重复读问题

> 隔离级别由低到高分别为：读未提交，读已提交，可重复读，串行化

| 隔离级别                                                           | 脏读   | 幻读   | 不可重复读 |
| :----------------------------------------------------------------- | :----- | :----- | :--------- |
| 读未提交（`Read uncommitted`）</br> 事务中可以读取未提交事务的数据 | 可能   | 可能   | 可能       |
| 读已提交（`Read committed`） </br> 事务中可以读取已提交事务的数据  | 不可能 | 可能   | 可能       |
| 可重复读（`Repeatable read`） </br> 事务中重复读取到的结果是一致的 | 不可能 | 可能   | 不可能     |
| 可串行化（`Serializable`） </br> 事务串行执行                      | 不可能 | 不可能 | 不可能     |

### 读未提交 `read uncommited`

> 事务中的修改，即使没有提交，`对其他事务也都是可见`的，事务可以读取未提交的数据

- 如果一个事务已经开始写数据，则另一个事务不允许同时进行写操作，但允许其他事务读此行数据

- 可以通过 `排他写锁` 来实现

- 可能造成 `脏读`，但不允许更新丢失

### 读已提交 `read commited`

> - 事务从开始直到提交之前，所做的任何修改`对其他事务都不可见`
> - 可能造成`不可重复读`，避免了`脏读`

- 一个事务可以读取另一个已提交事务的数据，`针对某一多次读取会造成不一样的结果`

- 有时候不太理解这里，读取的是别的事务已提交的数据为什么还会有问题？那是因为，当前这个事务还没结束的时候如果其他事务对同一条记录修改了多次，那么我这个事务里面就会发生`不可重复读`

- 所以 `RC` 没有 `RR` 那么好，感觉 `RR` 是借助 `MVCC` 给数据记录做了个快照（实际不是，如果是快照的话，就相当于是静态数据了，连幻读都解决了（快照读的时候可以解决串行化）），保存了当前的状态就不会受到其他事务影响了，实现可重复读

### 可重复读 `repeatable read`

> - MySQL InnoDB 引擎默认的隔离级别，实现技术是 `MVCC`
> - 同一个事务中，多次查询结果是一致的
> - 可以通过 `共享锁 + 排他写锁` 实现

- 事务读取数据时会禁止其他写事务进行（但是允许读事务）；但事务写数据时，禁止任何其他事务

- 不会出现`不可重复读`和`脏读`，保证对每一行的数据在整个事务中的内容是一样的，但是有时可能出现`幻读`，可以尝试通过间隙锁解决问题

- 但是如果实在做`统计`查询或者`批量`查询的时候，会导致出现幻读（查询行数不一致），`RR` 针对`【批量】`操作出现前后不一致

### 串行化 `Serializable`

- 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行

- 仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到

## ★ 什么是 `MVCC`

[20 张图带你彻底搞懂 MySQL MVCC 原理](https://mp.weixin.qq.com/s/l40astGsfghnzXSl0VeUKQ)

`MVCC Multi-Version Concurrency Control` 多版本并发控制

多个事务并行操作【某一行数据】时，不同事务对该行数据的修改会产生多个版本，**然后通过 `回滚指针（roll_pointer）`，连成一个链表，这个链表就称为【版本链】**（说到版本链，联想到 `alembic` 框架，也是把迁移脚本形成一条版本链）

![alt](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzkkRHibH0jLK3GSCicOrOdxBeia1anA1L8sJpk264dotFJXROnATaExLajtqzDeCrSJle6CH830rkAg/640?wx_fmt=png)

- 通过保存`数据在某个时间点的快照`来实现的；这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着`在同一个时刻不同事务看到的相同表里的数据可能是不同的`

- `InnoDB` 不会真的存储了多个版本的数据，`只是借助 【undolog 记录每次写操作的反向操作】`，所以索引上对应的记录只会有一个版本，即最新版本。只不过可以根据 `undolog` 中的记录反向操作得到数据的历史版本，所以看起来是多个版本

- 每行数据都存在一个版本，每次数据更新时都更新该版本

- 修改时 Copy 出当前版本随意修改，各个事务之间无干扰

- 保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃 copy（rollback）

### 快照读和当前读

- 在 RR 隔离级别下，**快照读**是通过 `MVVC 和 undolog` 来实现的

- **当前读** 是通过加 record lock(记录锁，即行锁）和 gap lock(间隙锁) 来实现的

**快照读**

读取的是记录数据的可见版本（有旧的版本）。`不加锁，普通的 select 语句都是快照读`

```sql
select * from core_user where id > 2;
```

**当前读**

读取的是记录数据的最新版本，`加锁的都是当前读`

```sql
-- 排他锁（写锁）
select * from core_user where id > 2 for update;

-- 共享锁（读锁）
select * from account where id > 2 lock in share mode;
```

### MVCC 能否解决幻读

[MVCC 能否解决幻读问题](https://blog.csdn.net/Edwin_Hu/article/details/124392174)

- `快照读`的幻读是用 MVCC 解决的，`当前读`的幻读是用间隙锁解决的

- INNODB 的默认事务隔离级别是 RR（可重复读），它的实现技术是 MVCC。

- 该技术不仅可以保证 INNODB 的可重复读，而`且可以防止幻读`。但是`它防止的是【快照读】的情况下`，也就是读取的数据虽然是一致的，但是数据是历史数据。

### MySQL 如何实现 `读已提交`、`可重复读` 的

[MySQL 是如何实现读已提交和可重复读的 - MVCC 原理](https://blog.csdn.net/h2503652646/article/details/117152307)

通过 `MVCC` 用来实现哪几个隔离级别；相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。

- 首先隔离级别如果是读未提交的话，直接读最新版本的数据就行了，压根就不需要保存以前的版本

- 可串行化隔离级别事务都串行执行了，所以也不需要多版本

- 因此 MVCC 是用来实现读已提交和可重复读的。

## `redolog` 和 `undolog` 是什么

TODO

### redolog

重做日志，提供前滚操作

- `redolog` 是可以在异常情况下（`buffer pool已修改，但磁盘未修改就崩溃了`），将`buffer pool`中的数据写入磁盘中

- 通常是`【物理日志】`保存在磁盘，`记录的是数据页的物理修改`，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。

- 以`块为单位`进行存储的，每个块占 512 字节，这称为 redolog block

### undolog

回滚日志，提供回滚操作，用来回滚行记录到某个版本

- 一般是 `【逻辑日志】`，根据 `每行记录` 进行记录，**主要用于 MVCC 的版本控制**

  可以这样认为，当 delete 一条记录时，undolog 中会记录一条对应的 insert 记录，当更新一条记录时，它记录一条对应相反的更新记录

- 采用`段的方式`存储。每个回滚段中有 1024 个 undo log segment

- 主要用于：事务回滚、MVCC

## binlog 和 redolog 的区别

// 2022 年 11 月 4 日

**适用对象不同**

- binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用

- redolog 是 InnoDB 引擎特有的

**写入内容不同**

- binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 "给 id = 1 这一行的 age 字段加 1"

- redolog 是物理日志，记录的是 “在某个数据页上做了什么修改”

**写入方式不同**

- binlog 是可以追加写入的。“追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

- redolog 是循环写的，空间固定会被用完

可以看到，redolog 和 binlog 的一个很大的区别就是，一个是循环写，一个是追加写。

==redolog 只会记录未刷入磁盘的日志，已经刷入磁盘的数据都会从 redolog 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。==

### 为什么不用 binlog 数据恢复

[mysql 为什么不能用 binlog 来做数据恢复](https://www.zhihu.com/answer/2318189289)

### 什么是两阶段提交

> 所谓两阶段提交，其实就是把 redolog 的写入拆分成了两个步骤：prepare 和 commit。

数据库提交事务的时候，innodb 引擎是下边几个步骤：

1、先写入 redolog，状态定为 `prepare` 状态
2、写入 binlog

3、写入 binlog 完成以后，再修改 redo log 状态为 commit 状态

4、最后再是事务的提交的 `commit` 命令

### 为什么要分两阶段提交

[什么是两阶段提交](https://blog.csdn.net/duan18888/article/details/124576059)

[⭐ 美团二面：如何解决 bin log 与 redo log 的一致性问题](https://zhuanlan.zhihu.com/p/447827223)

两阶段提交：`先写 redolog 后写 binlog`

![alt](https://img-blog.csdnimg.cn/img_convert/a240d2d6394a4398c7dd14c5a84bfd72.webp?x-oss-process=image/format,png)

- binlog 是 MySQL 自己提供的，在 MySQL 的 server 层；redolog 是存储引擎 InnoDB 自己提供的

  所以在 MySQL 中就存在两类日志 binlog 和 redolog，存在两类日志既有历史原因（InnoDB 最早不是 MySQL 官方存储引擎）也有技术原因，这个咱们以后再细聊。

- ==MySQL Server 层拥有的 binlog 只能用于归档，不足以实现崩溃恢复（crash-safe），需要借助 InnoDB 引擎的 redolog 才能拥有崩溃恢复的能力。==

「如果不使用 “两阶段提交”，那么`数据库的状态就有可能和用它的【日志恢复出来的库】的状态不一致`」

- 如果 `redolog` 写完，`binlog` 还没有写完

  此时 MySQL 进程异常重启，这时候 binlog 里面就没有记录这个语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 「binlog 丢失」，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。

- 如果先写 `binlog` 后写 `redolog`

  如果在 binlog 写完之后崩溃了，由于 `redolog` 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了 “把 c 从 0 改成 1” 这个日志。所以，在之后用 binlog 来恢复的时候就「多了一个事务出来」，恢复出来的这一行 c 的值就是 1，与原库的值不同。

# 参考资料

- [事务隔离级别和锁](https://developer.ibm.com/zh/technologies/databases/articles/os--transaction-isolation-levels-and-locks/)

- [MySQL InnoDB MVCC 机制的原理及实现](https://www.yuque.com/chenjiayang/blog/dozcqo)

- [关于 MySQL 的酸与 MVCC](https://mp.weixin.qq.com/s/401CeXbEK27pX9dFOOHDnA)

- [幻读的详解、实例及解决办法](https://blog.csdn.net/weixin_33912453/article/details/88754930)
