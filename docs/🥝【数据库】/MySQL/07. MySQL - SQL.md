- [参考资料](#参考资料)
- [`SQL`](#sql)
  - [★ `varchar` 和 `char` 的区别](#-varchar-和-char-的区别)
    - [存储和检索时的差异](#存储和检索时的差异)
    - [`varchar(1000)` 比 `varchar(100)` 是不是更好](#varchar1000-比-varchar100-是不是更好)
    - [能用 `varchar` 完全代替 `char` 么](#能用-varchar-完全代替-char-么)
    - [存储用户的密码散列应该使用什么字段进行存储](#存储用户的密码散列应该使用什么字段进行存储)
    - [`varchar(11)` 和 `int(11)` 中的 11 有什么区别](#varchar11-和-int11-中的-11-有什么区别)
    - [为什么 `varchar` 建议不要超过 255](#为什么-varchar-建议不要超过-255)
  - [`group by` 可以和 `where` 一起用吗，和 `having count` 有什么区别](#group-by-可以和-where-一起用吗和-having-count-有什么区别)
  - [★ `select count(1) 和 select count(*) 和 select count(字段)` 区别](#-select-count1-和-select-count-和-select-count字段-区别)
  - [连接查询](#连接查询)
    - [外连接](#外连接)
    - [内连接](#内连接)
  - [一条 SQL 语句在 MySQL 中如何执行的](#一条-sql-语句在-mysql-中如何执行的)
  - [为什么不建议使用外键](#为什么不建议使用外键)
  - [`DDL`、`DQL`、`DML`](#ddldqldml)
  - [`drop、delete、truncate` 的区别](#dropdeletetruncate-的区别)

# 参考资料

# `SQL`

## ★ `varchar` 和 `char` 的区别

[★ MYSQL 中 char 和 varchar](https://blog.csdn.net/weixin_35762553/article/details/113217871)

### 存储和检索时的差异

- `char 长度固定` 即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定。

- `varchar 可变长度` 可以设置最大长度；适合用在长度可变的属性。

**存储时**

```sql
-- 变长的，如果存入的字段是 "abc "，则实际上只占 4 个字节
varchar(100);

-- 定长的，如果存入的字段是 "abc "，则实际上占 100 个字节，末尾用空格补足
char(100);
```

**索引检索时**

- `VARCHAR` 在存储时不填充空格。`在存储和检索值时，尾部空格将被保留`

- `CHAR` 刚好相反；在存储时会填充空格，==【无论这个尾部空格是自动填充的还是数据本身的】在检索时都会去掉==

  检索效率来说，char 的效率要高于 varchar 的

  ```sql
  -- 创建一个 char 类型的字段，长度为 4
  alter table users add column test char(4);

  -- 存入末尾带空格的值
  update users set test = "ab ";

  -- 查出来看看
  select concat('[', test, ']') from users
  +------------------------+
  | concat('[', test, ']') |
  +------------------------+
  | [ab]                   |     --结果发现，我存进去的空格也没了...
  +------------------------+

  ```

### `varchar(1000)` 比 `varchar(100)` 是不是更好

- 虽然 varchar 是变长，在相同长度下，磁盘空间占用一样，将值设置更大一些，弹性空间也更大。但 `在【内存】加载的时候，每次都是按最大空间来分配的`。

- 在排序场景，或者一些临时表聚合场景，更大空间会产生明显的不利影响。

### 能用 `varchar` 完全代替 `char` 么

- varchar 是变长，相比 char 更灵活

- varchar 会额外 `用一个字节存储长度信息`

- char 的存储空间都是一次性分配的，存储是固定连续的，而 varchar 的存储的长度是可变的，当 varchar 更改前后数据长度不一致时，就不可避免的会出现 `【内存碎片】` 的问题

- 一般来说，长度固定的字段，还是用 char 比较合适，比如 Hash，就很适合用 char

### 存储用户的密码散列应该使用什么字段进行存储

- 密码散列，盐，用户身份证号等`固定长度的字符串`应该使用 `char` 而不是 `varchar` 来存储（`varchar` 检索慢一点），这样可以节省空间且提高检索效率

### `varchar(11)` 和 `int(11)` 中的 11 有什么区别

[int(1) 和 int(10) 有什么区别](https://mp.weixin.qq.com/s/Z9fg2-R7vaShjlDZqj-fXg)

- `varchar(11)` 中代表`能存` 11 个字符

- `int(11)` 中只是`代表显示长度`

  对大多数应用没有意义，只是规定一些工具用来显示字符的个数，比如 `int(1) 和 int(20)` 存储和计算其实是一样的

### 为什么 `varchar` 建议不要超过 255

- [varchar 能不能超过 255 个字节及产生的问题](https://blog.csdn.net/songkai558919/article/details/119856984)

> 占用空间、索引失效

- 当定义 varchar 长度 `<= 255` 时，`长度标识位需要一个字节 (utf-8 编码)`，一个字节 8 位，可以表示 2^8 = 256 长度

- 当 `> 255` 时，长度标识位需要两个字节，并且建立的`「索引也会失效」`

## `group by` 可以和 `where` 一起用吗，和 `having count` 有什么区别

> - 对于哪部分数据（`where`）进行聚合（`group by`），取聚合后的哪部分数据（`having`）
> - 查询优先级: `HAVING < 聚合语句 < WHERE`
> - `对分组数据 group by 再次判断时`要用 `HAVING`
> - `HAVING` 子句必须位于 `GROUP BY` 之后 `ORDER BY` 之前

```sql
select city, count(*) as num from staff where age > 19 group by city having num >= 3;
-- 1. 执行 where 先把年龄大于 19 岁的员工找出来
-- 2. 执行 group by 聚合语句对员工按照城市进行分组
-- 3. 执行 count 聚合函数计算每组员工的数量值
-- 4. 执行 having 选出员工数量大于等于 3 的城市组
```

- 聚合语句 `(sum, min, max, avg, count)` 要比 `HAVING` 子句优先执行

  ```sql
  -- 先执行聚合语句 count；再执行 having 语句
  -- 换句说话说把 having 换成 where 则会出错
  -- havint count 统计分组数据时用到聚合语句
  select test_col, count(*) from test_tb group by test_col having count(*) > 4;
  ```

- `WHERE` 子句在查询过程中执行优先级别优先于聚合语句

  ```sql
  -- 先执行 where 语句查询出 id 大于 10 的记录；再执行聚合语句 sum
  select sum(num) from test_tb where id > 10;
  ```

- 用 `having` 就一定要和 `group by` 连用， 用 `group by` 不一有 `having`，它只是一个筛选条件用的

  ```sql
  -- 聚合语句和 where 一起使用
  select sum(num) from order where id > 10;

  -- having 和 聚合语句一起使用
  select reportsto, count(*) from employees group by reportsto having count(*) > 4;
  ```

## ★ `select count(1) 和 select count(*) 和 select count(字段)` 区别

[`count(1)、count(*) 与 count(列名)`的执行区别](https://blog.csdn.net/iFuMI/article/details/77920767)

**总结**

```sql
-- 指定某一列，得到的是该列【非 null 】的数量
select count(age) from test_tb;

-- count(1) 和 count(*) 没啥差别
-- 统计的是行数，包括字段为 null 的记录
select count(1) from test_tb;

count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异。

```

**执行效果**

- `count(*)` 包括了所有的列，相当于行数，在统计结果的时候，`不会忽略列值为 NULL`

- `count(1)` 包括了忽略所有列，用 1 代表代码行，在统计结果的时候，`不会忽略列值为 NULL`

- `count(列名)` 只包括列名那一列，在统计结果的时候，==会忽略列值为空（这里的空不是指空字符串或者 0，而是表示 null）的计数==，即某个字段值为 NULL 时，不统计。

**执行效率**

![alt](https://img-blog.csdnimg.cn/img_convert/af711033aa3423330d3a4bc6baeb9532.png)

- 列名为主键，`count(列名)` 会比 `count(1)` 快

- 列名不为主键，`count(1)` 会比 `count(列名)` 快

- 如果表多个列并且没有主键，则 `count(1)` 的执行效率优于 `count(*)`

- ==如果有主键，则 `select count(主键)` 的执行效率是最优的==

- 如果表只有一个字段，则 `select count(*)` 最优

## 连接查询

[图解 SQL 里的各种 JOIN](https://blog.csdn.net/moakun/article/details/80429267)

![alt](https://img-blog.csdn.net/20180922120245376?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vYWt1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 外连接

- 外连接查询 `能返回左/右表里的所有记录，以及左/右表里能关联起来的记录（交集 ∩）`被连接后返回

  ```sql
  table_a left join table_b ... on xxx where...
  ```

- 左外连接、右外连接，指的是取并集后，`保留左表还是右表数据`

  左外连接 = 左表以及连接

  左连接：就是指依附左表，左表数据全查出来，右表只有符合条件的数据

`left outer join` 就是外连接 ，加不加 `outer` 都一样

- `left join`(左联接)

  ```sql
  -- 返回包括左表 users 中的所有的记录,右表显示满足联接条件的记录, 没有则显示null
  select * from kbssuser.users a left join kbssuser.customer b on a.user_code=b.cust_code and b.cust_code=181920761;
  ```

- `right join`(右联接)

  ```sql
  -- 返回包括右表 customer 中的所有记录, 左表显示满足联接条件的记录, 没有则显示null
  select * from kbssuser.users a right join kbssuser.customer b on a.user_code=b.cust_code and a.user_code=180000016;
  ```

- `full join`(全连接)

  全连接，显示两个表所有的信息

### 内连接

> where 查询就是内连接

- 内查询 `inner join ...on ... 相当于 ：table_a, table_b where xxx`

- 内连接查询能将左表（表 A）和右表（表 B）中`能关联起来的数据（并集 ∪）`连接后返回

  ```sql
  -- inner join(等值连接)
  -- 只返回两个表中满足联结条件的记录
  select * from kbssuser.users a inner join kbssuser.customer b on a.user_code=b.cust_code
  ```

- oracle 中的`(+)`相当于是一种语法糖

  哪个表有加号，这个表的数据就是附加，另一个表则是全部的数据

  ```sql
  -- 加号写在右表，则左表就全部显示，右表满足条件的才能显示，故以下语句左连接
  -- 这里用 `(+)` 后用的是`table_a, table_b(+) where xxx`，而不是 `table_a left join table_b on`
  select * from kbssuser.users a, kbssuser.customer b where b.cust_code(+) = 170006465 and a.user_code = b.cust_code(+);
  ```

## 一条 SQL 语句在 MySQL 中如何执行的

[一条 SQL 语句在 MySQL 中如何执行的](https://mp.weixin.qq.com/s/QU4-RSqVC88xRyMA31khMg)

[执行一条 select 语句，期间发生了什么？](https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)

![alt](https://myblog-tuchuang.oss-cn-shanghai.aliyuncs.com/1623727651911_20170928110355446.png)

![alt](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

![alt](https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzHb5ZvMdLOvjicVicD6zLAPaBNoSyMBAImH4dNKciakic9wGbRIDb9DsQbyOSx9n2I9X4icOhL0ic7scxbg/640?wx_fmt=png)

- 通过连接器与客户端 `【建立链接】`

- 先检查该语句是否有权限，如果没有权限，直接返回错误信息

- 如果有权限，在 MySQL8.0 版本以前，会先`【查询缓存】`

- 如果没有缓存，分析器进行`【词法分析】`，提取 sql 语句 select 等的关键元素。然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。

- 通过优化器 `【优化该语句】`，优化器进行确定执行方案

- 进行 `【权限校验】`，如果没有权限就直接返回错误信息

- 如果有权限就会调用数据库引擎接口，`【返回执行结果】`

## 为什么不建议使用外键

[为什么不推荐使用外键](https://blog.csdn.net/qq_22136439/article/details/103714369)

**优点**

- 由数据库自身保证数据一致性、完整性会更可靠

- 程序很难 100％ 保证数据的一致性、完整性，比如 A 表关联了 B 表的 ID，删掉 B 表数据，却没去掉 A 表的关联，所以看数据会发现 A 还关联这已经删除的记录的 ID

**缺点**

- 每次`级联 delete 或 update 的时候，都要【级联操作相关的外键表】`，不论有没有这个必要，由其在高并发的场景下，这会导致性能瓶颈

- 外键等于把数据的一致性事务实现，全部交给数据库服务器完成，并且有了外键，当做一些涉及外键字段的增，删，更新操作之后，`需要触发相关操作去进行【约束检查】`，而不得不`消耗资源、影响性能`

- 并发大流量事务场景，使用外键还可能 `容易造成死锁`

## `DDL`、`DQL`、`DML`

[DQL、DML、DDL、DCL 的概念与区别](https://blog.csdn.net/qq_39626154/article/details/83584697)

![alt](https://mmbiz.qpic.cn/mmbiz_png/HQKXnkPzzdvG7YibtwoIY3D1JXNXA1iaX2z7NIIAIrafXcwNlSFl58cg0nqbibQwicoxj4BdEesCWkXbGhvGh8ibCYA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `dql` `query` 数据查询语言

- `dml` `modify` 数据操纵语言（操作可以回滚）

- `ddl` `define` 数据定义语言（操作无法回滚）

- `dcl` `control` 数据控制语言

## `drop、delete、truncate` 的区别

> - `drop、delete、truncate` 都表示删除
> - 速度一般来说: `drop > truncate > delete`

- `delete` 和 `truncate` 只删除表的数据`不删除表的结构`

- `delete` 语句是 `dml`

  这个操作会放到 `rollback segement` 中，事务提交之后才生效， 如果有相应的触发器，执行的时候将被触发

- `truncate 和 drop` 是 `ddl`

  操作立即生效，原数据不放到 `rollback segment` 中，不能回滚. 操作不触发 触发器

**`drop、delete、truncate` 分别在什么场景之下使用**

- 不再需要一张表的时候，用 `drop`

- 想删除部分数据行时候，用 `delete`，并且带上 `where` 子句

- 保留表而删除所有数据的时候用 `truncate`
