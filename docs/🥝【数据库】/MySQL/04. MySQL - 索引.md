- [参考资料](#参考资料)
- [★ 索引原理](#-索引原理)
- [★ 索引](#-索引)
  - [索引有哪些优缺点](#索引有哪些优缺点)
  - [索引有几种、时间复杂度如何](#索引有几种时间复杂度如何)
- [索引分类](#索引分类)
  - [什么是主键索引（聚簇索引）、普通索引（非聚簇索引）](#什么是主键索引聚簇索引普通索引非聚簇索引)
  - [非聚簇索引一定会回表查询吗](#非聚簇索引一定会回表查询吗)
  - [什么是密集索引和稀疏索引](#什么是密集索引和稀疏索引)
  - [什么是覆盖索引和回表查询](#什么是覆盖索引和回表查询)
  - [★ 最左匹配原则](#-最左匹配原则)
  - [什么是联合索引](#什么是联合索引)
  - [什么是前缀索引](#什么是前缀索引)
  - [★ 什么是索引下推 (ICP)](#-什么是索引下推-icp)
    - [索引下推的例子](#索引下推的例子)
- [索引使用](#索引使用)
  - [`like` 的索引机制](#like-的索引机制)
  - [什么情况可能会使用索引](#什么情况可能会使用索引)
  - [★ 什么情况下会出现索引失效](#-什么情况下会出现索引失效)
  - [怎么在语句中强制使用其他的索引](#怎么在语句中强制使用其他的索引)
- [索引维护](#索引维护)
  - [主键使用自增 `ID` 还是 `UUID`](#主键使用自增-id-还是-uuid)
  - [数据库自增 ID 用完了会怎么样](#数据库自增-id-用完了会怎么样)
  - [创建索引需要注意些什么](#创建索引需要注意些什么)
- [拾遗](#拾遗)
- [其他](#其他)

# 参考资料

- [MySql 索引：索引基础（B-Tree 索引、哈希索引、聚簇索引、全文 (Full-text) 索引区别）](https://blog.csdn.net/shichen2010/article/details/103754029#322Hash_171)

- [关于 MySQL 索引知识与小妙招](https://www.cnblogs.com/mingyueyy/p/14159319.html)

- [★ MYSQL 中的索引](https://blog.csdn.net/ym15229994318ym/article/details/106978346)

- [★ 一文读懂索引](https://blog.csdn.net/jumpe_17/article/details/120355873)

- [我以为我对 MySQL 索引很了解，直到我被阿里面试官 22 连击](https://mp.weixin.qq.com/s/WZ64D6DfrjVxKDNUV3WmjQ)

# ★ 索引原理

[[03. MySQL - 红黑树]]

# ★ 索引

## 索引有哪些优缺点

**索引的优点**

- 可以大大`加快数据的检索速度`，这也是创建索引的最主要的原因

- 通过使用索引，可以在查询的过程中，使用`优化隐藏器，提高系统的性能`

**索引的缺点**

- 时间方面：`创建索引和维护索引要耗费时间`，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率

- 空间方面：索引需要`占物理空间`

## 索引有几种、时间复杂度如何

- `数据结构角度`

  | 索引             | InnoDB 引擎      | MyISAM 引擎 | Memory 引擎 |
  | ---------------- | ---------------- | ----------- | ----------- |
  | `BTREE` 索引     | 支持             | 支持        | 支持        |
  | `HASH` 索引      | 不支持           | 不支持      | 支持        |
  | `R-tree` 索引    | 不支持           | 支持        | 不支持      |
  | `Full-text` 索引 | 5.6 版本之后支持 | 支持        | 不支持      |

- `物理存储角度`

  - 聚集索引

  - 非聚集索引

- `逻辑角度`

  - 主键索引：主键索引是一种特殊的唯一索引，不允许有空值

  - 单列索引（普通索引）

  - 多列索引（联合索引）

  - 唯一索引或者非唯一索引

  - 空间索引

# 索引分类

- 按「数据结构」分类：B+tree 索引、Hash 索引、Full-text 索引。

- 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。

- 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。

- 按「字段个数」分类：单列索引、联合索引。

## 什么是主键索引（聚簇索引）、普通索引（非聚簇索引）

[聚簇索引与非聚簇索引（也叫二级索引）](https://www.jianshu.com/p/fa8192853184)

[MySQL 的二级索引](https://blog.csdn.net/thesprit/article/details/112989674)

非主键索引如果没有索引覆盖的话，需要哪些一次回表查询, 效率相对更低

![alt](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E5%9B%9E%E8%A1%A8.drawio.png)

- 主键索引也被称为 `聚簇索引`, 叶子节点存放的是整行数据

  将数据存储与索引放到了一块，`找到索引也就找到了数据`

- 非主键索引被称为 `二级索引 或 非聚簇索引`, 叶子节点存放的是主键的值

  将数据与索引分开存储，索引结构的叶子节点指向了数据的对应行，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据（==需要回表查询==）

- 如果根据主键查询，只需要搜索主键这颗 B+ 树

- 如果通过非主键索引查询，需要 **先搜索 K 索引树，【找到对应的主键】，然后再到 ID 索引树搜索一次，这个过程叫做【回表】**

## 非聚簇索引一定会回表查询吗

不一定，这涉及到查询语句所要求的字段**是否全部命中了索引**，`如果查询的字段全命中索引，就不必进行回表查询`

```sql

-- 假设我们在员工表的年龄上建立了索引，那么当进行以下查询时
-- 在索引的叶子节点上，已经包含了 age 信息，不会再次进行回表查询。
select age from employee where age < 20
```

## 什么是密集索引和稀疏索引

[密集索引和稀疏索引的区别](https://blog.csdn.net/yjn1995/article/details/97745532)

密集就是说每一条记录都有一个索引对应着；稀疏是指有些记录没有索引可以直接定位到，有点像线性探查法解决哈希冲突那样，到达位置后，继续往下顺序搜索。

主键必须有，而且一个表只有一个；主键是索引和数据放在一起的，二级索引才需要回表查询；

- `密集索引`

  ![alt](https://pic1.zhimg.com/v2-9b5e40439ffe471db8cfd0f336f60174_r.jpg)

  密集索引中，数据库中的每个搜索键值都有一个索引记录；每一个数据都可以直接通过索引找到；由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以`一个表只能创建一个密集索引`

- `稀疏索引`

  ![alt](https://pic1.zhimg.com/v2-edda75da238027922e248778be163b00_r.jpg)

  稀疏索引中，不会为每个搜索关键字创建索引记录。此处的索引记录包含搜索键和指向磁盘上数据的实际指针。要搜索记录，我们首先按索引记录进行操作，然后到达数据的实际位置。如果我们要寻找的数据不是我们通过遵循索引直接到达的位置，那么系统将开始顺序搜索，直到找到所需的数据为止

- `MyISAM`

  不管是主键索引、唯一键索引或者普通索引，其索引 `都属于稀疏索引`

- `InnoDB`

  - 若一个主键被定义，该`主键`则作为密集索引

  - 若没有主键被定义，该表的`第一个唯一键`作为密集索引

  - 若不满足以上条件，innodb 内部会`生成一个隐藏主键`作为密集索引

  - 非主键索引（稀疏索引）存储相关键位和它对应的主键值，包含两次查找

## 什么是覆盖索引和回表查询

- `覆盖索引`

  指的是在一次查询中，如果 `一个索引命中或者说覆盖所有需要查询的字段的值`，我们就称之为覆盖索引，而`不再需要回表查询`；就是说我要插的字段都在索引里找到了

- `回表查询`

  指`通过非主键索引查询`，找到对应的主键，然后根据根据普通索引查到的值再到主键索引搜索一次，这个过程叫做回表

  **非聚簇索引的叶子节点存放的是主键，聚簇索引存放的是数据**

  ![alt](https://img2018.cnblogs.com/blog/885859/201907/885859-20190729184911699-676257427.png)

## ★ 最左匹配原则

[MYSQL 索引失效原理与最左匹配原则](https://blog.csdn.net/tc979907461/article/details/106390911)

最左匹配原则就是指在联合索引中，**如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配**。

- 在检索数据时从联合索引的最左边开始匹配，比如我们创建了一个 `(key1, key2, key3)` 联合索引，实际上相当于创建了 `(key1)、(key1, key2)、(key1, key2, key3)` 三个索引

  查询时，会一直向右匹配；直到遇到范围查询 (>、<、between、like) 就停止匹配（范围查询的时候还是可以用索引的）

  \==注意: 有联合索引 `(a, b)`，语句 `select * from test where a >=1 and b` a 和 b 字段都能用上索引；对于 `>=、<=、between、like前缀匹配` 的范围查询，是可以用索引的==

  虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，==但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序），因此 b 字段也可以用到索引==

  去了解下什么是联合索引原理，就清楚为什么遇到范围查询就停止了

  ```sql
  select * from t where a = 5 and b > 0 and c = 1;
  -- 这样 a, b 可以用到（a,b,c）索引，但是 c 不可以
  -- 当查询到 b 的值以后（这是一个范围值），【c 是无序的】，所以就不能根据联合索引来确定到底该取哪一行

  -- 比如 b = 2
  -- 如果建立 (a, b) 顺序的索引，是匹配不到 (a, b) 索引的

  -- 但是如果查询条件是 a = 1 and b = 2 或者 a = 1（又或者是 b = 2 and a = 1）就可以，因为优化器会自动调整 a，b 的顺序（索引下推？）


  -- 比如 a = 1 and b = 2 and c > 3 and d = 4

  -- 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的
  -- 因为c字段是一个范围查询，它之后的字段会停止匹配。

  -- 如果在 (a,b,c) 三个字段上建立联合索引，那么他会自动建立 a| (a,b) | (a,b,c) 三组索引。

  -- 如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整。
  ```

- `=` 和 `in` 可以乱序

  ```sql
  where a = 1 and b = 2 and c = 3
  -- 建立(a,b,c)索引可以任意顺序
  -- MySQL 的查询优化器会帮你优化成索引可以识别的形式
  ```

## 什么是联合索引

[一次搞清楚 Mysql 联合索引，以及联合索引究竟用了多少](https://blog.csdn.net/weixin_30383279/article/details/96358714)

- 多个字段同时建立一个索引，叫做联合索引

  在联合索引中，如果想要命中索引，`需要按照建立索引时的字段顺序挨个使用`，否则无法命中索引

- **使用索引时需要索引有序**

  假设现在建立了 `(name，age，school)` 的联合索引，那么索引的排序为: 先按照 `name` 排序，如果 `name` 相同，则按照 `age` 排序，如果 `age` 的值也相等，则按照 `school` 进行排序

- 当进行查询时，此时索引仅仅按照 `name` 严格有序，因此必须首先使用 `name` 字段进行等值查询，之后对于匹配到的列而言，其按照 `age` 字段严格有序，此时可以使用 `age` 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序

- 一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

- 假如创建一个 `(a, b)` 的联合索引，那么它的索引树是这样的

  ![联合索引存储结构](https://img-blog.csdnimg.cn/20200527211615989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RjOTc5OTA3NDYx,size_16,color_FFFFFF,t_70)

  - 可以看到 a 的值是有顺序的，`(1, 1, 2, 2, 3, 3)`；而 b 的值是没有顺序的 `(1, 2, 1, 4, 1, 2)`。所以 `b = 2` 这种查询条件没有办法利用索引，因为联合索引首先是按 a 排序的，b 是无序的

  - **在 a 值相等的情况下，b 值又是按顺序排列的**

    这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引

  - 例如 `a = 1 and b = 2` a, b 字段都可以使用索引，因为在 a 值确定的情况下 b 是相对有序的，而 `a > 1 and b = 2`，a 字段可以匹配上索引，但 b 值不可以，**因为 a 的值是一个范围，在这个范围中 b 是无序的。**

## 什么是前缀索引

**对字段的前几个字符（具体是几个字符在建立索引时指定）建立索引**，这样建立起来的索引更小，查询更快

- 前缀的`标识度高，不会重复`，比如密码就适合建立前缀索引，因为密码几乎各不相同

- 不能在 `ORDER BY` 或 `GROUP BY` 中使用前缀索引，也不能把它们用作覆盖索引

- [建立前缀索引](https://www.jianshu.com/p/fc80445044cc)

  ```sql
  -- 使用字段值的前 10 个字符建立索引，默认是使用字段的全部内容建立索引
  alter table tb_name add index(column_name(10));
  ```

- 怎么确定这个前缀索引长度

  ```sql
  -- 查一下完整列的选择性
  select count(distinct column_name) / count(*) from tb_name;
  -- +---------------------------------+
  -- | count(distinct city) / count(*) |
  -- +---------------------------------+
  -- |                          0.4283 |
  -- +---------------------------------+

  -- 计算完整列的选择性，并使其前缀的选择性接近于完整列的选择性
  select count(distinct left(city,3))/count(*) as sel3,
         count(distinct left(city,4))/count(*) as sel4,
         count(distinct left(city,5))/count(*) as sel5,
         count(distinct left(city,6))/count(*) as sel6
         from city_demo;
  -- +--------+--------+--------+--------+
  -- | sel3   | sel4   | sel5   | sel6   |
  -- +--------+--------+--------+--------+
  -- | 0.3367 | 0.4075 | 0.4208 | 0.4267 |  可以看到sel5与完整列的选择性更接近，所以可以选择 6 作为前缀索引长度
  -- +--------+--------+--------+--------+
  ```

## ★ 什么是索引下推 (ICP)

**下推** 是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。

[MySQL 索引下推](https://www.cnblogs.com/cy0628/p/16366561.html)

[Mysql 性能优化：什么是索引下推](https://mp.weixin.qq.com/s?src=11&timestamp=1663575609&ver=4053&signature=TmZbI-DR43uZEPA0SE96WLKS27abWP8WY-*rf9hICB885Ac3KizDKyzVKuE0S*NSwF6jx7YAIfyFDuZgmVamQWfO6ppJpxIN9O56RfGWP4*68O9y*bZdDQ-k*IBAA2W8&new=1)

> 如果存在某些被索引的列的判断条件时，MySQL 将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，「只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器」。

==需要过滤的列，都在联合索引中==，在索引遍历过程中，存储引擎 innodb 对索引中包含的字段先做判断，过滤掉不符合条件的记录，==减少回表次数==

**在没有使用 ICP 的情况下，MySQL 的查询：**

- 存储引擎读取索引记录；

- 根据索引中的主键值，定位并读取完整的行记录；

- 存储引擎把记录交给 `Server` 层，`Server` 层去检测该记录是否满足`WHERE`条件。

**使用 ICP 的情况下，查询过程：**

- 存储引擎读取索引记录（不是完整的行记录）；

- ==存储引擎判断条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录==；

- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；

- 存储引擎把记录交给层，层检测该记录是否满足条件的其余部分。

![alt](https://img2022.cnblogs.com/blog/2174081/202206/2174081-20220611185128454-251810060.png)

### 索引下推的例子

- 【5.6 版本之前】，会对匹配的数据进行回表查询

  ![alt](https://img-blog.csdnimg.cn/img_convert/05ad65a6314bbfee93c324e797e17479.jpeg)

  有 `(name, age)` 联合索引

  ```sql
  -- 只能用到 name 这个索引，age 使用不到索引的
  -- 前面学习最左匹配元祖的时候，知道，遇到范围查询[后]，就无法在使用索引了
  -- 所以 name 可以用上索引，age 不行
  select * from test where name like "张%" and age = 10
  ```

  通过 name 进行查询，在 `(name, age)` 这棵树上查找到了两个结果，id 分别为 `2 和 1`，然后拿着取到的 id 进行回表查询，因此这个过程需要回表两次查出记录；

  再比对是否符合 age 条件。

- 【5.6 版本后】，会 **先过滤出 age = 10 的数据，再进行回表查询，减少回表率**，提升检索速度

  ![alt](https://img-blog.csdnimg.cn/img_convert/29de7adc2a9385b517a1fab4c5b3301a.jpeg)

  - `在索引内部就判断了 age 是否等于 10`，对于不等于 10 的记录直接跳过

  - 因此在 `(name, age)` 这棵索引树中只匹配到了一个记录，此时拿着这个 id 去主键索引树中回表查询全部数据，这个过程只需要回表一次。

![alt](https://img-blog.csdnimg.cn/img_convert/ff5e3ad2bdc8e485aca82cfb8b023b76.png)

根据 explain 解析结果可以看出 Extra 的值为 `Using index condition`，表示已经使用了索引下推。

# 索引使用

## `like` 的索引机制

**只对 `%` 在后面的字段走索引**，如：`like 'aa%'`；对 `%` 在中间或者前面的情况不走索引，如：`like '%aa'`或者`like 'a%a'`

```sql
> explain select * from student where Sname like 'huang%';

+----+-------------+---------+------------+-------+---------------+-------+---------+--------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key   | key_len | ref    | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+-------+---------+--------+------+----------+-----------------------+
| 1  | SIMPLE      | student | <null>     | range | Sname         | Sname | 61      | <null> | 1    | 100.0    | Using index condition |
+----+-------------+---------+------------+-------+---------------+-------+---------+--------+------+----------+-----------------------+

> explain select * from student where Sname like '%huang';
-- 没走索引， type 为 ALL，走的是全表扫描

+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | <null>        | <null> | <null>  | <null> | 4    | 25.0     | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+

```

## 什么情况可能会使用索引

`where`、`order by`、`join`

## ★ 什么情况下会出现索引失效

[MySQL 中走与不走索引的情况汇集](https://www.cnblogs.com/gxyandwmm/p/13363100.html)

[聊聊索引失效的 10 种场景](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247498821&idx=1&sn=e19eb6cf220729857b53b2f73e831463&chksm=fc7307a9cb048ebf735710146c0356ec9a3aed4e9989ec1d4f4027b03f11fde8b2f16d76e98d&mpshare=1&scene=1&srcid=09192P3wpQ4TG3mlBID2ouAR&sharer_sharetime=1663570714309&sharer_shareid=9c63fb9c4a4ec9889487c66899164186#rd)

[★ MySQL 不走索引场景已经原因](https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w)

![alt](https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5ianHlF0AzOr530aPCbgeARxMduoIvwQDZJJOOSIKFHwAdXQTOzBnEWOlvY9lR9matXZ8joTruQl4Q/640?wx_fmt=png)

> `like 模糊查询时 % 的位置`、`or`、联合索引中的顺序、有数学运算、有使用函数、存在隐形转换、`order by 排序的列在 where 中`、`<>、!=` **不等于**操作

- 条件中有 `or`，即使其中有`部分条件带索引`也不会使用

  如果使用了 or 关键字，那么它前面和后面的字段都要加索引，不然所有的索引都会失效。

  ```sql
  -- 如果 name 有索引，age 无索引，则该语句也不会走索引
  select * from test_tb a where a.name = 'huangjinjie' or a.age = 26;
  ```

- 对于`联合索引`，查询不是第一列的数据（`即不符合最左匹配原则`），则不会使用索引

  ```sql
  -- 比如 (name, age, sex) 三字段组成联合索引
  select * from test_tb a where a.name = 'huangjinjie';  -- 走索引
  select * from test_tb a where a.age = '26';            -- 不走索引
  ```

- `like` 查询是以 `% 开头`

  > 因为索引是有序排列存储的，**只对 `%` 在后面的字段走索引**，如：`like 'aa%'`；但是对 `%在中间或者前面的情况不走索引`，如：`like '%aa'`或者`like 'a%a'`

  ```sql
  -- name 列建立了索引

  select * from test_tb a where a.name like 'huang%';     -- 走索引
  select * from test_tb a where a.name like '%jinjie';    -- 不走索引
  select * from test_tb a where a.name like 'huang%jie';  -- 不走索引
  ```

- 存在索引列的 `数据类型隐形转换`，用不上索引

  ```sql
  -- 比如列类型是字符串，那一定要在条件中将数据使用引号引用起来, 否则不使用索引
  select * from test_tb a where a.sex = '1';  -- 走索引
  select * from test_tb a where a.sex = 1;    -- 有隐形转换，不走索引
  ```

- `where` 子句里对索引列上 `有数学运算`，用不上索引

  > 因为索引保存的是字段的原始值，自然索引不到函数计算后的值了

  ```sql
  -- 即使 age 列建立了索引，该语句也不会走索引
  select * from test_tb a where a.age = a.age + 1;
  ```

- `where` 子句里对索引列 `使用函数` ，用不上索引，如 `where abs(id) = 11`

  ```sql
  -- 即使 name 列建立了索引，该语句也不会走索引
  select * from test_tb a where concat('hhhh', a.name) = 'hhhhuagnjinjie';
  ```

- `order by` 操作中，排序的列同时也在 `where` 语句中，将不会使用索引

  ```sql
  select * from test_tb a where a.age = 26 order by a.age desc;
  ```

- 在索引字段上使用 `<>、!=` **【不等于操作符】（不是范围操作符）是永远不会用到索引的**，因此对它的处理只会产生全表扫描

  ```sql
  select * from test_tb where a.name != 'huangjinjie';

  select * from test_tb where a.age < 26;  -- 这样是会使用索引的

  select * from test_tb where a.age <> 26;
  -- 优化方法： a.age <> 26 改为 a.age > 26 or a.age < 26

  explain select * from device where branch_id < 3;   -- type 为 range，使用了索引
  +----+-------------+------------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+
  | id | select_type | table      | partitions | type  | possible_keys | key           | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+------------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | device | NULL       | range | idx_branch_id | idx_branch_id | 4       | NULL |    2 |   100.00 | Using index condition |
  +----+-------------+------------+------------+-------+---------------+---------------+---------+------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)

  explain select * from device where branch_id <> 3;  -- type 为 ALL 全表扫描
  +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
  | id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | device | NULL       | ALL  | idx_branch_id | NULL | NULL    | NULL |    5 |    80.00 | Using where |
  +----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)
  ```

## 怎么在语句中强制使用其他的索引

当查询语句有多个索引选择的时候，可以通过 `force index(idx_name)` 来指定使用某个索引

```sql

-- 可以看到 status 可以是用 index_query_type_and_status 和 index_query_status 两个索引

mysql> show index from log;
+---------+------------+-----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table   | Non_unique | Key_name                    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+---------+------------+-----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| log |          0 | PRIMARY                     |            1 | id          | A         |       21039 |     NULL | NULL   |      | BTREE      |         |               |
| log |          1 | index_query_type_and_status |            1 | log_type    | A         |           3 |     NULL | NULL   | YES  | BTREE      |         |               |
| log |          1 | index_query_type_and_status |            2 | status      | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               |
| log |          1 | index_query_status          |            1 | status      | A         |           2 |     NULL | NULL   | YES  | BTREE      |         |               |
+---------+------------+-----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.00 sec)

-- 强制使用指定的索引

mysql> explain select status from log force index(index_query_status);
+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+-------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key                | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | log | NULL       | index | NULL          | index_query_status | 5       | NULL | 21050 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+--------------------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select status from log force index(index_query_type_and_status);
+----+-------------+---------+------------+-------+---------------+-----------------------------+---------+------+-------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys | key                         | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+---------+------------+-------+---------------+-----------------------------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | log | NULL       | index | NULL          | index_query_type_and_status | 10      | NULL | 21050 |   100.00 | Using index |
+----+-------------+---------+------------+-------+---------------+-----------------------------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

```

# 索引维护

## 主键使用自增 `ID` 还是 `UUID`

> - 推荐使用自增 ID，不要使用 UUID
> - 在数据量大一些的情况下，用`自增主键性能会好一些`
> - `数据插入时需要移动数据，UUID 无法确定前后 ID 大小`，需要进行判断

- 在 `InnoDB` 存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的 `B+` 树叶子节点上存储了主键索引以及全部的数据(按照顺序) ，如果主键索引是自增 ID，那么只需要不断向后排列即可

- 如果是 UUID，由于`到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片`，造成插入性能的下降

## 数据库自增 ID 用完了会怎么样

[数据库自增 ID 用完了会怎么样](https://www.cnblogs.com/ilovejaney/p/14229123.html)

- 如果 `设置了主键，那么会报主键冲突`

  ```sql
  -- 创建一张测试表
  CREATE TABLE `test_max_id` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `name` varchar(32) NOT NULL DEFAULT '',
      PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=2147483647 DEFAULT CHARSET=utf8mb4;

  -- 插入成功
  insert into test_max_id(name) value('huagnjinjie');

  -- 再插入另外一条数据，报主键冲突
  insert into test_max_id(name) value('hjj');
  (1062, "Duplicate entry '2147483647' for key 'PRIMARY'")
  ```

- 如果 `没有设置主键`

  数据库则会帮我们`自动生成一个全局的 row_id`，**新数据会覆盖老数据**

- `解决方案`

  尽可能`都要设置主键`，主键尽量使用 `bigint` 类型，21 亿的上限还是有可能达到的，虽然说 row_id 上限高达 281 万亿，但是覆盖数据显然是不可接受的

## 创建索引需要注意些什么

> 是否有必要给字段上索引（`存储成本、维护成本`）、联合索引的顺序

- `or、in` 是可以用索引的

  数据量太大 (200w) 且 in 条件多，这个应该 MySQL 的`优化器自己选择判断的，当数据量很大的时候，in 查询走索引也许不是最好的`。（PS：这部分要考虑 自带的优化器的判断，关于 MySQL 的优化器的执行原理，那是相当复杂，简而言之就是各种条件判断，`选出 MySQL "自认为的最优解"`。）

- `唯一性太差、更新太频繁` 的字段，不适合建立索引；防止过多的索引对表造成太大的压力，这些都和实际的表结构以及查询方式有关

- 索引`需要空间来存储`，也`需要定期维护`

  - 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的 INSERT，DELETE，UPDATE 将为此多付出 4，5 次的磁盘 I/O。

  - 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能

- 要考虑到`字段的使用频率`, 经常作为条件进行查询的字段比较适合，`不频繁用作查询条件` 的字段，不适合建立索引

- 如果需要建立联合索引的话, 还需要`考虑联合索引中的顺序`

  在创建【联合索引】时，要根据业务需求，`where` 子句中 `使用最频繁的一列放在最左边`

- 索引范围查询(`INDEX RANGE SCAN`)适用于两种情况

  - 基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%

  - 基于非唯一性索引的检索

# 拾遗

- 索引下推

- 聚簇索引

- 索引失效的几种情况

# 其他
