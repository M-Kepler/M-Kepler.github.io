- [★ 主从同步机制](#-主从同步机制)
  - [主从复制原理以及流程](#主从复制原理以及流程)
  - [主从同步机制是什么](#主从同步机制是什么)
  - [`binlog` 和 `relaylog` 是什么](#binlog-和-relaylog-是什么)
  - [`binlog` 的录入方式有哪些](#binlog-的录入方式有哪些)
    - [`statement` 基于 【SQL 语句】的复制模式](#statement-基于-sql-语句的复制模式)
    - [`row` 基于【行数据】的复制模式](#row-基于行数据的复制模式)
    - [`mixed` 混合模式](#mixed-混合模式)
  - [主从复制的作用](#主从复制的作用)
  - [主从复制解决的问题](#主从复制解决的问题)
  - [MySQL 同步方式](#mysql-同步方式)
    - [异步复制](#异步复制)
    - [全同步复制](#全同步复制)
    - [半同步复制](#半同步复制)
  - [主从同步一致性问题](#主从同步一致性问题)
    - [为什么会有主从同步的时延问题](#为什么会有主从同步的时延问题)
    - [如何解决主从同步的时延问题](#如何解决主从同步的时延问题)
- [其他](#其他)
- [参考资料](#参考资料)

# ★ 主从同步机制

`MySQL + keepalived` 来保证高可用

[`keepalived` 是什么](https://www.cnblogs.com/losbyday/p/5841830.html)

- 专门用来`监控集群系统中各个服务节点的状态`，它根据 OSI 参考模型的第三（网络层）、第四层（传输层）、第五层（会话层）交换机制检测每个服务节点的状态，`如果某个服务器节点出现异常，或者工作出现故障，Keepalived 将检测到，并【将出现的故障的服务器节点从集群系统中剔除】`，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点

- `VRRP`（Vritrual Router Redundancy Protocol 虚拟路由冗余协议）是一种主备模式的协议，通过 VRRP 可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信

## 主从复制原理以及流程

- 将主数据库中的 `DDL` 和 `DML` 操作通过二进制日志（`binlog`）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。

## 主从同步机制是什么

> - 前提是作为主库角色的数据库服务器必须开启二进制日志
> - [mysql 主从同步](https://www.cnblogs.com/J-xiaowei/articles/12390591.html)

![alt](https://pic4.zhimg.com/v2-12f36a0aa2ea88020809173182e54e73_b.jpg)

- 主库将数据库的 `DDL`、`DML` 操作都写入到二进制日志 binlog 中，只要 master 上的数据发生改变，则将其改变写入二进制日志

- 从服务器会在一定时间间隔内 `向主库对发起连接，【探测】主库的 binlog 是否发生改变`，如果发生改变，则创建一个 **`I/O 线程`** 向主库 `【请求】` 二进制事件

- 主库 `启动一个 dump 线程，把 binlog 【发送】给从库`

- 从库的 `I/0 线程【接收】主库发过来的 binlog`，并保存至从库的 `relaylog` 中继日志中

- 从库启动 **`SQL 线程`** 从 `relaylog` 中继日志中读取二进制日志，`把数据【写入】到 DB`，使得其数据和主节点的保持一致

- 最后 I/O 线程 和 SQL 线程将进入睡眠状态，等待下一次被唤醒

## `binlog` 和 `relaylog` 是什么

```sql
-- 查看 binlog 相关的配置
mysql> show variables like "log_bin%";
+---------------------------------+-----------------------------+
| Variable_name                   | Value                       |
+---------------------------------+-----------------------------+
| log_bin                         | ON                          |
| log_bin_basename                | /var/lib/mysql/binlog       |
| log_bin_index                   | /var/lib/mysql/binlog.index |
| log_bin_trust_function_creators | OFF                         |
| log_bin_use_v1_row_events       | OFF                         |
+---------------------------------+-----------------------------+

-- 查看 relay 相关的配置
mysql> show variables like "%relay%";
+---------------------------+-------------------------------------------+
| Variable_name             | Value                                     |
+---------------------------+-------------------------------------------+
| max_relay_log_size        | 0                                         |
| relay_log                 | xxxxxxx-PC-relay-bin                      |
| relay_log_basename        | /var/lib/mysql/xxxxxxx-PC-relay-bin       |
| relay_log_index           | /var/lib/mysql/xxxxxxx-PC-relay-bin.index |
| relay_log_info_file       | relay-log.info                            |
| relay_log_info_repository | TABLE                                     |
| relay_log_purge           | ON                                        |
| relay_log_recovery        | OFF                                       |
| relay_log_space_limit     | 0                                         |
| sync_relay_log            | 10000                                     |
| sync_relay_log_info       | 10000                                     |
+---------------------------+-------------------------------------------+

```

**`binlog`**

- 二进制格式的日志，用于记录用户对数据库`更新的 SQL 语句`信息

- 主要用于 主从同步、数据恢复

**`relaylog`**

- 中继日志，用于存储从主节点同步过来的 binlog 日志内容

- 从库通过 IO 线程读取主库的 `binlog`，写入到中继日志 `relaylog` 中，从服务器通过 `sql running` 线程读取从库的 `relaylog` ，并写入到从库的 `binlog` 实现同步。

## `binlog` 的录入方式有哪些

- 查看录入模式

  ```sql
  mysql> show variables like 'binlog_format';
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | binlog_format | ROW   |  -- 默认用的是 ROW 模式
  +---------------+-------+
  1 row in set (0.00 sec)
  ```

### `statement` 基于 【SQL 语句】的复制模式

每一条会修改数据的 sql 都会记录到主库的 binlog 中。从库在复制的时候 sql 进程会解析成和原来 master 端执行过的相同的 sql 来再次执行

- 存在的问题分析

  假设主库执行删除这个 SQL（其中 a 和 create_time 都有索引）如下：

  ```sql
  delete from t where a > '666' and create_time < '2022-03-01' limit 1;
  ```

  数据库选择了 `a` 索引还是选择 `create_time` 索引，最后 `limit 1` `查出来的数据一般是不一样的`。所以就会存在这种情况：在 `binlog = statement` 格式时，主库在执行这条 SQL 时，使用的是索引 a，而从库在执行这条 SQL 时，使用了索引 create_time。最后主从数据不一致了。

  **鉴于此问题，MySQL 还提供了 `row` 格式** 的 binlog

### `row` 基于【行数据】的复制模式

日志中会记录成每一行数据被修改的形式，然后在从库再对相同的数据进行修改

row 格式的日志，记录的是两个事件 `Table_map` 和 `Delete_rows`。`Table_map`说明要操作的表，`Delete_rows` 用于定义要删除的行为，记录删除的具体行数。row 格式的 binlog 记录的就是要删除的主键 ID 信息，因此不会出现主从不一致的问题。

- 存在的问题分析

  如果 SQL 删除 10 万行数据，使用 `row 格式就会很占空间的`，10 万条数据都在 binlog 里面，写 binlog 的时候也很耗 IO。

  **鉴于此问题，MySQL 提供了 `mixed` 格式**的 binlog

### `mixed` 混合模式

实际上就是前两种模式的结合，在 mixed 模式下，会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选一种。

## 主从复制的作用

- 主数据库出现问题，可以切换到从数据库

- 可以进行数据库层面的`读写分离`

- 可以在从数据库上进行日常`备份`

## 主从复制解决的问题

- `数据分布`

  随意开始或停止复制，并在不同地理位置分布数据备份

- `负载均衡`

  降低单个服务器的压力

- `高可用和故障切换`

  帮助应用程序避免单点失败

- `升级测试`

  可以用更高版本的 MySQL 作为从库

## MySQL 同步方式

[mysql 同步方式\_MYSQL 主从同步详解](https://blog.csdn.net/weixin_31703753/article/details/113438478)

由于==默认的复制方式是异步的，`主库把日志发送给从库后，不关心从库是否已经处理`==，这样会产生一个问题就是`假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了`。由此产生两个概念。

### 异步复制

> 默认的复制即是异步的

主节点 `执行完客户端提交的事务后立即提交事务并返回给客户端，并【不关心 log dump 线程是否成功地将将此次事务 写进 binglog 并且发送给从库】`。假如执行事务的主线程提交事务后，log dump 线程还未来得及写入 binlog，此时系统宕机，则会造成 binglog 中没有保存刚才提交的事务，造成主从数据不一致。

### 全同步复制

主库写入 `binlog` 后强制同步日志到从库，`【所有的从库都执行完成后才返回给客户端】`，但是很显然这个方式的话性能会受到严重影响。（要等从库执行完，所以耗时久的事务也是影响主从时延的一个因素）

### 半同步复制

半同步复制的逻辑是，从库写入日志成功后返回确认给主库，`【主库收到至少一个从库的确认】`就认为写操作完成

## 主从同步一致性问题

> - 主库数据同步到从库期间，主库还会接收请求，这部分的数据怎么同步给从库？
> - Redis 主从同步有增量模式，有 **`repl_backlog_buffer` 复制积压缓冲区** 和 **`slave_repl_offset` 复制偏移量**

- 主库和从库在同步数据的过程中断怎么办呢，数据不就会丢失了嘛。因此`主库与从库之间维持了一个长链接`，主库内部有一个线程，专门服务于从库的这个长链接的。

- binlog 提供三种录入方式，以避免数据错乱

### 为什么会有主从同步的时延问题

[MySQL 同步延迟问题](https://www.jianshu.com/p/ed19bb0e748a)

- 从库的配置往往没有主库的`【配置】`高

- 主库支持并发写入，而 5.7 之前的版本上从库只有`【单线程】`SQL 来完成任务

- `【网络问题】`，往返时延 RTT 较大

- `【大事务操作】`，比如大并发的【更新】操作，一次更新很多数据，从库读取 binlog 的线程只有一个，没处理那么快，从库也要完成这个事务才算同步成功

### 如何解决主从同步的时延问题

[MySQL 中主库跑太快，从库追不上怎么整](https://mp.weixin.qq.com/s/J-2uAfB3UW4v4jGJZ-pOog)

**方案一：`采用重试、二次查询的方式`**

- 如果同步延时不是很大，调用接口查询的时候，如果返回数据为空，则加入到`重试任务`中。（如果这条数据确实不存在，那就浪费了重试的性能消耗了）

- 二次查询。`如果从库查不到数据，则再去主库查一遍`，由 API 封装即可，算是一个兜底策略，比较简单。不过等于读的压力又转移到主库身上了，如果有不法分子估计搞一下必定查不到的查询，这就难受了

**方案二：使用 MySQL5.7 以上版本**

- MySQL5.7 版本后引入新的机制，即基于组提交的并行复制

**方案三：使用过程中注意**

- 在业务初期就`选择合适的分库、分表策略`，避免单表单库过大带来额外的复制压力

- `避免一些无用的I/O`消耗，使用 PCIE-SSD 硬盘

- 避免数据库进行各种大量的运算

# 其他

- [mysql 查看 binlog 日志](https://www.cnblogs.com/softidea/p/12624778.html)

# 参考资料

- [Mysql 主从机制](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247497982&idx=1&sn=bb589329cceb5462fc41f66ec63dbf56&chksm=cf2227d7f855aec16dd4d3b3425c0401850eeaf2c9cdc82e82722d38a00c24ee9ccfa3353774&scene=90&subscene=93&sessionid=1646181601&clicktime=1646181604&enterid=1646181604&ascene=56&devicetype=android-30&version=28001431&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=A3TQKweT6P3kPAxTFnGpFTI%3D&pass_ticket=hHyfuqGEb9ZXrlSpNyWU%2F2TCYzCQdnXR4dV36p0S6W4RjKkAwriwY%2FdKudiHcqE5&wx_header=3)
