- [存储引擎](#存储引擎)
  - [存储引擎了解多少](#存储引擎了解多少)
  - [`MyISAM` 索引与 `InnoDB` 索引的区别](#myisam-索引与-innodb-索引的区别)
  - [如何根据业务场景选择存储引擎](#如何根据业务场景选择存储引擎)
  - [`InnoDB` 引擎的四大特性有哪些](#innodb-引擎的四大特性有哪些)
  - [InnoDB 的事务是用的哪种](#innodb-的事务是用的哪种)
  - [三大范式](#三大范式)
  - [存储方式是怎么样的](#存储方式是怎么样的)
- [行数据库、列数据库](#行数据库列数据库)

## 存储引擎

### 存储引擎了解多少

> 常见的存储引擎有 InnoDB 和 MyISAM

- 其中 InnoDB 是`行级锁`，MyISAM 是`表级锁`，InnoDB 的并发更高

- 其中 InnoDB 支持`事务`，MyISAM 不支持事务

- 其中 InnoDB 支持`外键`，MyISAM 不支持外键

- 其中 InnoDB 有完整的容灾备份系统，支持在线热备 Tumy

- 其中统计行数用 MyISAM 更快，MyISAM 查询更快。InnoDB 增、删、修比较快

### `MyISAM` 索引与 `InnoDB` 索引的区别

- `InnoDB` 索引是聚簇索引，`MyISAM` 索引是非聚簇索引

- `InnoDB` 的主键索引的叶子节点存储着行数据，因此主键索引非常高效

- `MyISAM` 索引的叶子结点存储的是行数据地址，需要再寻址一次才能得到数据

- `InnoDB` 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询是做到覆盖索引会非常高效

### 如何根据业务场景选择存储引擎

> 如果没有特别的需求，使用默认的 `InnoDB`（MySQL5.5 后，Innodb 成为了默认的索引引擎）

- `MyISAM`

  [MyISAM 引擎的特点及优化方法](https://www.cnblogs.com/liulei-LL/articles/7693165.html)

  - `不需要支持事务`的业务 (例如转账, 付款就不行)

  - `读多【或】写多都可以`；一般为读数据比较多的应用, 读写都频繁则不合适，会堵塞。

  - 读写并发访问较少的业务 (单独读或者单独写高并发可以, 同时读写并发不行)(主要是锁定机制问题, 其实锁定整个表, 会有堵塞问题)

  - 数据修改相对较少的业务

  - 对数据一致性要求不是非常高的业务

  - 硬件资源较差的机器可以使用 MyISAM, 一般为中小型网站

- `InnoDB`

  `更新删除操作频率高`，或者要保证数据的完整性；并发量高，支持事务和外键，比如 OA 自动化办公系统。

### `InnoDB` 引擎的四大特性有哪些

- 插入缓冲（insert buffer）

- 二次写（double write）

- 自适应哈希索引（ahi）

- 预读（read ahead）

### InnoDB 的事务是用的哪种

> 默认是 RR（可重复读）；解决了不可重复读问题，没有解决幻读（可以通过`间隙锁`锁住附近的记录来解决）

```sql
-- 查看引擎的事务隔离级别
show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+

-- 或者 select @@global.tx_isolation, @@tx_isolation;
+-----------------------+-----------------+
| @@global.tx_isolation | @@tx_isolation  |
+-----------------------+-----------------+
| REPEATABLE-READ       | REPEATABLE-READ |
+-----------------------+-----------------+

```

### 三大范式

[「每天一道面试题」数据库三大范式](https://m.toutiao.com/article/7030652472536482317/?upstream_biz=toutiao_pc)

- 第一范式

  数据表中的每一列（每个字段）都不可以再拆分

  比如某些数据库系统中需要用到 “地址” 这个属性，本来直接将 “地址” 属性设计成一个数据库表的字段就行。但是如果系统经常会访问 “地址” 属性中的 “城市” 部分，那么就非要将 “地址” 这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便

- 第二范式

  在第一范式的基础上，非主键列**完全依赖于主键**，而不能是依赖于主键的一部分（针对联合主键的情况）。

  比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键；但这个表中是以订单编号和商品编号作为联合主键，这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。

- 第三范式

  在满足第二范式的基础上，表中的非主键**只依赖于主键**，而不依赖于其他非主键

  比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。

### 存储方式是怎么样的

- `InnoDB` 的索引是 `B+ Tree`的结构

- `B+ Tree` 只有`叶子节点存储数据`，每个叶子节点的数据与下一个叶子节点有一个指针指向

## 行数据库、列数据库

> - `面向行的数据库`：比如 MySQL、PostgreSQL 和大多数传统的关系数据库
> - `面向列的数据库`：比如 HBase、MonetDB

- 区别在于存储数据的方式，行数据库是一行一行存储、列数据库是一列一列存储

- [行式数据库和列式数据库区别](https://blog.csdn.net/gltncx11/article/details/84677169)

  ![alt](https://img-blog.csdnimg.cn/20181201183054996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dsdG5jeDEx,size_16,color_FFFFFF,t_70)
