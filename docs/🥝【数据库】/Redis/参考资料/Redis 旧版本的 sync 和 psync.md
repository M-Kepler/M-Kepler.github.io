- [新版复制功能的实现 psync](#新版复制功能的实现-psync)
  - [部分重同步的实现](#部分重同步的实现)
  - [复制偏移量](#复制偏移量)
  - [复制积压缓冲区](#复制积压缓冲区)
    - [根据需要调整复制积压缓冲区的大小](#根据需要调整复制积压缓冲区的大小)
  - [服务器运行 ID](#服务器运行-id)
  - [PSYNC 命令的实现](#psync-命令的实现)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/6871980170460364807)

旧版复制功能的缺陷 sync 在 Redis 中，从服务器对主服务器的复制可以分为以下两种情况：初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；断

### 旧版复制功能的缺陷 sync

在 Redis 中，从服务器对主服务器的复制可以分为以下两种情况：

- `初次复制`

  从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；

- `断线后重复制`

  处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。

对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。

#### SYNC 命令是一个非常耗费资源的操作

SYNC 命令是非常消耗资源的，因为每次执行 SYNC 命令，主从服务器需要执行一下操作：

- 主服务器需要执行 BGSAVE 命令来生成 RDB 文件，这个生成操作会耗费主服务器大量的 CPU、内存和磁盘 I/O 资源；

- 主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响；

- 接收到 RDB 文件的从服务器需要载入主服务器发来的 RDB 文件，并且在载入期间，从**服务器会因为阻塞而没办法处理命令请求**。

SYNC 是一个如此消耗资源的命令，所以 Redis 最好在真需要的时候才需要执行 SYNC 命令。

## 新版复制功能的实现 psync

为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis 从 2.8 版本开始，使用 **PSYNC** 命令代替 SYNC 命令来执行复制时的同步操作。

PSYNC 命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：

- 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和 SYNC 命令的执行步骤基本一样，它们都是通过让主服务器创建并发送 RDB 文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步；
- 而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，**如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。**

### 部分重同步的实现

部分重同步功能由以下三个部分构成：

- 主服务器的**复制偏移量**（replication offset）和从服务器的复制偏移量；

- **主服务器的复制积压缓冲区（replication backlog）**；

- **服务器的运行 ID**（run ID）。

### 复制偏移量

执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：

- 主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量的值加上 N；
- 从服务器每次收到主服务器传播来的 N 个字节的数据时，就将自己的复制偏移量的值加上 N；

通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：

- 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的；
- 相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。

![alt](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f47f59f86f414c95aed143ae25288ddb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

假设从服务器 A 在断线之后就立即重新连接主服务器，并且成功，那么接下来，**从服务器将向主服务器发送 PSYNC 命令，报告从服务器 A 当前的复制偏移量为 10086**， 那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器又如何补偿从服务器 A 在断线期间丢失的那部分数据呢？以上问题的答案都和复制积压缓冲区有关。

### 复制积压缓冲区

复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为 1MB。

和普通先进先出队列随着元素的增加和减少而动态调整长度不同，固定长度先进先出队列的长度是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。

当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如图所示。

![alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d79679578e462dad9b00938492338d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量，就像下表所示的那样。

![alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/704eeca0f1154689929baf714a0ca7cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

当从服务器重新连上主服务器时，从服务器会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：

- 如果 offset 偏移量之后的数据（也即是偏移量 offset+1 开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作；

- 相反，如果 offset 偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。

#### 根据需要调整复制积压缓冲区的大小

Redis 为复制积压缓冲区设置的默认大小为 1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么 PSYNC 命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。
复制积压缓冲区的最小大小可以根据公式 second\*write_size_per_second 来估算：

- 其中 second 为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）；

- 而 write_size_per_second 则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）；

例如，如果主服务器平均每秒产生 1 MB 的写数据，而从服务器断线之后平均要 5 秒才能重新连接上主服务器，那么复制积压缓冲区的大小就不能低于 5MB。
为了安全起见，可以将复**制积压缓冲区的大小设为 2_second_write_size_per_second**，这样可以保证绝大部分断线情况都能用部分重同步来处理。

至于复制积压缓冲区大小的修改方法，可以参考配置文件中关于 **repl-backlog-size** 选项的说明。

### 服务器运行 ID

除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行 ID（run ID）：

- 每个 Redis 服务器，**不论主服务器还是从服务，都会有自己的运行 ID**；

- 运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成，例如 53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3；

当从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，而从服务器则会将这个运行 ID 保存起来（注意哦，是**从服务器保存了主服务器的 ID**）。

当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行 ID：

- 如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；

- 相反地，如果从服务器保存的运行 ID 和当前连接的主服务器的运行 ID 并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。

### PSYNC 命令的实现

PSYNC 命令的调用方法有两种：

- 如果从服务器以前没有复制过任何主服务器，或者之前执行过 SLAVEOF no one 命令，那么从服务器在开始一次新的复制时将向主服务器发送 PSYNC ? -1 命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）；

- 相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 PSYNC 命令：其中 runid 是上一次复制的主服务器的运行 ID，而 offset 则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。

根据情况，接收到 PSYNC 命令的主服务器会向从服务器返回以下三种回复的其中一种：

- 如果主服务器返回 + FULLRESYNC 回复，那么表示主服务器将与从服务器执行完整重同步操作：其中 runid 是这个主服务器的运行 ID，从服务器会将这个 ID 保存起来，在下一次发送 PSYNC 命令时使用；而 offset 则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量；

- 如果主服务器返回 + CONTINUE 回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了；

- 如果主服务器返回 - ERR 回复，那么表示主服务器的版本低于 Redis 2.8，它识别不了 PSYNC 命令，从服务器将向主服务器发送 SYNC 命令，并与主服务器执行完整同步操作。

![alt](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adae4a122f3043838e66d6466a31bdeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
