- [引言](#引言)
  - [主从模式](#主从模式)
    - [**主从级联模式分担全量复制时的主节点压力**](#主从级联模式分担全量复制时的主节点压力)
    - [**主从节点间网络断了怎么办？**](#主从节点间网络断了怎么办)
    - [总结](#总结)
  - [哨兵模式](#哨兵模式)
    - [**哨兵机制的基本流程**](#哨兵机制的基本流程)
    - [**主观下线和客观下线**](#主观下线和客观下线)
    - [**如何选定新主库？**](#如何选定新主库)
    - [总结](#总结-1)
    - [pub/sub 机制](#pubsub-机制)
      - [**基于** **pub/sub** **机制的哨兵集群组成**](#基于-pubsub-机制的哨兵集群组成)
      - [基于 INFO 命令的从节点列表，这可以帮助哨兵和从节点建立连接](#基于-info-命令的从节点列表这可以帮助哨兵和从节点建立连接)
      - [基于哨兵自身的 pub/sub 功能，实现了客户端和哨兵之间的事件通知](#基于哨兵自身的-pubsub-功能实现了客户端和哨兵之间的事件通知)
    - [**由哪个哨兵执行主从切换？**](#由哪个哨兵执行主从切换)
    - [分享一个经验](#分享一个经验)
  - [Cluster 集群模式](#cluster-集群模式)
    - [**如何保存更多数据？** （通用思想）](#如何保存更多数据-通用思想)
    - [Redis Cluster 方案——Hash Slot 插槽算法](#redis-cluster-方案hash-slot-插槽算法)
    - [Cluster 集群节点的通讯](#cluster-集群节点的通讯)
    - [**客户端如何定位数据？**](#客户端如何定位数据)
    - [Redis Cluster 集群故障转移和故障恢复](#redis-cluster-集群故障转移和故障恢复)
    - [总结](#总结-2)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7109506994075074567#heading-0)

## 引言

Redis 高可靠性，有两层含义：一是**数据尽量少丢失**，二是**服务尽量少中断**。AOF 和 RDB 的持久化保证了数据尽量少丢失，而对于服务尽量少中断，Redis 的做法就是**增加副本冗余量**，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。

Redis 实现高可靠有三种部署模式：**主从模式，哨兵模式，集群模式**。

### 主从模式

主从模式中，主从节点之间采用的是读写分离的方式。主节点负责读写操作，从节点只负责读操作。从节点的数据来自主节点，实现原理就是**主从复制机制**

主从复制包括全量复制，增量复制两种。一般当从节点（slave）第一次启动连接主节点（master），就采用**全量复制**，全量复制主要包括三个阶段：

第一阶段，**从节点和主节点建立起连接，并告诉主节点即将进行同步，主节点确认回复后，主从节点间就可以开始同步了**。

具体来说，从节点给主节点发送 psync 命令，表示要进行数据同步，主节点根据这个命令的参数来启动复制。psync 命令包含了**主节点的 runID** 和**复制进度 offset** 两个参数。第一次复制时， runID 设为 “？”，offset 设为 -1。

主节点收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主节点 runID 和主节点目前的复制进度 offset，返回给从节点。从节点收到响应后，会记录下这两个参数。

第二阶段，**主节点将所有数据同步给从节点。从节点收到数据后，在本地完成数据加载**。这个过程依赖于内存快照生成的 RDB 文件。

具体来说，主节点执行 bgsave 命令，生成 RDB 文件，接着将文件发给从节点。从节点接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。

在主节点将数据同步给从节点的过程中，主节点不会被阻塞，仍然可以正常接收请求。为了保证主从节点的数据一致性，主节点会在内存中用专门的 replication buffer，记录 RDB 文件生成之后收到的所有写操作。

第三个阶段，主节点会把第二阶段执行过程中新收到的写命令，再发送给从节点。

具体来说，当主节点完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从节点，从节点再重新执行这些操作。

这样一来，主从节点就实现同步了。

#### **主从级联模式分担全量复制时的主节点压力**

一次全量复制中，对于主节点来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。

如果从节点数量很多，而且都要和主节点进行全量复制的话，就会导致主节点忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主节点响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主节点的网络带宽，同样会给主节点的资源使用带来压力。

我们可以**通过 “主 - 从 - 从” 模式将主节点生成 RDB 和传输 RDB 的压力以级联的方式分散到从节点上**。

简单来说，我们在部署主从集群的时候，可以手动选择一个从节点（比如选择内存资源配置较高的从节点），用于级联其他的从节点。其他的从节点不用再和主节点进行交互了，只要和级联的从节点进行写操作同步就行了，这就可以减轻主节点上的压力。

一旦主从节点完成了全量复制，它们之间就会一直维护一个网络连接，主节点会通过这个连接将后续收到的命令操作再同步给从节点，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。

#### **主从节点间网络断了怎么办？**

在 Redis 2.8 之前，如果主从节点在命令传播时出现了网络闪断，那么，从节点就会和主节点重新进行一次全量复制，开销非常大。

从 Redis 2.8 开始，网络断了之后，主从节点会采用增量复制的方式继续同步。当主从节点断连后，主节点你会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。

repl_backlog_buffer 是一个环形缓冲区，**主节点会记录自己写到的位置（ master_repl_offset），从节点则会记录自己已经读到的位置（ slave_repl_offset）** 。

主从节点的连接恢复之后，从节点首先会给主节点发送 psync 命令，并把自己当前的 slave_repl_offset 发给主节点，主节点会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。主节点只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从节点就行。

不过，有一个地方我要强调一下，因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主节点会继续写入，此时，就会覆盖掉之前写入的操作。**如果从节点的读取速度比较慢，就有可能导致从节点还未读取的操作被主节点新写的操作覆盖了，这会导致主从节点间的数据不一致**。

一般而言，我们可以调整 **repl_backlog_size** 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主节点写入命令速度 *操作大小 - 主从节点间网络传输命令速度* 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值。

#### 总结

Redis 的主从节点同步的基本原理，总结来说，有三种模式：全量复制、基于长连接的命令传播，以及增量复制。

全量复制虽然耗时，但是对于从节点来说，如果是第一次同步，全量复制是无法避免的，一个比较好的建议：**一个 Redis 实例的数据库不要太大**，一个实例大小在几 GB 级别比较合适，这样可以减少 RDB 文件生成、传输和重新加载的开销。另外，为了避免多个从节点同时和主节点进行全量复制，给主节点过大的同步压力，我们也可以采用 “主 - 从 - 从” 这种级联模式，来缓解主节点的压力。

长连接复制是主从节点正常运行后的常规同步阶段。在这个阶段中，主从节点之间通过命令传播实现同步。不过，这期间如果遇到了网络断连，增量复制就派上用场了。特别需要注意一下 repl_backlog_size 这个配置参数。如果它配置得过小，在增量复制阶段，可能会导致从节点的复制进度赶不上主节点，进而导致从节点重新进行全量复制。所以，通过调大这个参数，可以减少从节点在网络断连时全量复制的风险。

主从模式使用读写分离虽然避免了同时写多个实例带来的数据不一致问题，但是还面临主节点故障的潜在风险。

### 哨兵模式

主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis 从 2.8 开始正式提供了 Redis Sentinel（哨兵）架构来解决这个问题。哨兵机制是实现主从节点自动切换的关键机制。

#### **哨兵机制的基本流程**

哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主节点）和通知。

**监控**是指哨兵进程在运行时，周期性地给所有的主从节点发送 PING 命令，检测它们是否仍然在线运行。如果从节点没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为 “下线状态”；同样，如果主节点也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主节点下线，然后开始**自动切换主节点**的流程。

**选主**是主节点挂了以后，哨兵就需要从很多个从节点里，按照一定的规则选择一个从节点实例，把它作为新的主节点。

**通知**是哨兵会把新主节点的连接信息发给其他从节点，让它们执行 replicaof 命令，和新主节点建立连接，并进行数据复制。同时，哨兵会把新主节点的连接信息通知给客户端，让它们把请求写操作发到新主节点上。

#### **主观下线和客观下线**

**哨兵进程会使用 PING 命令检测它自己和主、从节点的网络连接情况，用来判断实例的状态**。如果哨兵发现主节点或从节点对 PING 命令的响应超时了，那么，哨兵就会先把它标记为 “主观下线”。

但是呢，一个哨兵进程对 Redis 节点进行监控，就可能会出现**单点问题**。

因此，哨兵机制**通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群**。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好而误判。

当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认主库的确进入了主观下线状态， 则主库会被标记为客观下线。再进入选主的流程

#### **如何选定新主库？**

首先，哨兵会按照在线状态、网络状态，筛选过滤掉一部分不符合要求的从节点，然后，依次按照优先级、复制进度、ID 号大小再对剩余的从节点进行打分，只要有得分最高的从节点出现，就把它选为新主节点。

在筛选时，**除了要检查从节点的当前在线状态，还要判断它之前的网络连接状态**。如果从节点总是和主节点断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从节点的网络状况并不是太好，就可以把这个从节点筛掉了。

接下来对剩余的从节点，分别按照从节点优先级、从节点复制进度以及从节点你 ID 号进行三轮打分，只要在某一轮中，有从节点得分最高，那么它就是主节点了，选主过程到此结束。如果没有出现得分最高的从节点，那么就继续进行下一轮

**第一轮：优先级最高的从节点得分高。** 用户可以通过 slave-priority 配置项，给不同配置的从节点设置不同优先级。

**第二轮：和旧主节点同步程度最接近的从节点得分高。** 选择和旧主节点同步最接近的那个从节点作为新主节点，那么，这个新主节点上就有最新的数据。

**第三轮：ID 号小的从节点得分高。** 在优先级和复制进度都相同的情况下，ID 号最小的从节点得分最高，会被选为新主节点。

#### 总结

主从集群的数据同步，是数据可靠的基础保证；而在主库发生故障时，自动的主从切换是服务不间断的关键支撑。

Redis 的哨兵机制自动完成了以下三大功能，从而实现了主从库的自动切换，可以降低 Redis 集群的运维开销：

* 监控主从节点运行状态，并判断主节点是否客观下线；
* 在主节点客观下线后，选取新主节点；
* 选出新主节点后，通知从节点和客户端。

为了降低误判率，在实际应用时，哨兵机制通常采用多实例的方式进行部署，多个哨兵实例通过 “少数服从多数” 的原则，来判断主节点是否客观下线。

#### pub/sub 机制

有了 pub/sub 机制，哨兵和哨兵之间、哨兵和主从节点之间、哨兵和客户端之间就都能建立起连接了。

##### **基于** **pub/sub** **机制的哨兵集群组成**

哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。

哨兵只要和主节点建立起了连接，就可以在主节点上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主节点上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主节点上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。

除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。

所以，为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。**只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换**。

在主从集群中，主节点上有一个名为 `__ sentinel __:hello` 的频道，不同哨兵就是通过它来相互发现，实现互相通信的。这样一来，哨兵集群就形成了。

举个例子，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到 “**sentinel**:hello” 频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。

##### 基于 INFO 命令的从节点列表，这可以帮助哨兵和从节点建立连接

这是由哨兵向主节点发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主节点发送 INFO 命令，主节点接受到这个命令后，就会把从节点列表返回给哨兵。接着，哨兵就可以根据从节点列表中的连接信息，和每个从节点建立连接，并在这个连接上持续地对从节点进行监控。哨兵 1 和 3 可以通过相同的方法和从节点建立连接。

##### 基于哨兵自身的 pub/sub 功能，实现了客户端和哨兵之间的事件通知

哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。

客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。

举个例子，你可以执行如下命令，来订阅 “所有实例进入客观下线状态的事件”：

```
SUBSCRIBE +odown
```

#### **由哪个哨兵执行主从切换？**

确定由哪个哨兵执行主从切换的过程，和主节点 “客观下线” 的判断过程类似，也是一个 “投票仲裁” 的过程。

任何一个哨兵实例只要自身判断主节点 “主观下线” 后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主节点的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。

一个哨兵获得了仲裁所需的赞成票数后，就可以标记主节点为 “客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。

此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为 “Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。

在投票过程中，任何一个哨兵想成为 Leader ，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。

#### 分享一个经验

**要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds**。我们曾经就踩过一个 “坑”。当时，在我们的项目中，因为这个值在不同的哨兵实例上配置不一致，导致哨兵集群一直没有对有故障的主节点形成共识，也就没有及时切换主节点，最终的结果就是集群服务不稳定。

### Cluster 集群模式

哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是主从节点存储的数据是一样的，我们需要解决在线扩容的问题。 因此，Cluster 集群应运而生，它在 Redis3.0 加入的，实现了 Redis 的**分布式存储**。对数据进行分片，也就是说**每台 Redis 节点上存储不同的内容**，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。

#### **如何保存更多数据？** （通用思想）

**纵向扩展**：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。纵向扩展的好处是，**实施起来简单、直接**。但是，当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞。另外**纵向扩展会受到硬件和成本的限制**。毕竟，把内存从 32GB 扩展到 64GB 还算容易，但是，要想扩充到 1TB，就会面临硬件容量和成本上的限制了。

**横向扩展**：横向增加当前 Redis 实例的个数。**在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择**。

#### Redis Cluster 方案——Hash Slot 插槽算法

Redis Cluster 方案采用哈希槽来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

具体的映射过程分为两大步：首先根据键值对的 key，按照 CRC16 算法计算出一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？

我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。

当然， 我们也可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用 cluster addslots 命令，根据不同实例的资源配置情况，指定每个实例上的哈希槽个数。

```
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1 
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3 
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```

**在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作**。

#### Cluster 集群节点的通讯

一个 Redis 集群由多个节点组成，**各个节点之间是怎么通信的呢**？通过 **Gossip 协议**！

Redis Cluster 集群通过 Gossip 协议进行通信，节点之间不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot 信息等等。常用的 Gossip 消息分为 4 种，分别是：ping、pong、meet、fail。

> * meet 消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。
> * ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。
> * pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。
> * fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。

特别的，每个节点是通过**集群总线 (cluster bus)** 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加 10000。例如某个 node 的端口号是 6379，那么它与其它 nodes 通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。

#### **客户端如何定位数据？**

在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。

在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，当实例之间相互连接后，实例之间不断交换信息，每个实例就有所有哈希槽的映射关系。

一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：

* 在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；
* 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。

此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致客户端缓存的分配信息和最新的分配信息就不一致。

Redis Cluster 方案提供了一种**重定向机制，** 当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回一个 error， MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和新实例连接，并发送操作请求了。同时还会更新本地缓存。

```
GET hello:key 
(error) MOVED 13320 172.16.19.5:6379
```

另一种情况是当客户端向旧实例发送请求，但此时，旧实例中的数据只有一部分迁移到了新实例，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息，如下所示：

```
GET hello:key 
(error) ASK 13320 172.16.19.5:6379
```

ASK 命令表示两层含义：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。

和 MOVED 命令不同，**ASK 命令并不会更新客户端缓存的哈希槽分配信息**。ASK 命令的作用只是让客户端能给新实例发送一次请求。

#### Redis Cluster 集群故障转移和故障恢复

Redis Cluster 集群中，需要确保 16384 个槽对应的 node 都正常工作，如果某个 node 出现故障，它负责的 slot 也会失效，整个集群将不能工作。

因此为了保证高可用，Cluster 集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。

这和哨兵模式里面的主观下线、客观下线、如何选定新的主节点是一样的。

#### 总结

在应对数据量扩容时，虽然增加内存这种纵向扩展的方法简单直接，但是会造成数据库的内存过大，导致性能变慢。Redis 切片集群提供了横向扩展的模式，也就是使用多个实例，并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，再通过哈希槽分散保存到不同的实例上。这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。

另外，集群的实例增减，或者是为了实现负载均衡而进行的数据重新分布，会导致哈希槽和实例的映射关系发生变化，客户端发送请求时，会收到命令执行报错信息。需要了解 MOVED 和 ASK 命令，你就不会为这类报错而头疼了。
