- [★ 数据结构](#-数据结构)
  - [参考资料](#参考资料)
  - [基本数据结构](#基本数据结构)
    - [字符串 string](#字符串-string)
    - [列表 list](#列表-list)
    - [字典 hash](#字典-hash)
    - [集合 set](#集合-set)
    - [有序集合 zset](#有序集合-zset)
  - [底层结构](#底层结构)
    - [整数集合 intset](#整数集合-intset)
    - [压缩列表 ziplist](#压缩列表-ziplist)
    - [哈希表 hashtable](#哈希表-hashtable)
      - [`Redis` 中 Hash 扩容过程: 渐进式 `rehash`](#redis-中-hash-扩容过程-渐进式-rehash)
    - [快速列表 quicklist](#快速列表-quicklist)
    - [★ 跳表 skiplist](#-跳表-skiplist)
      - [跳表的实现](#跳表的实现)
      - [zset 为什么不采用红黑树](#zset-为什么不采用红黑树)
      - [zset 为什么不采用哈希表](#zset-为什么不采用哈希表)
- [拾遗](#拾遗)
- [学习过程中的疑问](#学习过程中的疑问)
- [其他](#其他)

# ★ 数据结构

## 参考资料

## 基本数据结构

> 双端链表、跳表、压缩列表、字典

![主要支持的数据类型](http://upload-images.jianshu.io/upload_images/3133209-32b3f383b5b9b173.png)

```log
skiplist 跳跃表  -----> 为了查询快一点（有序、二分查找）：zset

ziplist 压缩列表 -----> 需要存储列表的都会用到：list、zset、hash

    =====> Q: 既然 zset 用到了，为什么 set 没用到这个结构？
    =====> A: 列表元素是可以重复的，zset 中可以用来存可重复的 score

hashtable 字典   -----> 需要键值对关系的都用到： hash、set

int 整数、embstr 字符串  -----> 最基础的类型，无论整数还是字符串，在 Reids 都是 string

intset 整数集合 -----> 整数集合（名字中都带了集合了），自动去重的：set

```

### 字符串 string

![alt](https://redisbook.readthedocs.io/en/latest/_images/graphviz-bb7ecaf3be8e729365b5a9241cdcb04aa5a709d1.svg)

```sql
127.0.0.1:6379[1]> set str_test 1
OK

-- Redis 数据类型
127.0.0.1:6379[1]> type str_test
string


-- 内部实现
127.0.0.1:6379[1]> object encoding str_test
"int"

127.0.0.1:6379[1]> set str_test2 "abc"
OK
127.0.0.1:6379[1]> type str_test2
string
127.0.0.1:6379[1]> object encoding str_test2
"embstr"
127.0.0.1:6379[1]>
```

- `Redis` 没有直接使用 `c` 语言的字符串，而是自己实现了一个 `sds`

- 一个键对应一个值。值不仅是字符串，也可以是数字

- 二进制安全，意思是`可以包含任何数据，比如图片或者序列化的对象`

### 列表 list

![alt](https://redisbook.readthedocs.io/en/latest/_images/graphviz-9d1b937227cf948b8a9bfb3137570475e5407d2c.svg)

```sql
127.0.0.1:6379[1]> lpush list_test huangjinjie test
(integer) 2

127.0.0.1:6379[1]> type list_test
list

-- <3.0 List 是用双向链表或压缩列表实现
-- >3.0 List 对象的底层改为由 quicklist 数据结构实现
127.0.0.1:6379[1]> object encoding list_test
"quicklist"
```

- 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等

- 实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销

### 字典 hash

![alt](https://redisbook.readthedocs.io/en/latest/_images/graphviz-145365a458984496cfecacd67b29f5d42c39a401.svg)

```sql
127.0.0.1:6379> hmset hash_test name huangjinjie age 22 location shenzhen
OK

127.0.0.1:6379> type hash_test
hash

127.0.0.1:6379> object encoding hash_test
"ziplist"
```

- `hash` 是一个 `string` 类型的字段和值的映射表，`hash` 特别适合用于存储对象

- `Redis` 中每个 `hash` 可以存储 `2^32 - 1` 键值对（40 多亿）

### 集合 set

![alt](https://redisbook.readthedocs.io/en/latest/_images/graphviz-2f54a5b62b3507f0e6d579358e426c78b0dfbd5c.svg)

```sql
127.0.0.1:6379> sadd set_test 1 2 3 4 1 2 3
(integer) 4

127.0.0.1:6379> type set_test
set

-- 整数集合
127.0.0.1:6379> object encoding set_test
"intset"

```

```sql
127.0.0.1:6379> sadd set_test2 "1" "a" "1" "b"
(integer) 3

127.0.0.1:6379> type set_test2
set

-- 哈希表
127.0.0.1:6379> object encoding set_test2
"hashtable"

```

- `set` 是 `string` 类型的无序集合。集合成员是唯一的

- 集合是`通过哈希表`实现的，所以添加，删除，查找的复杂度都是 `O(1)`

- 集合中最大的成员数为 `2^32 - 1 = 4294967295` 每个集合可存储 40 多亿个成员

### 有序集合 zset

[zset 底层是如何实现的](https://segmentfault.com/a/1190000037473381)

![alt](https://redisbook.readthedocs.io/en/latest/_images/graphviz-4d10098056ec25ed0e239f64bbcac524bce31bc8.svg)

```sql
127.0.0.1:6379[1]> zadd zset_test 100 xiaoming 90 xiaohua 78 xiaohuang
(integer) 3

-- 有序
127.0.0.1:6379[1]> zrange zset_test 0 -1
1) "xiaohuang"
2) "xiaohua"
3) "xiaoming"

127.0.0.1:6379[1]> object encoding zset_test
"ziplist"
```

- 相对集合多了个 `double` 类型的 `score` 权重参数来为成员进行排序

- 这种结构插入的时候就会按 `score` 来进行排序，即插入后就自动排序了

- 很适合用来做排行榜，或者说 top k

- 内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射。

## 底层结构

### 整数集合 intset

Redis 用于保存整数值的集合抽象数据结构，可以保存 int16_t、int32_t 或者 int64_t 的整数值，并且集合满足唯一性（集合不包含重复项）和有序性（集合中的元素按照从小到大有序排序）

![alt](https://img-blog.csdnimg.cn/d3efa3580966456d9a5c47a77fc64461.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhcHB5dHJlZTAwMQ==,size_16,color_FFFFFF,t_70)

### 压缩列表 ziplist

压缩列表是 `ZSET`、`HASH` 和 `LIST` 类型的其中一种编码的底层实现，是由一系列特殊编码的连续内存块组成的顺序型数据结构，其目的是节省内存。

![alt](https://img-blog.csdnimg.cn/20201229234628972.png)

### 哈希表 hashtable

#### `Redis` 中 Hash 扩容过程: 渐进式 `rehash`

[`Redis` 中 Hash 扩容过程](https://blog.csdn.net/weixin_38004638/article/details/118206845)

Redis 中又两个哈希数组 `ht[0] 和 ht[1]`

在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部 rehash 到 `ht[1]` 的话，可能会导致服务器在一段时间内停止服务。所以，`采用渐进式 rehash 的方式`

**渐进式 rehash 采用的是一种分而治之的方式，将 rehash 的操作分摊在每一个的访问中，避免集中式 rehash 而带来的庞大计算量**

![alt](https://img-blog.csdnimg.cn/img_convert/a1fc1ed67ef9102801c959d74f4fb866.png)

- Redis 字典（hash 表）底层有两个数组，还有一个 rehashidx 用来控制 rehash；初始时为 ht[1] 分配空间，`让字典同时持有 ht[0] 和 ht[1] 两个哈希表`

- 默认 hash 长度为 4，当元素个数与 hash 表长度一致时，就`发生扩容，hash 长度变为原来的二倍`

- 将 rehashindex 的值设置为 0，表示 rehash 工作正式开始

- **在 rehash 期间，每次对字典【执行增删改查操作时】，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashindex 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成以后，rehashindex 的值 + 1**

- 随着字典操作的不断执行，最终 ht[0] 的所有键值对都会被 rehash 到 ht[1]，这时将 rehashindex 的值设置为 -1，表示 rehash 操作结束

### 快速列表 quicklist

在 Redis3.0 以前，List 对象的底层数据结构是双向链表或者压缩链表;
在 3.2 的时候，List 对象的底层改为由 quicklist 数据结构实现。

quickList 链表就是双向链表 + 压缩链表组合，quicklist 本身是个链表，链表中的元素是压缩列表。

快速列表 quicklist 可以看成是用双向链表将若干小型的 ziplist 连接到一起组成的一种数据结构。

![alt](https://img-blog.csdnimg.cn/f00f2d9810dc41a6b1cb5870a7023832.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb5a2m5Lmg55qE54uX,size_20,color_FFFFFF,t_70,g_se,x_16)

### ★ 跳表 skiplist

跳表的时间复杂度是 `O(logn)`，空间复杂度是 `O(n)`

单链表查询的时候要从头遍历尾，不如数组直接下表寻址；跳跃表就是通过添加辅助链表的方式用来解决这个问题的

[跳跃表](https://blog.csdn.net/weixin_41622183/article/details/91126155)

```sql
127.0.0.1:6379> zadd scoretest 100 xiaohuang 90 xiaohao
(integer) 2
127.0.0.1:6379> zrange scoretest 0 -1
1) "xiaohao"
2) "xiaohuang"

-- 可以看到内部是用 ziplist 实现的
127.0.0.1:6379> object encoding scoretest
"ziplist"
```

#### 跳表的实现

![alt](https://cdn.learnku.com/uploads/images/202103/03/50944/Fe5n3yKtZ4.gif!large)

![alt](https://segmentfault.com/img/bVcHoFu)

> 感觉就像二分查找一样分区的思想

**对链表建立索引来进行辅助查询**

- 查找的时候从第顶层辅助链表开始，找到所在区间的其实节点，找打图中的 `[7, ∞)` 区间

- 然后往往下一层辅助链表查，找到 `23` 落于图中的 `[7, 37]` 区间

- 继续往下一层查询，找到 `[19, 37]` 区间

- 继续上诉操作，最终在原始链表找到了 `23` 应该插入的位置

**辅助链表怎么建立？要建多少个这样的辅助链表呢**

（`随机`）

**这不是个 `二分查找吗`**

- 按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个`二分查找`，使得查找的时间复杂度可以降低到 `O(log n)`

- 但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就`会打乱上下相邻两层链表上节点个数严格的2:1的对应关系`。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成 O(n)。删除数据也有同样的问题。

- 跳表 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是`为每个节点随机出一个层数(level)`

**跳表优缺点**

- 相比单向链表，查找的时间复杂度从 `O(n)` 降为 `O(logN)`

- 相比数组，删除插入的时间复杂度从 `O(n)` 降为 `O(logN)`，且无需扩容 / 缩容操作。

- 另外，可存储重复键值的跳表该如何实现呢？每个节点变为链表以解决冲突

#### zset 为什么不采用红黑树

[Redis 为什么采用跳表而不是红黑树](https://blog.csdn.net/gamekit/article/details/104734734)

- 相比平衡树 / 红黑树，跳跃表的操作的效率差不多，但是`跳表不稳定`。而且跳表的`空间开销相比于后者有所增加`
- 在做`范围查找`的时候，平衡树比 跳表 操作要复杂

  - 平衡树需要以中序遍历的顺序继续寻找其它不超过大值的节点。

  - 跳表进行范围查找非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现

- 相比于红黑树、平衡二叉树，跳表不仅查找、插入、删除`时间复杂度都是 O(logN)`，并且`实现简单`很多

  - 平衡树的插入和删除操作 `可能引发子树的调整`，逻辑复杂

  - 跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速

- 跳表需要 `更少的指针内存`。平均每个节点包含 1.33 个指针，比平衡树更有优势。

#### zset 为什么不采用哈希表

`zset` 要求有序性，而哈希表不是有序的。因此，在哈希表上只能做单个 `key` 的查找，不适宜做范围查找

# 拾遗

# 学习过程中的疑问

- **如果 rehash 到 99% 就不再访问这个 key（也就是说不会再发生 rehash）此时岂不是相当于保存了两份数据？如果这个 hash 表很大（比如上万键值）那岂不是要执行上万次才能完全 rehash 过去？**

  记住，这个叫做渐进式 rehash。rehash 过程是不断在进行的，而不是等你有了一万个键才开始 rehash

- **我可能初始化的时候就设置了一万个键呢？**

- **一次迁移多少数据？什么时候废弃原来那份？**

  肯定不会访问一次才搬迁一个 key

- **之前遇到过说 c++ 哈希冲突怎么处理，怎么扩容的问题**

# 其他
