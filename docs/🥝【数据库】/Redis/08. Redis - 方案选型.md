- [方案选型](#方案选型)
  - [Redis 为什么是 key-value 的，为什么不是支持 SQL 的](#redis-为什么是-key-value-的为什么不是支持-sql-的)
  - [有了 Redis 还需要 MySQL 么](#有了-redis-还需要-mysql-么)
  - [`Memcache` 和 `Redis` 的区别](#memcache-和-redis-的区别)
  - [★ `Redis` 为什么那么快](#-redis-为什么那么快)
  - [`Redis` 是单线程还是多线程](#redis-是单线程还是多线程)
  - [为什么 `Redis 6.0` 之后改用多线程了](#为什么-redis-60-之后改用多线程了)
    - [原来版本为什么不采用多线程](#原来版本为什么不采用多线程)
    - [新版本为什么采用多线程](#新版本为什么采用多线程)
    - [新版本还是线程安全吗](#新版本还是线程安全吗)
- [原理](#原理)
  - [Reactor 模型](#reactor-模型)
- [方案设计](#方案设计)
  - [点赞功能用 MySQL 还是 Redis](#点赞功能用-mysql-还是-redis)
  - [排行榜功能](#排行榜功能)
  - [消息队列](#消息队列)
  - [延时任务](#延时任务)
  - [分布式唯一 ID](#分布式唯一-id)
  - [分布式锁](#分布式锁)
- [其他](#其他)
  - [用缓存来做分页](#用缓存来做分页)
  - [10 万用户一年 365 天的登录情况如何用 Redis 存储，并快速检索任意时间窗内的活跃用户](#10-万用户一年-365-天的登录情况如何用-redis-存储并快速检索任意时间窗内的活跃用户)
  - [100 万并发 4G 数据，10 万并发 400G 数据，如何设计 Redis 存储方式](#100-万并发-4g-数据10-万并发-400g-数据如何设计-redis-存储方式)

# 方案选型

## Redis 为什么是 key-value 的，为什么不是支持 SQL 的

- 因为 Redis 是基于内存的数据库（注意 nosql 并不能理解为不是 sql，而应该是 not only sql）其`应用场景是【快速读写】`，那么对于`复杂查询等操作显然不是Redis考虑的重点`，选择键值对可以满足快速读写功能，而 sql 也可以实现复杂的查询

## 有了 Redis 还需要 MySQL 么

[为什么 Redis 不能代替 MySQL 进行数据存储](https://blog.csdn.net/chesi3740/article/details/100595187)

> - 在使用中都是 Redis+MySQL。**Redis 管数据缓存到内存，用于提高查询效率，MySQL 管数据存储到磁盘，用于保存重要不能丢失的数据**

- Redis 既能基于内存，也能持久化到磁盘，但是 `主打内存效率` 的 Redis，`持久化功能远远比不上MySQL。而大量数据都放入内存，需要很高的硬件支持`，不太现实

- `Mysql 有完善的事务机制`，能满足项目需求，Redis 虽然也有事务，但是很多场景无法满足

- Redis 虽然有 5 种数据结构，但是过于 `复杂的数据关系还是无法清晰表现`，MySQL 通过行和列、表与表的关系，让数据与数据直接之间的关系一目了然。

## `Memcache` 和 `Redis` 的区别

|      | `Memcache`                                           | `Redis`                                                                              |
| :--- | :--------------------------------------------------- | :----------------------------------------------------------------------------------- |
| 优点 | `多线程`，非阻塞 IO 复用的网络模型，可以更好利用多核 | 支持数据 `持久化`                                                                    |
|      | 使用预分配内存池的方式，`减少内存碎片产生`           | 不仅支持简单的 `k/v` 类型的数据，同时还提供 `list，set，zset，hash` 等数据结构的存储 |
|      |                                                      | 不仅可以作为 nosql 数据库，还`可以用作消息队列、数据堆栈、数据缓存`等                |
|      |                                                      | `支持数据备份，有主从模式`                                                           |
| 缺点 | 不支持数据持久化                                     | 存储 `100k` 以上的数据时，性能稍差                                                   |
|      | 只支持简单的 `k/v` 类型数据                          | 使用单线程的 I/O 复用模型，无法充分发挥多核优势                                      |

## ★ `Redis` 为什么那么快

> - `1. 纯内存操作 - 减少磁盘IO`
> - `2. 单线程操作 - 避免频繁的上下文切换`
> - `3. 灵活多样的数据结构`
> - `4. 非阻塞I/O多路复用机制 epoll；单线程可以处理多个连接请求，减少网络IO时间消耗`

- `纯内存操作 - 减少磁盘IO`

  避免大量访问数据库，减少直接读取磁盘数据，Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快；

- `单线程操作 - 避免频繁的上下文切换`

  - 避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

  - 但 Redis6.0 采用多线程；因为 Redis 在处理网络数据时，调用 epoll 的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，达到几万的 QPS，此处可能会成为瓶颈。一般我们遇到此类网络 IO 瓶颈的问题，可以增加线程数来解决。开启多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。

  - Redis6.0 也不例外，在此处增加了多线程来处理网络数据，以此来提高 Redis 的吞吐量。当然相关的命令处理还是单线程运行，不存在多线程下并发访问带来的种种问题。

- `采用了 I/O 多路复用机制`

  Reactor 模型

  - 用户首先将需要进行 IO 操作的 socket 添加到 select 中，然后阻塞等待 select 系统调用返回。当数据到达时，socket 被激活，select 函数返回。用户线程正式发起 read 请求，读取数据并继续执行。这样用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，Redis 服务端将这些 socke 置于队列中，然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中，提高读取效率。

  - 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），多路 I/O 复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作，从而提高效率。

- `灵活多样的数据结构`

  Redis 内部使用一个 RedisObject 对象来表示所有的 key 和 value。RedisObject 主要的信息包括数据类型、编码方式、数据指针、虚拟内存等。它包含 String，Hash，List，Set，Sorted Set 五种数据类型，针对不同的场景使用对应的数据类型，减少内存使用的同时，节省网络流量传输。

- `总结`

  - 试想单线程是否就无法发挥多核 CPU 性能，其实不然，我们可以通过在单机开多个 Redis 实例来完善。单一线程只能用到一个 CPU 核心，所以可以在同一个多核的服务器中，启动多个实例，组成 master-master 或者 master-slave 的形式，耗时的读命令可以完全在 slave 进行，充分发挥 Redis 的作用。

  - 单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块也会用到多个线程，使用 Redis 的过程中充分发挥其优势，避免一些不当操作，导致性能下降。

## `Redis` 是单线程还是多线程

`Redis` 是单进程多线程的

```sh
$pstree -p | grep Redis-server
  |-Redis-server(189)-+-{Redis-server}(191)
  |                   |-{Redis-server}(192)
  |                   |-{Redis-server}(193)
```

- `Redis` 中除了执行任务外，还有其他工作，怎么可能单线程呢；`Redis` 中 `io` 多路复用模块是单线程，事件处理器也是单线程.

- 执行命令的是单线程，执行命令外还有：接收 IO 请求、持久化、过期等等.

## 为什么 `Redis 6.0` 之后改用多线程了

- [Redis6.0 为何引入多线程](https://mp.weixin.qq.com/s/D_j6HTYKd4DabYz-Ei6cAg)

- [Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？](https://mp.weixin.qq.com/s/Tp91BH-EorJ_16mxbXCeUg)

使用多线程并非是完全摒弃单线程，`Redis` 还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，`执行命令还是使用单线程`

### 原来版本为什么不采用多线程

多线程的目的，就是通过并发的方式来提升 I/O 的利用率和 CPU 的利用率

- Redis 的操作基本都是基于内存的，CPU 资源根本就不是 Redis 的性能瓶颈，所以，通过多线程技术来提升 Redis 的 CPU 利用率这一点是完全没必要的。

- Redis 确实是一个 I/O 操作密集的框架，他的数据操作过程中，会有大量的网络 I/O 和磁盘 I/O 的发生。要想提升 Redis 的性能，是一定要提升 Redis 的 I/O 利用率的。但是 Redis `为了避免引入多线程带来的相互切换性能开销问题，没有采用多线程计数，而是选择了【多路复用】`

### 新版本为什么采用多线程

> IO 多路复用也是阻塞的；用上多线程可以发挥多核优势，加速处理网络请求

`Redis` 性能瓶颈在于 **`网络IO 和 磁盘IO`** 而非 CPU，`【使用多线程能提升 IO 的效率】`，从而整体提高 Redis 的性能

- 在`多路复用的 IO 模型中，在处理网络请求时是阻塞的`，如果并发量很高，此处可能会成为瓶颈

- 有大量的 CPU 时间片是耗费在了网络 IO 的同步处理上的，并没有充分的发挥出多核的优势

- 采用多线程，`使得网络处理的请求并发进行，就可以大大的提升性能`。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势

### 新版本还是线程安全吗

是的，io 多线程只是 Redis 为了处理 io 时提升性能，他的请求命令还是单线程的，这里不会影响 Redis 的线程安全性

# 原理

## Reactor 模型

![alt](https://img-blog.csdnimg.cn/20201229005746243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5Nzc3MA==,size_16,color_FFFFFF,t_70)

- 由多个 socket 接收来自客户端的各种请求，例如：建立通道，返回 data，发送 redis 指令等。

- socket 由 I/O 多路复用程序进行监听，redis 中的 I/O 多路复用机制采用的是非阻塞的 epoll 模型。

- 将执行命令顺序压入队列，由文件事件分派器将分派给相应的处理器处理完毕后返回结果（或数据）。

**重点强调：**

- redis 内部实现的文件事件处理器为单线程的，这也是为什么 redis 经常被称为但单线程的原因，但实际上并不是整个 redis 实例都只有一个线程，例如从 4.0 开始就有的多线程在后台删除对象，以及从 6.0 开始的多线程网络 I/O。具体可看：https://www.cnblogs.com/javastack/p/12848446.html

- 整个 redis 线程模型基于 Reactor 模型，命令经 I/O 多路复用程序被存入队列中后，文件事件分派器单线程处理命令，所以客户端命令不一定是顺序的，但不会有两条命令被同时执行，也就不会有并发问题（天然解决了开头说的重复消费的问题，当然要在代码里加一些判断，避免取回空值）

# 方案设计

## 点赞功能用 MySQL 还是 Redis

TODO

## 排行榜功能

> 用到了跳表

TODO

## 消息队列

TODO

## 延时任务

[用定时任务实现关闭订单的问题](https://www.cnblogs.com/Finley/p/16395466.html)

## 分布式唯一 ID

```sql
-- 设置序列起始值
SET test "10000"

-- 获取一个序列值，直接将返回值作为序列使用即可
INCR test

-- 获取一批（如100个）序列值
INCRBY test 100

-- 假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。
```

## 分布式锁

```sql
-- set if not exist
-- SETNX [key] [value]

SETNX test test_value  -- 返回 1 表示设置成功（获得锁）

SETNX test test_value_new  -- 返回 0 ，修改值失败（锁抢占）

DEL test  -- 释放锁
```

- 当 key 不存在时，将 key 的值设为 value ，返回 1。若给定的 key 已经存在，则 setnx 不做任何动作，返回 0。

- 当 setnx 返回 1 时，表示获取锁，做完操作以后 del key，表示释放锁，如果 setnx 返回 0 表示获取锁失败，整体思路大概就是这样

# 其他

## 用缓存来做分页

[基于 Redis 做缓存分页](https://www.jianshu.com/p/9c89c579b7ef)

## 10 万用户一年 365 天的登录情况如何用 Redis 存储，并快速检索任意时间窗内的活跃用户

> `bigmap`

[Redis 登录 10 万用户一年 365 天的登录情况如何用 Redis 存储，并快速检索任意时间窗内的活跃用户](https://blog.csdn.net/weixin_39876650/article/details/111296082)

## 100 万并发 4G 数据，10 万并发 400G 数据，如何设计 Redis 存储方式

TODO
