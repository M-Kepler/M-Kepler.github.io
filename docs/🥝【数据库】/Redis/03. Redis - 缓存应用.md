- [参考资料](#参考资料)
- [缓存应用](#缓存应用)
  - [缓存系统设计需要考虑什么](#缓存系统设计需要考虑什么)
  - [说一说缓存穿透](#说一说缓存穿透)
  - [说一说缓存雪崩](#说一说缓存雪崩)
  - [说一说缓存击穿](#说一说缓存击穿)
- [★ 缓存和数据库一致性问题](#-缓存和数据库一致性问题)
  - [为什么会有数据一致性问题](#为什么会有数据一致性问题)
  - [方案一：采用缓存超时 + 双删策略](#方案一采用缓存超时--双删策略)
  - [方案二：消息队列进行删除的补偿](#方案二消息队列进行删除的补偿)
  - [方案三：`binlog` 订阅删除缓存](#方案三binlog-订阅删除缓存)
- [热 key 是什么，有什么危害，如何发现，如何解决](#热-key-是什么有什么危害如何发现如何解决)
- [★ 过期策略](#-过期策略)
  - [如何实现缓存过期的，原理是什么](#如何实现缓存过期的原理是什么)
    - [定时删除](#定时删除)
    - [惰性删除](#惰性删除)
    - [定期删除](#定期删除)
    - [`定期删除` 和 `惰性删除` 就没问题了吗](#定期删除-和-惰性删除-就没问题了吗)
- [★ 内存淘汰策略](#-内存淘汰策略)
  - [内存淘汰策略和过期策略的区别](#内存淘汰策略和过期策略的区别)
  - [内存不足怎么办，如何保证 `Redis` 中的都是热点数据，有哪几种数据淘汰策略](#内存不足怎么办如何保证-redis-中的都是热点数据有哪几种数据淘汰策略)
  - [缓存淘汰算法](#缓存淘汰算法)

# 参考资料

# 缓存应用

## 缓存系统设计需要考虑什么

- 缓存一致性问题

- 有预防缓存穿透、雪崩、击穿的措施

- 高可用的问题，单机部署？集群部署？分布式部署

## 说一说缓存穿透

> 穿透、透过缓存；缓存系统形同虚设，请求直达数据库

**现象**

当业务系统需要`查询数据库不存在的数据时，每一次请求最终都要访问一次数据库`，即业务访问根本不存在的数据。

**危害**

大量这种根本查询不到数据的请求会对数据库造成冲击，拖慢数据库性能，甚至导致数据库崩溃

**解决方案**

- `BloomFilter(布隆过滤器)`

  - 在访问缓存之前先访问布隆过滤器，检查需要查询的数据是否存在，布隆过滤器存储目前数据库中存在的所有 key。

  - 不存在，则说明数据库中也不存在该数据，因此缓存都不要查了，直接返回 `null`

  - 存在，则继续执行后续的流程，先前往缓存中查询，缓存中没有的话再前往数据库中的查询

  > 显然，布隆过滤器需要考虑 `数据同步更新到布隆过滤器` 的问题 ，如果数据同步失败了，还需要增加重试机制，而且跨数据源，不能保证数据的实时一致性

- `把空数据也缓存起来`

  将空数据 `null` 也做成一个缓存结果，这样在下次有相同请求到来时，缓存可以拦截该请求，返回缓存中的结果。

## 说一说缓存雪崩

> 雪崩，突然之间崩塌（比如 `集中过期`）；缓存突然没了，压力全落到数据库上了

**现象**

如果缓存在某个时刻挂了，那么大量的请求也将会直接访问数据库，造成很大压力

**危害**

如果缓存因某种原因宕机，那原本被缓存抵挡的海量查询请求就会像疯狗一样涌向数据库。此时数据库如果抵挡不了这巨大的压力，它就会崩溃

**解决方案**

- 使用 `缓存集群`，增大可用性，当一个缓存挂了还有其他的缓存跟上

- 使用 `Hystrix`，它是一款开源的“防雪崩工具”，它通过 `熔断`、降级、`限流` 三个手段来降低雪崩发生后的损失

## 说一说缓存击穿

> 击穿：保护伞上穿孔了；保护伞上有了个洞，虽然缓存没崩，但某个点被打穿了；请求也是接达数据库，可能会把数据库干趴

**现象**

指一个 `key 非常热点`，在不停的扛着大并发，`当这个 key 【过期失效的瞬间】，且 key 值还没更新，持续的大并发就穿破缓存，直接请求数据库`，就像在一个屏障上凿开了一个洞。

**危害**

对于一些请求量极高的热点数据而言，一旦过了有效时间，此刻将会有大量请求落在数据库上，从而可能会导致数据库崩溃

**解决方案**

- 使用`互斥锁`

  上锁的对象为 key，当`失效后的第一个查询请求到来时，就会对缓存上锁`，这时只有一个查询请求察合不到缓存，转而去访问数据库，而其他的查询请求就会被挡在外面，直到缓存中更新了这个结果之后，剩余的查询请求才可查询缓存。

- `设置不同的失效时间`

  对于很多热点数据集中失效，可以`设置不同的失效时间`，这样可以错开一部分热点数据的更新时间，避免缓存集中过期

- `数据预热`

  最好在项目启动之前，先把缓存进行 `预热`。即事先把所有的数据同步到缓存中，这样基本都能直接从缓存中获取到，就不会出现缓存击穿的问题了

# ★ 缓存和数据库一致性问题

- [★ 如何保证缓存与数据库双写时的数据一致性](https://mp.weixin.qq.com/s/5kTaqG-OyT-tV9JlVKm2-w)

- [掘地三尺搞定 Redis 与 MySQL 数据一致性问题](https://mp.weixin.qq.com/s/v96g-rscaOHpcURx6kXsEA)

- [缓存（本地缓存、分布式缓存）与数据库之间的数据一致性问题](https://www.pianshen.com/article/4037822761/)

- [缓存和数据库一致性问题，看这篇就够了](https://mp.weixin.qq.com/s/WK1f-BwwCwKwieacFoPbtQ)

## 为什么会有数据一致性问题

**`问题提出`**

- 更新数据库和更新缓存，**不在一个事务里面**；

  数据库的操作和缓存的操作不可能在一个事务中，也就势必会出现数据库写入失败，缓存不能更新，缓存写入失败等数据不一致问题；

- 更新数据库和更新缓存，**存在时间差**，时间差内如果有请求来，就会造成数据不一致。

  不管是先写数据库，再删除 Redis 缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况

**`问题分析`**

最常用简单的一种场景，查询缓存，缓存没有就去查询数据库，然后更新到缓存

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLaE1Nmo04b62OFZqmd1C2ZaXzTiaxOLu9OOISaQaN0UI62iaDkHBoqFoiacBEqs498Z4DMHpgyaibwSlw/640?wx_fmt=jpeg)

- 如果删除了缓存，但还没有来得及写数据库；

- 另一个线程来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中保存的就变成脏数据了。

- 如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

## 方案一：采用缓存超时 + 双删策略

![alt](https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qbxeibHeuL5xCVlOZOTeBmsUhMhXBoiatyjPmjx1L35eJleThA2PQIibVpIibaRPc4RwTIficE202KvHPg/640?wx_fmt=png)

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLaE1Nmo04b62OFZqmd1C2ZaQHib6H2j6RibcYZlmibXib2P5hwFicbPtOaibpjDf1swTfxAqCsM1aX4Xyiaw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

- 先清掉缓存，然后写数据库

- 休眠 `500ms`

  考虑到 Redis 和 MySQL 各自的`主从同步会有延时`，最差的情况也就是`在这个超时时间内来个请求取到了旧数据`

  主从同步时延也可以采用 `二次查询 + 重试` 来解决；一次查不到就稍等一下再查一次，从库查不到就去主库查询。

- 再清一次缓存（避免期间请求过来发现缓存没有数据然后去数据库取了旧数据更新到缓存）

- **延时双删为什么要删第二次？**

  因为，MySQL 是主从架构，主库写从库读。当数据写入主库后，【在数据来同步到从库期间】有请求过来，Redis 没有数据（因为第一次删除了）就会读取从库旧的数据更新到缓存中。所以要等主从同步完成后，再删除一次数据

- **缺点**

  - 事务提交完以后再进行删除缓存还有一个问题，就是如果你使用的是 MySQL 的读写分离的架构的话，那么其实**主从同步之间也会有时间差**。

  - 比如更新数据库成功了，但是在`【删除缓存的阶段出错了没有删除成功】`，那么此时再读取缓存的时候每次都是错误的数据了。

## 方案二：消息队列进行删除的补偿

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLaE1Nmo04b62OFZqmd1C2ZaLEkHwdhE8VeDoWvMTfgiaFQLicADK49ln2ed68bicEtKgdQA3SAOATMoQ/640?wx_fmt=jpeg)

- 请求 A 先对数据库进行更新操作；

- 再对 Redis 进行行删除操作，**如果删除失败**；

- 此时将 Redis 的 key 作为消息体发送到消息队列中；

- 删除缓存的消息加入到队列中；

- 系统接收到消息队列发送的消息后再次对 Redis 进行删除操作。

## 方案三：`binlog` 订阅删除缓存

和 MySQL 主从同不一样，只不过把从服务器换成了 Redis 服务器

![alt](https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhpDtMA1eOSqaoJBw06qbJ6ibOuqD0mdk9NJ5fyibY9ess2mkDpo8P77zGspLZhtfgBMCgRMwRNuLvnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLaE1Nmo04b62OFZqmd1C2ZarVzJ4qrjGfk4XBZUjJMiaKAJagbVZgEJ2VkJWpfic3SyZBVoklnicK0XA/640?wx_fmt=jpeg)

- 数据更新到数据库

- Redis 服务器拉取 MySQL 的 binlog

- 解析数据写入到 Redis 中，达到同步的效果

# 热 key 是什么，有什么危害，如何发现，如何解决

[谈谈 Redis 的热 key 问题如何解决](https://zhuanlan.zhihu.com/p/65959998)

**什么是热 key 问题**

就是瞬间有几十万的请求去访问某个固定的 `key`，从而压垮缓存服务的情情况

**如何发现**

- 凭经验, 有些比较明显的特点，比如秒杀活动等，可以预估那些是热 key

- 在请求发起端加一下统计日志

- 请求先经过代理，在代理层做统计

**如何解决**

- `利用二级缓存`

  发现热 key 时（比如定时检测某时间段内的 Redis 访问情况，把超过阈值的 key 拎出来），把 key 装到缓存里，请求过来时如果发现 key 在缓存里，则直接返回

- 备份热 key

- 监控热 key，发现后通知系统处理

# ★ 过期策略

- [过期删除策略和内存淘汰策略](https://www.cnblogs.com/ysocean/p/12422635.html)

- [彻底弄懂 Redis 的内存淘汰策略](https://zhuanlan.zhihu.com/p/105587132)

## 如何实现缓存过期的，原理是什么

### 定时删除

- 为 key 设置一个`过期时间`的同时，创建一个定时器，定时器到了就删除

- 如果过期 key 比较多的时候，就要有很多个定时器，很消耗 `CPU`

- 这个主动过期 key 的定时任务，是在 Redis 主线程中执行的。也就是说如果在执行主动过期的过程中，出现了需要大量删除过期 key 的情况，那么此时应用程序在访问 Redis 时，必须要等待这个过期任务执行结束，Redis 才可以服务这个客户端请求。

**优点：**

定时删除对内存是最友好的，能够保存内存的 key 一旦过期就能立即从内存中删除。

**缺点：**

对 CPU 最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。

### 惰性删除

- 访问这个 `key` 时才对 `key` 进行检测，如果达到了过期时间则删除；

- 缺点也很明显了，有些 `key` 一直不访问，就会一直存在，一直占用资源；极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。

**优点：**

对 CPU 友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的 key 不用浪费时间进行过期检查。

**缺点：**

对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。

### 定期删除

每`隔一段时间对数据库做一次检测`，删除里面的过期 `key`；由于不可能对所有的 `key` 做轮询来删除，所以 `Redis` 会每次 `【随机】取一些来做检查和删除`；很明显这种方法会占用大量的 `CPU` 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量

**优点：**

可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。

**缺点：**

- 难以确定删除操作执行的时长和频率。

- 如果执行的太频繁，定期删除策略变得和定时删除策略一样，对 CPU 不友好。

- 如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。

- 另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。

**配置**

定期删除函数的运行频率，在 Redis2.6 版本中，规定每秒运行 10 次，大概 100ms 运行一次。在 Redis2.8 版本后，可以通过修改配置文件 redis.conf 的 `hz` 选项来调整这个次数。

### `定期删除` 和 `惰性删除` 就没问题了吗

不是的，如果定期删除（随机删一些）没删掉。然后你也没即时去请求 key，也就是说惰性删除也没生效。这样，Redis 的内存会越来越高。那么就应该采用内存淘汰机制。

# ★ 内存淘汰策略

当现有内存大于 maxmemory 时，便会触发 Redis 主动淘汰内存方式，通过 `maxmemory-policy [xxx]` 设置淘汰方式，有如下几种：

## 内存淘汰策略和过期策略的区别

[过期策略和内存淘汰策略不要搞混淆](https://cloud.tencent.com/developer/article/1643921)

通过过期删除策略，对于某些永远使用不到的键，并且多次定期删除也没选定到并删除，那么这些键同样会一直驻留在内存中，又或者在 Redis 中存入了大量的键，这些操作可能会导致 Redis 内存不够用，这时候就需要 Redis 的内存淘汰策略了。

**内存淘汰策略的选取并不会影响过期的 `key` 的处理**

- 内存淘汰策略用户 **`内存不足时`** 的需要申请额外空间的数据

- 过期策略用于处理过期的缓存数据

**过期键删除策略和内存淘汰机制之间的关系**

- 过期删除策略强调的是对过期键的操作，如果有键过期了，而内存还足够，不会使用内存淘汰机制，这时也会使用过期键删除策略删除过期键。

- 内存淘汰机制强调的是对内存的操作，如果内存不够了，即使有的键没有过期，也要删除一部分，同时也针对没有设置过期时间的键。

## 内存不足怎么办，如何保证 `Redis` 中的都是热点数据，有哪几种数据淘汰策略

> `volatile` 易变的; 不稳定的; `eviction` 驱逐; 驱赶;

| 淘汰策略 `allkeys、volatile; lru、random` | 说明                                                                       |
| :---------------------------------------- | :------------------------------------------------------------------------- |
| `no-eviction`                             | 内存不足，写入操作会报错                                                   |
|                                           |                                                                            |
| `allkeys-lru`                             | 在所有键中，移除`最近最少使用`的 key                                       |
| `allkeys-random`                          | 在所有键中，`随机移除`某个 key                                             |
| `allkeys-lfu`                             | 从所有键中驱逐使用频率最少的键 (Redis4.0 后新增)                           |
|                                           |                                                                            |
| `volatile-lru`                            | 在设置了过期时间的键空间中，`移除最近最少`使用的 key                       |
| `volatile-random`                         | 在设置了过期时间的键空间中，`随机移除`某个 key                             |
| `volatile-ttl`                            | 在设置了过期时间的键空间中，有`更早过期时间的 key` 优先移除                |
| `volatile-lfu`                            | 在设置了过期时间的键空间中，优先淘汰 `使用频率最少`的键 (Redis 4.0 后新增) |

## 缓存淘汰算法

[[缓存淘汰算法]]
