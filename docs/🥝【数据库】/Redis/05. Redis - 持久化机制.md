- [参考资料](#参考资料)
- [持久化](#持久化)
  - [持久化的作用](#持久化的作用)
  - [`RDB`](#rdb)
    - [触发机制](#触发机制)
    - [`save` 和 `bgsave` 命令的区别](#save-和-bgsave-命令的区别)
    - [RDB 优缺点](#rdb-优缺点)
    - [生成 RDB 期间，Redis 可以同时处理写请求么](#生成-rdb-期间redis-可以同时处理写请求么)
    - [生成 RDB 期间，产生的数据怎么处理](#生成-rdb-期间产生的数据怎么处理)
  - [`AOF`](#aof)
    - [触发机制](#触发机制-1)
    - [AOF 优缺点](#aof-优缺点)
    - [AOF 重写](#aof-重写)
  - [两种持久化方案对比](#两种持久化方案对比)
    - [二者都开启的情况下，加载顺序是怎么样的](#二者都开启的情况下加载顺序是怎么样的)
    - [恢复时 RDB 和 AOF 哪个更快](#恢复时-rdb-和-aof-哪个更快)
    - [在生成 RDB 过程中，AOF 如果停止同步，会不会丢失](#在生成-rdb-过程中aof-如果停止同步会不会丢失)
    - [混合持久化模式](#混合持久化模式)
  - [Redis 既然有持久化为什么还要写进 MySQL](#redis-既然有持久化为什么还要写进-mysql)
- [拾遗](#拾遗)
- [其他](#其他)
  - [看下 rdb aof 文件到底保存啥](#看下-rdb-aof-文件到底保存啥)

# 参考资料

- [Redis 持久化 RDB 和 AOF](https://www.cnblogs.com/haoprogrammer/p/11068396.html)

- [RDB 和 AOF 持久化的原理是什么？我应该用哪一个？它们的优缺点？](https://segmentfault.com/a/1190000018388385)

# 持久化

![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F163758%2F201901%2F163758-20190129173744336-1790859427.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619020303&t=3c4f364f774c8db478549d094c4d28d5)

## 持久化的作用

Redis 是一个基于内存的数据库，因此数据容易丢失，为了解决数据丢失的问题，于是 `Redis` 就设计了持久化，能快速恢复过来，继续提供缓存服务

- 大量的请求过来，`Redis 挂了，导致缓存全部无法命中`，在 `Redis` 里根本找不到数据，这个时候就 `出现缓存雪崩问题`。所有请求没有在 Redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 `mysql` 承接高并发，然后就挂了

## `RDB`

`Redis Database` **默认的持久化机制**， 以快照的形式 `将一段时间内的数据持久化到硬盘`，保存成一个 `dumpr.RDB` 二进制文件

`fork()` 出一个子进程执行命令；把数据 dump 成一个 RDB 二进制文件，保存在 `$REDIS_ROOT/data/dump.rdb`

### 触发机制

**save 命令**

同步阻塞方式，需要等 Redis 执行完 save 后，才能执行其他 get、set 等操作。

**bgsave 命令**

异步非阻塞，其原理是调用 Linux 的 `fork()` 函数，子进程进行创建 RDB 文件的操作。

**自动方式**

> 其实就相当于【定时备份】

```ini
# Save the DB on disk:
#
#   save <seconds> <changes>
#   save <指定时间间隔> <执行指定次数更新操作>
#   save ""

# 表示 60 秒内有 10000 次操作会自动生成 RDB 文件
save 60 10000

save 900 1
save 300 10

```

**其他方式**

- 执行 `flushall` 命令，清空数据，几乎不用

- 执行 `shutdown` 命令，安全关闭 redis 不丢失数据，几乎用不到

- 主从复制，在主从复制的时候，RDB 文件作为媒介来关联主节点和从节点的数据一致。

### `save` 和 `bgsave` 命令的区别

> `bgsave` 采用了 `COW 写时复制`

![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2F07imgmini.eastday.com%2Fmobile%2F20190415%2F20190415233716_c39097d44b918423415cd8476dafa2db_2.jpeg&refer=http%3A%2F%2F07imgmini.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619020663&t=209d6d9f36f51e441bc7f1efb16c6055)

执行 `bgsave` 或者 `bgrewriteaof` 命令时，都会 fork 出一个子进程来读取数据，写到磁盘

**优点**

- 相比 `SAVE` 命令，可以异步复制，继续提高服务

**缺点**

- 如果`子进程存在期间，如果发生了大量的写操作`，那可能就会出现很多的缺页异常，这样就得`【耗费不少性能在复制】`上

- 在 fork 出子进程之后，会将触发 rehash 的负载因子阈值提高，尽量减少写操作

### RDB 优缺点

**`优点`**

- 适合大规模的数据恢复

- 恢复速度相对较快

**`缺点`**

- 【数据的完整性和一致性不高】，因为 RDB 可能在最后一次备份时宕机了。

  `RDB` 一次写入的数据较多，因为 RDB 文件需要保存整个数据集的状态，所以`它并不是一个轻松的操作`。因此你可能会至少 5 分钟才保存一次 RDB 文件（save 900 1 配置）， **一旦发生故障停机， 就可能会丢失好几分钟的数据**。 时间间隔会比 AOF 长，出现宕机丢失的数据会更多

- 【耗时耗性能】

  备份时占用内存，因为 Redis 在备份时 `会独立创建一个子进程`，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

  所以 Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

### 生成 RDB 期间，Redis 可以同时处理写请求么

> 可以的，cow 写时复制技术保证快照期间数据可修改

![alt](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74WvjurUia5RTLu7qzCHvc8Dch9qdz4iaNGMNoBIQKDZoVn0ibA0E9DdekunIGA/640?wx_fmt=png)

- `Redis` 使用操作系统的多进程 **写时复制技术 COW(Copy On Write)** 来实现快照持久化，保证数据一致性

- `Redis` 在持久化时会调用 `glibc` 的函数 `fork` 产生一个子进程，快照持久化完全交给该子进程处理，父进程继续处理客户端请求

- 当主线程执行写指令修改数据的时候，这个数据就会复制一份副本， `bgsave` 子进程读取这个副本数据写到 RDB 文件

### 生成 RDB 期间，产生的数据怎么处理

- `save` 命令是阻塞主线程的，期间主线程不会处理客户端命令，所以生成的 RDB 是和内存数据一致的

- `bgsave` 是异步的，`fork` 的时候会拷贝父进程的数据内容，而且产生子进程也是有一定耗时的，在此期间，主线程还在处理客户端命令，那生成出来的 RDB 和实际的数据就会有差异了

  比如说在 `00:05` 的时候调用 `fork` 开始进行持久化，然后在 `00:07` 的时候，完成生成 RDB 文件，同时，主线程还在处理客户端的命令；那么这 `0.02s` 期间的产生的数据差异怎么办？

  操作系统的 **COW 写时复制技术**，即当产生数据读写的时候，会把这个数据复制一份，`bgsave` 的时候就是读取这个副本数据写入到 RDB 文件里

  **如果在 `fork` 之后，父子进程都还需要继续进行写操作，那么就会触发频繁的复制。**

## `AOF`

`Append Only File` 通过`记录用户的写、删除命令（查询命令不会记录）` **追加** 到 `xxx.aof` 文件，如果突然断电了，Redis 的数据就会通过重新读取并执行文件里的命令记录来恢复数据

![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1122279%2F202102%2F1122279-20210206093405595-1211875532.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619020663&t=1c342cfaa29eb48bb1b14687e5c8bd1c)

### 触发机制

```log
[命令] -----> [AOF 缓冲区] -- fsync --> [AOF 文件]
```

- Reds **主进程** 接收客户端请求写命令，写入到 `aof_buf`（AOF 缓冲区）

  命令写入到磁盘的整个过程都是在主线程执行的，这个过程必然会加重 Redis 写负担。（后面会说到 AOF 刷盘策略）

- 有专门的子进程去调用 `fsync()` 函数`把数据从缓存写入到 AOF 文件`，所以，不会阻塞客户端，主线程可以继续处理客户端请求。

**AOF 刷盘策略**

![alt](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190624101908354-208380668.png)

- `appendfsync always`

  每条命令都会刷新到缓冲区，把缓冲区 `fsync` 到硬盘，对硬盘 IO 压力大，一般 sata 盘只有几百 TPS，如果 redis 的写入量非常大，那对硬盘的压力也横刀。

- `appendfsync no`

  由操作系统来定什么时候 `fsync` 到硬盘中。但是当 Redis 宕机时，会丢失一部分数据。

- `appendfsync everysec` （默认配置）

  每秒把缓冲区 `fsync` 到硬盘，如果出现故障，会丢失 1 秒的数据

### AOF 优缺点

**`优点`**

数据的完整性和一致性更高

**`缺点`**

- 因为 AOF 记录的内容多，`文件会越来越大，数据恢复也会越来越慢`。

- AOF 每秒 `fsync` 一次指令硬盘，如果硬盘 IO 慢，会阻塞父进程；风险是会丢失 1 秒多的数据；在 Rewrite 过程中，主进程把指令存到 `mem-buffer` 中，最后写盘时会阻塞主进程。

### AOF 重写

> 实际上是 Redis 内存中的数据回溯成 AOF 文件

AOF 重写机制是在重写时，**读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」**（有点像 RDB，记录快照），等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/gB9Yvac5K3M9JeWwVHia7MXxHm00kiau916shF283yKeYkObSVbazanXv0pWN60kRJZ28YNdsYwibWRFyIRb9PcRg/640?wx_fmt=jpeg)

![alt](https://img-blog.csdnimg.cn/20200514100505242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlbm1laXNodWFp,size_16,color_FFFFFF,t_70)

**`bgrewriteaof` 命令**

> COW 写时复制

从 Redis 的主进程 `fork` 一个子进程生成包含当前 Redis 内存数据的最小命令集

- 从主进程中 fork 出子进程，并拿到 fork 时的 AOF 文件数据写到一个临时 AOF 文件中

- 在重写过程中，redis 收到的命令会同时写到 `AOF 缓冲区和重写缓冲区中`，这样保证重写不丢失重写过程中的命令

- 重写完成后通知主线程，主线程会将 `AOF 缓冲区` 中的数据追加到子进程生成的文件中

- Redis 会原子的将旧文件替换为新文件，并开始将数据写入到新的 aof 文件上

**自动触发时机：（需要同时满足）**

```ini
# 1. aof 文件重写的大小阈值
# 当前的 aof 文件大小 > aof 文件重写的大小阈值
auto-aof-rewrite-min-size 64mb

# 2. aof 文件增长率
# (aof 当前文件大小 - 上次 aof 的文件大小) / 上次 aof 文件大小 > aof 文件增长率
auto-aof-rewrite-percentage 100
```

## 两种持久化方案对比

- `RDB` 方案 假如不满触发条件，突然断电，就会丢失数据

- RDB 需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大

- `RDB` 保存的数据，`AOF` 保存的命令，`RDB` 文件比 `AOF` 小；恢复速度 `RDB` 更快

- 为了解决 `RDB` 的弊端，就有了 `AOF` 的持久化，始终在一个文件里保存记录，但 AOF 的持久化随着时间的推移数据量会越来越大，`占用很大的空间`

- 宕机后，会`优先加载 AOF 文件`，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件完整

- 各有优劣，如果能综合就好了，所幸的是在 Redis4.0 后，通过下面配置 `AOF-use-RDB-preamble` 就可以开启两者混合持久化，取长补短

### 二者都开启的情况下，加载顺序是怎么样的

> 先 **判断 `AOF`** 再判断 `RDB`（因为 AOF 数据更完整）

![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2.tuicool.com%2F2QJVb2i.png%21web&refer=http%3A%2F%2Fimg2.tuicool.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1619021238&t=6f2b42b9e8db50a51f87a301e26344fb)

### 恢复时 RDB 和 AOF 哪个更快

> RDB 快

- RDB 是数据的`内存映射`，直接载入到内存

- AFO 是命令，需要逐条执行

### 在生成 RDB 过程中，AOF 如果停止同步，会不会丢失

不会，所有的操作缓存在内存队列里，dump 完后后，统一操作

### 混合持久化模式

Redis4.0 以后，提供混合持久化方式 `aof-use-rdb-preamble` 配置，preamble 前言、序言的意思

![alt](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190626160208108-1516752611.png)

当 AOF rewrite 时，Redis `先以 RDB 格式在 AOF 文件中写入一个数据快照，再把在生成快照期间产生的每一个写命令，追加到 AOF 文件中`。因为 RDB 是二进制压缩写入的，这样 AOF 文件体积就变得更小了。

## Redis 既然有持久化为什么还要写进 MySQL

[Redis 本身有持久化，为什么还要写进 MySQL](https://blog.csdn.net/carroll_/article/details/115468681)

**权限控制**

- MySQL 有权限控制，用户可以精确到每个 IP 的每个账户，目标可以精确到每个表的每个操作。

- Redis 则是天生设计成完全开放权限，包括完全删除数据库的操作，任何人都可以执行。要么就只能把指令重命名成空的，完全禁止任何人执行。

**数据完整性**

- MySQL 的数据库保存在磁盘中，万一崩溃断电，也有数据库日志可以用以完成数据库事务。

- MySQL 支持主从备份，所有的写入操作都可以实时发送到异地，哪怕突然机房被核弹轰炸，也不会丢失数据（可能除了最后几条语句）。

- Redis 的崩溃…… 嗯小心数据全丢。Redis 的 Replication 备份…… 嗯小心数据全丢。

**负载均衡**

- MySQL 可以单主多从，也可以胆子够大在内网做双主，也可以用 innodb 配合 galera 做集群，每台机器都有一个独立的拷贝，因此服务器之间只要传输写指令即可。

- Redis 可以单主多从（然而小心数据全丢），但是不能做多主互联。最多最多只能做 sharding ，也就是每台机器只保存一部分数据，读写一律被分散到其他机器上。直接后果就是内网流量大增。

**数据隔离**

- MySQL 里我可以选择删掉某个应用的所有数据而保留另一个应用的所有数据。

- Redis 里要么依赖 11 个 DB 的选择，要么依赖命名空间。

**性价比**

- MySQL 是内存 + 硬盘，上个 SSD 配合 Query Cache 那速度已经是很快了。

- Redis 是纯内存。乖乖掏钱加内存换至强啦。而且你还是得配备高性能磁盘，因为定时刷到磁盘和开机加载数据的操作还是要磁盘性能的。

**数据库可以使用事务**

**需求不同**

- 开发这样想是对的，但是其他的人可能会面临新的压力，新的技术挑战，所以需求定位是最终的出发点，除非哪天 Redis 的统计也能做的很溜.

# 拾遗

- RDB 的 bgsave 和 AOF 的 fsync、AOF 重写的 bgrewriteaof 都是 fork 子进程去后台执行，不会阻塞主线程

# 其他

## 看下 rdb aof 文件到底保存啥

- 同样的数据，可以看出 aof 确实大一点

  ```sh
  $ls -lht
  total 8.0K
  -rw-rw---- 1 redis redis 163 Jul  2 17:10 dump.rdb
  -rw-r----- 1 redis redis 254 Jul  2 17:10 appendonly.aof

  # AOF 就是一个文本文件
  $file appendonly.aof
  appendonly.aof: UTF-8 Unicode text, with CRLF line terminators

  # RDB 是二进制文件
  $file dump.rdb
  dump.rdb: Redis RDB file, version 0009
  ```

- AOF

  可以看到保存了 huagnjinjie 这条已经被删除了的数据的命令

  ```sh
  $cat appendonly.aof
  # 注：为了方便阅读，我把同一个语句缩进到同一行了
  # 原始内容是每一个单词一行（空格分割）
  *2
  $6
  SELECT $1 0
  *8
  $5
  hmset $11 huagnjinjie $4 name $11 huangjinjie $4 city $6 深圳 $1 a $4 ge27 *8 $5
  hmset $11 huangjinjie $4 name $11 huangjinjie $4 city $6 深圳 $3 age $2 27 *2 $3
  del $11 huagnjinjie
  ```

- 同样的数据，在 RDB 形态下内容如下

  稍微可以看得出是什么数据；上面我是删了 huagnjinjie 这条数据的，RDB 文件中也确实没这条数据

  ```sh
  $cat dump.rdb

  REDIS0009�      redis-ver5.0.7�
  redis-bits�@�ctime�i
                       �bused-mem�|
                                    �
                                     aof-preamble���
  huangjinjie440name
  city深圳age��v����"=
  ```
