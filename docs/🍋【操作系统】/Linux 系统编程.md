- [文件IO](#文件io)
  - [标准库IO](#标准库io)
  - [系统调用IO](#系统调用io)
- [文件系统](#文件系统)
- [内存](#内存)
  - [内存分区](#内存分区)
  - [共享内存](#共享内存)
    - [linux 内存管理机制是什么](#linux-内存管理机制是什么)
    - [共享内存的实现原理](#共享内存的实现原理)
    - [共享内存段被映射进进程空间之后，存在于进程空间的什么位置](#共享内存段被映射进进程空间之后存在于进程空间的什么位置)
    - [共享内存段最大限制是多少](#共享内存段最大限制是多少)
  - [大小端](#大小端)
  - [堆栈](#堆栈)
    - [虚拟文件系统](#虚拟文件系统)
    - [段页式存储管理](#段页式存储管理)
- [进程](#进程)
  - [进程](#进程-1)
    - [`fork`](#fork)
    - [`wait 和 waitpid` 的区别](#wait-和-waitpid-的区别)
  - [进程环境](#进程环境)
    - [PCB](#pcb)
    - [程序地址空间](#程序地址空间)
  - [进程概念](#进程概念)
    - [僵尸进程](#僵尸进程)
    - [孤儿进程](#孤儿进程)
    - [守护进程](#守护进程)
    - [进程状态](#进程状态)
  - [进程控制](#进程控制)
    - [进程创建](#进程创建)
    - [进程等待](#进程等待)
    - [进程终止](#进程终止)
    - [程序替换](#程序替换)
  - [进程间通信 IPC](#进程间通信-ipc)
  - [经典进程同步问题](#经典进程同步问题)
    - [生产者消费者问题](#生产者消费者问题)
    - [读者写者问题](#读者写者问题)
    - [吸烟者问题](#吸烟者问题)
    - [哲学家进餐问题](#哲学家进餐问题)
- [线程](#线程)
  - [线程](#线程-1)
    - [多线程编程会带来什么问题](#多线程编程会带来什么问题)
  - [线程安全](#线程安全)
    - [同步](#同步)
    - [互斥](#互斥)
    - [模型](#模型)
  - [线程池](#线程池)
- [协程](#协程)
  - [协程和 `I/O` 多路复用有啥关联](#协程和-io-多路复用有啥关联)
  - [协程的特点](#协程的特点)
  - [线程协程区别联系](#线程协程区别联系)
  - [协程在 `web` 服务器中的应用](#协程在-web-服务器中的应用)
  - [协程](#协程-1)
- [锁](#锁)
  - [锁](#锁-1)
    - [`Linux` 编程中的锁有哪些](#linux-编程中的锁有哪些)
    - [条件变量的使用](#条件变量的使用)
    - [互斥锁](#互斥锁)
    - [死锁](#死锁)
    - [线程死锁](#线程死锁)
    - [其他](#其他)
  - [`flock` 文件锁](#flock-文件锁)
- [其他](#其他-1)

# 文件IO

- [文件打开模式](https://www.cnblogs.com/kangjianwei101/p/5220021.html)

## 标准库IO

## 系统调用IO

# 文件系统

# 内存

## 内存分区

## 共享内存

### linux 内存管理机制是什么

### 共享内存的实现原理

### 共享内存段被映射进进程空间之后，存在于进程空间的什么位置

### 共享内存段最大限制是多少

## 大小端

- 利用`union`判断是大端还是小端

  ```cpp
  /*
  由于union只存储一个成员，若一个union有一个int变量和一个char变量，那么若前一个int变量被赋值后 此时union存储的就是该int变量
  若此时读取char变量，由于char并没有被重写，所以读取的还是int变量的前8位
  根据读取的的8位字节判断是否=int的值, 如果相等，则证明int的值保存在低地址
             15       0        0        0
  [低地址->] 00001111 00000000 00000000 00000000[高地址] // 如果前8位=int的值, 则为小端
             0        0        0        15
  [高地址->] 00000000 00000000 00000000 00001111[低地址] // 如果后8位=int的值, 则为大端
  */
  bool IsLittleEndian()
  {
      union
      {
        int a;
        char b;
      } u;

      int k = 15; //要在char范围内
      u.a = k;
      if ((int)u.b == k)
      {
          printf("小端\n");
          return true;
      }
      else
      {
          printf("大端\n");
          return false;
      }
  }
  ```

## 堆栈

### 虚拟文件系统

- 虚拟文件系统什么意思
  Linux 中允许众多不同的文件系统共存，如 ext2, ext3, vfat 等，通过使用同一套文件 I/O 系统调用即可对 Linux 中的任意文件进行操作而无需考虑其所在的具体文件系统格式；即对文件的操作无需考虑文件属于哪个文件系统

- 一个实际的文件系统想要被 Linux 支持，就必须提供一个符合 VFS 标准 的接口，才能与 VFS 协同工作。`其实就像是库函数一样, 有对不同文件系统做封装，对于用户来说是透明的，操作是一样的`如下图:
  ![alt](http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/3.jpg)

### 段页式存储管理

# 进程

## 进程

### `fork`

> pid = 0 // 子进程; pid < 0 // error; pid >0; //父进程

- 写时复制(copy-on-write):
  - fork()进程如果没有调用 exec 的话, 其代码空间和父进程是一样的
  - 只有`在fork之后exec之前两个进程用的是相同的物理空间（内存区）子进程的代码段、数据段、堆栈都是指向父进程的物理空间`，也就是说
    两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，所以 fork 操作是很快的
  - `资源的复制只有在写入的时候才进行`
    > 例: 进程 A malloc()了一块内存，并将 string s，存入该空间，fork 出子进程 B,B 是否可以访问该内存，可以对内存的变量修改吗？
    > 不能，虽然是在堆上分配的，子进程还是会自己重新复制一份自己的空间，在自己的空间上操作

### `wait 和 waitpid` 的区别

- 从本质上讲，系统调用 waitpid 和 wait 的作用是完全相同的，但 waitpid 多出了两个可由用户控制的参数 pid 和 options，从而为我们编程提供了另一种更灵活的方式

  ```c++
  sub_pid = waitpid(-1, &stat, WNOHANG);

  >0    只等待进程ID等于指定进程号的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束 waitpid就会一直等下去。
  =-1   等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。
  =0    等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
  <-1   等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值
  ```

## 进程环境

### PCB

### 程序地址空间

## 进程概念

### 僵尸进程

### 孤儿进程

### 守护进程

### 进程状态

## 进程控制

### 进程创建

### 进程等待

### 进程终止

### 程序替换

## 进程间通信 IPC

## 经典进程同步问题

### 生产者消费者问题

### 读者写者问题

- 问题描述
  有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。

- 问题分析
  - 关系分析
    由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。

  - 整理思路
    两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。

  - 信号量设置
    首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。

### 吸烟者问题

### 哲学家进餐问题

# 线程

## 线程

### 多线程编程会带来什么问题

- 编写线程安全的函数、`调试`困难，比较难去重现 bug、`同步互斥过程中造成死锁问题`

## 线程安全

> 多线程访问临界资源的问题

### 同步

### 互斥

### 模型

## 线程池

- 事先创建好线程池，避免线程的频繁创建和销毁成本

# 协程

> - 协程，又称微线程，它不被操作系统内核所管理，而完全是由程序控制，协程切换花销小，因而有更高的性能。
> - 协程可以比作子程序，不同的是，**执行过程中协程可以挂起当前状态，转而执行其他协程，在适当的时候返回来接着执行，协程间的切换不需要涉及任何系统调用或任何阻塞调用，完全由协程调度器进行调度。**

- 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。 所以`子程序调用是通过栈实现的`，一个线程就是执行一个子程序。

- `协程在一个子程序中中断，去执行其他子程序`，不是函数调用，有点类似CPU的中断。就是说用了协程可以在执行A函数的过程中随时中断去执行B，B执行过程中也可以随时回来执行A，但是 `期间并没有发生函数调用`

- 这么看感觉线程也是这样啊，线程也是一会儿执行A函数，一会儿执行B函数，而且没有产生函数调用

## 协程和 `I/O` 多路复用有啥关联

> [协程与 IO 多路复用区别？](https://www.v2ex.com/t/690868)

- 单纯的协程是没有什么用的，就只是做做切换，协程本身是无法提高并发的, 但是协程 + I/O 切换可以.

- 协程是`用户态`的概念，IO 多路复用是系统调用的接口，是`用户态`与`内核态`交互的方式；毕竟协程是无法直接访问网卡缓冲区的，需要调用系统接口来获取网络 IO 的数据。 所以网络程序，协程一般需要搭配 IO 多路复用才能发挥最大威力，**协程提升并发处理的能力，IO 就要靠 IO 多路复用**。

- 之前写的 `c/s` 模型网络程序的时候，是怎么解决一个服务器同时接收多个客户端连接的? 做法是用 `多进程模型` 或者 `多线程模型`，即有新的客户端需要接入的时候，就开一个进程或者线程去处理（当然也可以是先创建好进程/线程池）

## 协程的特点

- 必须在只有一个单线程里实现并发

- 修改共享数据不需加锁

- 用户程序里自己保存多个控制流的上下文栈

- `一个协程遇到 IO 操作自动切换到其它协程`（如何实现检测 IO，yield、greenlet 都无法实现，就用到了 gevent 模块（select 机制））

- `对 IO 阻塞无关的大运算量耗时操作基本没有什么帮助`，比如循环导致的超时

- ==一旦引入协程，就需要检测单线程下所有的 IO 行为，实现遇到 IO 就切换，少一个都不行，因为一旦一个任务阻塞住了，整个线程就阻塞住了==。其他的任务即便是可以计算，但也无法运行了

## 线程协程区别联系

## 协程在 `web` 服务器中的应用

## 协程

# 锁

## 锁

> - 信号量、互斥锁都是选择睡眠的方式来对共享工作停止访问的
> - 自旋锁不会引起调用者【睡眠】

### `Linux` 编程中的锁有哪些

- 互斥锁 `mutex`
  当线程 A 先获取资源时，发现资源别的线程锁住了，CPU 进行上下文切换，`将线程挂起,置于等待队列，转而去执行别的任务，而不必进行忙等待`

- 自旋锁 `spin lock`
  如果线程 A 是去请求锁，那么线程 A 就会一直在 CPU 上`进行忙等待并不停的进行锁请求，直到获得锁为止`
  - 自旋锁适合锁时间比较短的情况
  - 适合 CPU 是可抢占的情况

- 信号量
  - 就是一个`计数器`，通过`PV操作同步解决进程/线程对临界资源利用的冲突问题`
    如果允许 n 个进程访问共享资源，信号量就设置为 n，有进程进房子里 P 操作（py) 锁头就减 1，如果没有锁了（锁数量为 0），还有进程想进来，那就挂起这个进程；进程访问完会把锁头交还给房管，此时锁头>0，刚才挂起的进程可以进来操作了

### 条件变量的使用

- 条件变量提供`信号机制`，所有等待该条件的线程同时阻塞，使用过程需要互斥量配合使用
  - 一个线程等待”条件变量的条件成立”而挂起
  - 另一个线程使”条件成立”（给出条件成立信号）

- 条件变量是一个类，定义: `std::condition_variable iMsg;` 是【用来等待线程进行通知而不是上锁的】，是线程间`共享全局变量进行同步的一种机制` ，为了防止竞争，`条件变量的使用总是和一个互斥锁结合在一起`

### 互斥锁

> 互斥锁、条件锁、自旋锁、读写锁

- `mutex`
- `lock_guard`
  类模板, 构造函数进行加锁, 析构函数进行解锁. 可以自己用大括号来限定作用域
- `unique_lock`
  比 lock_gurad 灵活在会记住锁的状态,
- `condition_variable + unique_lock + notify_once + wait`
- `future、promise、async`

- `atomic`
- `协程`

### 死锁

### 线程死锁

- 产生原因

  ```
  陷入互相等待的状态
  A线程锁住了mutex1, 在想用mutex2锁住的变量时尝试锁mutex2, 发现mutex2被锁了, 等待mutex2释放
  B线程锁住了mutex2, 在想用mutex1锁住的变量时尝试锁mutex1, 发现mutex1被锁了, 等待mutex1释放
  原因是A、B线程锁互斥量的顺序不一致, 解锁顺序倒是不影响
  ```

- 解决方法就是破坏几个条件中的一个

  ```cpp
  // c++11 thread 死锁解决

  1) std:lock() 函数模板
    std:lock(mutex1, mutex2)
    解锁还是要手工unlock()，解锁顺序不影响
    可以一次锁住>=2个互斥量，不存在因锁的顺序问题而导致死锁的存在，会等所有都锁住才继续往下走
    原理:
      如果有一个互斥量没锁成功，则会释放掉已锁成功的互斥量，过段时间再去尝试，直到把所有互斥量都锁住为止
    缺点:
      lock()解决死锁的痛点在于存在忘记unlock的危险，而lock_guard刚好可以自动unlock，可否两者优点都有呢？

  2) lock() 和 lock_guard
    使用lock_guard的adopt_lock参数可以做到，让lock_guard构造的时候不lock, 但是必需在lock_guard之前加锁
    std:lock（mutex1, mutex2)
    lock_guard<mutex>lock_guard(mutex1, adopt_lock)

  3) atomic 原子操作
    类模板atomic声明的对象确保了该操作是原子性的, 不需要加锁
    std::atomic<int> g_atomic_counter(0); // atomic是一个类模板
    g_atomic_counter++;
  ```

### 其他

## `flock` 文件锁

- `LOCKEX`

- check

# 其他
