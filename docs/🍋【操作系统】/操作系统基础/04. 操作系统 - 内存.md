- [参考资料](#参考资料)
- [内存](#内存)
  - [★ `cache` 和 `buffer` 的区别](#-cache-和-buffer-的区别)
  - [★ 进程的虚拟地址空间](#-进程的虚拟地址空间)
  - [★ `32`位虚拟内存空间地址从高到低是怎么分布的](#-32位虚拟内存空间地址从高到低是怎么分布的)
  - [内存分配](#内存分配)
    - [内存分配方式(生命周期)](#内存分配方式生命周期)
    - [用户空间内存分区](#用户空间内存分区)
  - [内存碎片](#内存碎片)
  - [为什么要内存对齐](#为什么要内存对齐)
  - [★ 什么是写时复制 `copy on write` 读时共享](#-什么是写时复制-copy-on-write-读时共享)
  - [★ 什么是零拷贝技术](#-什么是零拷贝技术)
  - [为什么浮点数有误差](#为什么浮点数有误差)
  - [如何判断两个浮点数是否相等，为什么不用等于号](#如何判断两个浮点数是否相等为什么不用等于号)
  - [★ `mmap`](#-mmap)
  - [虚拟地址如何映射到物理地址](#虚拟地址如何映射到物理地址)
  - [内存溢出 `memory overflow`](#内存溢出-memory-overflow)
    - [缓冲区溢出的原因和危害](#缓冲区溢出的原因和危害)
  - [内存泄漏 `memory leak`](#内存泄漏-memory-leak)
    - [内存泄漏解决方案](#内存泄漏解决方案)
  - [★ 堆和栈的区别](#-堆和栈的区别)
  - [分页和分段有什么区别](#分页和分段有什么区别)
- [文件系统](#文件系统)
  - [虚拟文件系统](#虚拟文件系统)

# 参考资料

[操作系统内存管理，你能回答这 8 个问题吗？](https://mp.weixin.qq.com/s/yzvye0rJto1P7zSTh03kZQ)

# 内存

## ★ `cache` 和 `buffer` 的区别

> [Linux 内存、Swap、Cache、Buffer 详细解析](https://mp.weixin.qq.com/s/gVwjTmHGtU8KDiuL4cBcCg)

![alt](https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEbkelNlZYW0RauS1CFBpKziacm0iaU3Vgjz9JTtbcTLnHXe2VhwvwuAWkYBnBpIhUJEGFMbPX587K2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- `cache（贮藏）`

  为了弥补高速设备和低速设备的`速度差`而引入的中间层，最终起到 `加快访问速度` 的作用。

- `buffer（缓冲）`

  为了进行流量整型，把突发的大数量较小规模的 I/O 整理成平稳的小数量较大规模的 I/O，以 `减少响应次数`（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了）

## ★ 进程的虚拟地址空间

> - [深入理解进程 — 虚拟地址空间](https://blog.csdn.net/weixin_43850474/article/details/112985963?mibr_reader_mode=1)
> - [Linux 进程地址空间和虚拟内存](https://blog.csdn.net/songchuwang1868/article/details/89710465)

- `为什么要有虚拟地址空间`

  因为程序不可分割，`要么有足够且连续的空间将程序一次性全部加载完毕，要么不加载`。所以我们发现这样的内存管理的效率太低，并且浪费了大量的空间，所以才会有之后的虚拟地址空间

- `什么是虚拟地址空间`

  操作系统为每一个进程都会设置属于自己的虚拟地址空间，换句话说就是，`操作系统欺骗了进程，将本来间断的内存空间通过一个虚拟地址空间让进程相信自己所加载的程序处于一个连续的空间之中`

## ★ `32`位虚拟内存空间地址从高到低是怎么分布的

- `0-3G` 用户空间，`3-4G` 内核空间，环境变量、命令行参数、栈区、共享库、堆区、数据段（bss/data）、代码段

- 看懂了这个，再去看那些子进程从父进程继承了什么、线程共享了进程什么资源、线程那些资源是私有的，就会清晰一点

![32 位 linux 寻址空间大致分布](https://img-blog.csdnimg.cn/20200211121000558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05hcG9sZW9uX2p1bg==,size_16,color_FFFFFF,t_70)

- 死记这个顺序没多久就忘记了，其实可以从程序运行所需要的内存来记忆

  - 首先肯定是内核空间先，`内核程序` 要先跑起来，用户的程序是内核函数调起的

  - 用户程序运需要链接一些动态库等，所以要知道`环境变量` 里库的位置

  - 指定运行这个程序需要什么参数，不同参数行为不一样嘛，所以要知道 `命令行参数`

  - 然后就正式开始运行了，首先放的是由系统管理的 `栈` 空间

  - 然后是程序所依赖的 `共享库` 空间

  - 然后是用户程序自己管理的 `堆` 空间（栈地址从上到下生长，堆是从下到上生长）

  - 然后是`未初始化的全局变量`、`已初始化的全局变量`、`代码段`，这个顺序也是，需要系统进行处理的会放在比较前面，后面已初始、代码段都是固定不动的，就放最后

![alt](https://img-blog.csdnimg.cn/20200211123735456.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05hcG9sZW9uX2p1bg==,size_16,color_FFFFFF,t_70)

![alt](https://img-blog.csdnimg.cn/2021012215205344.png)

- `内核空间`

  内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。

- `栈`

  由编译器自动分配释放，行为类似数据结构中的栈 (先进后出)，它是`向下增长`的，也就是说向低地址（了解了上面这个图，就不用纠结到底是堆还是栈向下生长的了）

- 局部变量、函数参数、返回地址等

- `共享映射段`

  装载动态共享库，如 C 标准库函数（fread、fwrite、fopen 等）和 Linux 系统 I/O 函数

- `堆`

  堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。它是`向上增长`的。

- `bss 段 （Block Started by Symbol）`

  指用来`存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域`
  未初始化或初值为 0 的全局变量和静态局部变量

- `data 段（已初始化全局变量）`

  `已初始化且初值非 0` 的全局变量和静态局部变量

- `代码段（即 text段）`

  可执行代码、字符串字面值、只读变量

## 内存分配

### 内存分配方式(生命周期)

- `静态存储连续性`

  函数外定义的变量(全局变量)和使用 satic 定义的变量, 他们在整个程序运行过程中都存在

- `自动存储连续性`

  函数内定义的局部变量(包括函数参数), 他们在开始执行所属函数时被创建, 执行完函数后被释放

- `线程存储连续性`

  用 `thread_local` 定义的变量, 其声明周期和所属线程一样

- `动态存储连续性`

  用 `new / malloc` 动态申请的变量, 申请时被创建, 直到用 `delete / free` 将其释放

- `内存分配时期`

  - `编译时不分配内存`

    编译时是不分配内存的。此时只是根据声明时的类型进行占位，到以后程序执行时分配内存才会正确;
    所以声明是给编译器看的，聪明的编译器能根据声明帮你识别错误；

  - `运行时必分配内存`

    运行时程序是必须调到“内存”的。因为 CPU（其中有多个寄存器）只与内存打交道的。程序在进入实际内存之前要首先分配物理内存;
    注意，涉及到内存分配的都是在运行阶段分配才有意义。

### 用户空间内存分区

- `栈区`

  由编译器自动分配释放, 存放`函数参数值和局部变量值`等

- `堆区`

  由程序员动态申请释放, 存放用 `new/malloc` 等申请的变量

- `代码区`

  存放`二进制代码`

- `全局区/静态存储区`

  这块内存在程序编译的时候就已经分配好了, 存放`全局变量和静态变量`

- `文字常量区`

  存放`字符串常量`, 程序结后由系统释放

## 内存碎片

- `内部碎片（操作系统导致）`

  - 已经被分配出去(能明确指出属于哪个进程)却不能被利用的内存空间

  - 如某一数组容量为 90，但实际只可以分配 8 字节的倍数大小可被 4、8 或 16 整除（视处理器体系结构而定）的地址容量即 96，也就是说`系统会分配比实际需要稍微大一点的空间`，比如之前写 dbf 解析的时候用到 mmap, 就是按整页分配, 不满一页也分配一页大小

  - 剩下的 6 个字节内存在当前程序中得不到利用也不能再次分配给其他程序，所以成为了碎片

- `外部碎片（程序员导致）`

  频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。

  ```
  - 有连续空闲字节空间0~99, 刚开始申请了10个字节(占用0~9), 接着申请了5个字节(10~14);

  - 把刚才0~9的那10个字节释放, 然后需要申请20个字节, 此时, 刚释放掉的空间不满足大小, 所以分配在了15~34了;

  0 --- 9 10 +++ 14 15 +++ 34 35 --- 99 (--表示空闲, ++表示占用)

  - 所以, 如果10~14的空间一直占用着, 而往后申请的空间都大于10字节, 那么0~9的空间就一直用不上了
  ```

- `怎么解决内存碎片问题`

  - 利用分页单元把一组非连续的空闲页框映射到连续的线性地址, 意思是，我们使用地址转换技术，`把非连续的物理地址转换成连续的线性地址`

  - 开发一种适当的技术来`管理现存的空闲的内存情况`，以尽量避免为满足对小块的请求而分割大的空闲块

## 为什么要内存对齐

- `平台（移植）原因`

  不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

- `性能原因`

  数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

- 内存对齐的例子

  ```cpp
  struct TestStruct1
  {
      char  c1;
      short s;
      char  c2;
      int   i;
  };

  // 按常理计算： char 1 字节，short 2 字节，int 4 字节，加一起 8 字节
  sizeof(TestStruct1)

  /* 实际不是这样 在 32 位系统中，按 4 字节对齐；64位系统则是按 8 字节对齐（一个字节8位）
  [********] [********] [********] [########]
  char       short                 填充
  [********] [########] [########] [########]
  char       填充
  [********] [********] [********] [********]
  int

  // 所以，这个结构体一共占用 3 * 4 = 12个字节
  */
  ```

## ★ 什么是写时复制 `copy on write` 读时共享

> - 写时复制 `COW` 是一种可以`【推迟甚至避免拷贝数据】`的技术
> - 内核此时并不复制整个进程的地址空间，而是让`父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间`，从而使各个进行拥有各自的地址空间
> - 资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候

- 在页根本不会被写入的情况下—例如，`fork()` 后立即执行 `exec()`，地址空间就无需被复制了

- `fork()` 的实际开销就是`复制父进程的页表以及给子进程创建一个进程描述符`。在一般情况下，进程创建后都为马上运行一个可执行的文件

- `可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)`。由于 Unix 强调进程快速执行的能力，所以这个优化是很重要的。

- 如果在 `fork()` 之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断 page-fault)，这样就得不偿失

## ★ 什么是零拷贝技术

内核层直接转发数据，不需要数据在内核态和用户态的拷贝；比如把内核空间和用户空间虚拟地址映射到同一个物理地址上

- [一文读懂零拷贝技术](https://mp.weixin.qq.com/s/c9Hi0Pq43Toi0Ug-Xndmlg)

- [深入理解零拷贝技术](https://mp.weixin.qq.com/s/vWNB8K9JlFL2q0oAtNzBxg)

- [一文带你彻底了解，零拷贝 Zero-Copy 技术 (图解)](https://zhuanlan.zhihu.com/p/442771856)

零拷贝技术 不单只有 `sendfile`，如 `mmap`、`splice` 和 `直接I/O` 等都是零拷贝技术的实现

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/A1HKVXsfHNld3Fz1Fsu7vO8sreLJ392QjYKIPqiarL7GFL74jvPibmKCnsl0uCs07qU2CHg5Lt7no715upBPPfmQ/640?wx_fmt=jpeg)

用上 零拷贝 后

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/A1HKVXsfHNld3Fz1Fsu7vO8sreLJ392QMavpYY7SgYMCUrKBnP0xKlwSQiaiaXfPuyibFxVxcu3lcYPAaV6GpoLnQ/640?wx_fmt=jpeg)

## 为什么浮点数有误差

> 十进制小数转换为二进制过程中出现了误差
> 对于小数部分转换后出现无限循环的部分，计算机只保存了有限位

- 十进制小数是怎么转化为二进制?
  整数部分 `连除2取余，倒序排列`，小数部分`连乘2取整，正序排列`

  ```sh
  例如：将十进制数值`42.65`转换为二进制数值

  42(42.65 的整数部分)
  42 / 2 = 21    ......    0
  21 / 2 = 10    ......    1
  10 / 2 = 5     ......    0
  5 / 2 = 2      ......    1
  2 / 2 = 1      ......    0
  1 / 2 = 1      ......    1

  十进制的 42 转换成二进制后为 101010，连除取余结果倒序排列
  (42)10 = (101010)2


  0.65(42.65 的小数部分)
  0.65 * 2 = 1.3    ......    1
  0.3  * 2 = 0.6    ......    0
  0.6  * 2 = 1.2    ......    1
  0.2  * 2 = 0.4    ......    0
  0.4  * 2 = 0.8    ......    0
  0.8  * 2 = 1.6    ......    1
  0.6  * 2 = ... (重复上述循环了)

  十进制的 0.65 转换成二进制后为 0.101001...，连乘取整结果正序排列
  (0.65) 10=(0.101001...) 2

  所以，十进制数 42.65 转换成二进制后为 101010.101001...
  (42.65) 10 = (101010) 2 + (0.101001...) 2 = (101010.101001...) 2
  ```

- `IEEE`标准

  `IEEE`标准规定，单精度浮点数共 32 位，`23位小数f`，8 位偏置指数 e，1 位符号 s；同理，`double类型有52位`可以存放小数

- `总结`

  上面将 0.65 转换出的二进制代码，计算机只能存储 23 位，所以后面`超出23位以后的都被忽略掉了`的

## 如何判断两个浮点数是否相等，为什么不用等于号

> `计算机本质是二进制，通过浮点表示小数，都是模拟出来的`， `float` 和 `double` 都不能保证可以把所有实数都准确的保存在计算机中，采用`==`运算符是不可行的

- 浮点数大小比较为什么不能用 `==`

  - 浮点数精度不同，同一小数，但用不同精度表示时，结果不一样

    ```cpp
    float a = (float) 0.1;
    float b = (double) 0.1;
    ```

- 可以通过求绝对值的差值和精度作比较来判断是否相等

  ```cpp
  const double eps = 1e-6;
  if (fabs(double_a - double_b) < eps)
  {
    ...
  }
  ```

## ★ `mmap`

> - [认真分析 mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html)
> - [深入理解 mmap](https://mp.weixin.qq.com/s/BPMa5FLPUKiLUr_59a41Gg)
> - [阿里二面：什么是 mmap？](https://mp.weixin.qq.com/s/4d6Bjp42VkcyMWVsxIDWaQ)

常规文件操作需要从 `【磁盘】到【页缓存】再到用户【程序主存】` 两次数据拷贝，`mmap` 操控文件，只需要从磁盘到用户主存的一次数据拷贝过程，不会产生缺页异常

![alt](https://mmbiz.qpic.cn/mmbiz_png/ljlJkD7iaUC1nyA3xTD2Y1vF5IqhsJPf2qkADaXYw4aic6mrLpPpcC6WA92rN2NarDE1j5NyRGMPNic3jOoZrEc5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 常规操作需要两次拷贝

  - 为了提高读写效率和保护磁盘，使用了页缓存机制，这样造成读文件时`需要先将文件页从磁盘拷贝到页缓存中`

  - `由于页缓存处在内核空间`，不能被用户进程直接寻址，所以还需要将`页缓存中数据页拷贝到用户空间`对应的内存

- `mmap` 过程

  - `mmap` 操作文件中，**`创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射`** 这两步，并没有把文件拷贝到主存。

  - 进程真正发来读写操作，`访问数据时发现内存中并无数据而发起的缺页异常`过程，通过已经建立好的映射关系，只使用一次数据拷贝，就`从磁盘中将数据传入内存的用户空间`中，供进程使用。所有不会发生`缺页异常`，也不会发生用户态到内核态的陷入动作。

- 通过 `mmap` 这种方式之后，用户进程可以直接访问这块内存，`memcpy` 访问的也只不过是用户空间地址，由于`访问的时候已经分配好了物理页面和【建立好了物理页到虚拟页的映射】`，所有不会发生`缺页异常`，也不会发生用户态到内核态的陷入动作

- 用户态进程正常访问内核态数据需要首先通过系统调用等方式陷入内核，进行数据拷贝，然后再次回到用户态；用户态和内核态直接的`进出需要进行上下文切换`，需要两次上下文切换，需要一定的开销，而 mmap 映射好之后以后访问都不需要进行上下文切换。

- mmap 映射这种方法由于物理页面通过页面共享更加节省内存，而用户态和内核态内存拷贝需要两份物理页面

## 虚拟地址如何映射到物理地址

> `mmu` 将虚地址转换成物理地址，达到访存的目的

- 将虚拟内存地址映射到物理内存地址，叫做内存映射，映射关系缓存在一个叫`页表`的结构中，由 `MMU` 模块进行管理；`MMU` 规定内存的映射最小单位，通常为 `4K`， 每次映射，都需要关联 4K 或 4K `整数倍`的内存空间

- 虚拟地址

  > 你网盘有 1T 的空间，你最多可以用 1T，但实际上没用到的部分是被其他用户共享的

  虚拟地址并不真实存在计算机中，`系统给每个进程都分配了虚拟空间`，进程可以认为这段虚拟空间是连续的，这个范围跟 CPU 位数相关，如 `32` 位系统中，进程的虚拟地址最大即为 `2^32（4G）`大小

- `物理地址`

  即`内存芯片级的单元寻址`，进程运行时执行的指令和数据最终都落到物理地址上，比如一条 4G 的内存条，其可寻址空间就是 `4G`

- `地址翻译`

  `Linux` 内核采用页式存储管理。虚拟地址空间划分为固定大小的页面。由 `MMU 在运行时将虚拟地址映射成（或者说地址翻译）某个物理内存页面中的地址`

## 内存溢出 `memory overflow`

> 程序在申请内存时，没有足够的内存空间

`使用安全的函数`，如 `snprintf` 而不是 `sprintf`

### 缓冲区溢出的原因和危害

> [什么是缓冲区溢出？有什么危害？原因是什么？](https://blog.csdn.net/qq_35642036/article/details/82809845)

- `原因`

  造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入

- `危害`

  - 程序崩溃，导致拒绝服务

  - 跳转并且执行一段恶意代码

## 内存泄漏 `memory leak`

> 申请的内存没有正确回收释放

- 类的构造函数和析构函数中 `new 和 delete 没有配套`，导致分配的资源没有正确释放

- 释放对象 `数组时没有使用 delete[]`，而使用了 `delete`

- 没有将 `基类的析构函数`定义为虚函数

### 内存泄漏解决方案

> 使用工具来查找内存泄漏 `vargard` 工具，`BoundsChecker` 工具

- 重载 `malloc，free` 函数

  对 malloc remalloc 函数进行封装，比如嵌套一层为 `xmalloc, xremalloc`，然后`调用时进行引用计算和记录分配地址`，同时也对 free 进行封装为 xfree，释放时相应的减掉引用计数，但程序退出时，引用计数应该为 0。

- 定义公共基类，重载 new 和 delete `运算符`

  定义一个基类，这个类中重载了 new 运算符和 delete 运算符，一个是`加引用计数`，一个是`记录分配地址`。这里可以调上面说到的的 `xmalloc 和 xfree`，需要注意先执行构造和析构函数，并且还要注意调用虚析构那一套。

- 使用 **`智能指针`** 来避免内存泄漏

  智能指针是根据局部变量在函数退出时，会调用类的析构函数来保障分配的堆内存能释放掉。

## ★ 堆和栈的区别

- `管理方式不同`

  - 栈是编译器自动管理的

  - 堆需手动释放

- `空间大小不同`

  - 在 32 位系统下，堆内存可达到 4GB 的的空间

  - 而栈就小得可怜。(VC6 中,栈默认大小是 1M,当然,你可以修改它)

- `能否产生碎片不同`

  - 对于栈来说，进栈/出栈都有着严格的顺序(先进后出)，不会产生碎片

  - 堆频繁的 new/delete,会造成内存空间的不连续,容易产生碎片

- `生长方向不同`

  > 站可能站不起来，但堆一定会越堆越高

  - 栈向下生长，地址从高到低分配。以降序分配内存地址

  - 堆向上生长，地址从低到高分配，以升序分配内在地址

- `分配方式不同`

  - 堆动态分配,无静态分配

  - 栈分为静态分配和动态分配,比如局部变量的分配,就是动态分配(alloca 函数)

- `分配效率不同`

  - 栈是系统提供的数据结构,计算机会在底层对栈提供支持,进栈/出栈都有专门的指令,这就决定了栈的效率比较高

  - 堆则不然,它由 C/C++函数库提供,机制复杂,堆的效率要比栈低得多

## 分页和分段有什么区别

> 用户程序的`地址空间`被划分成若干固定大小的区域，称为 `页`，相应地，`内存空间`分成若干个物理`块`，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配

- [操作系统：分段与分页的区别](https://blog.csdn.net/crslee/article/details/44535343)

# 文件系统

## 虚拟文件系统

- 虚拟文件系统什么意思

  Linux 中允许众多不同的文件系统共存，如 ext2, ext3, vfat 等，通过使用同一套文件 I/O 系统调用即可对 Linux 中的任意文件进行操作而无需考虑其所在的具体文件系统格式；即对文件的操作无需考虑文件属于哪个文件系统

- 一个实际的文件系统想要被 Linux 支持，就必须提供一个符合 VFS 标准 的接口，才能与 VFS 协同工作。`其实就像是库函数一样, 有对不同文件系统做封装，对于用户来说是透明的，操作是一样的`如下图:

  ![alt](http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/3.jpg)
