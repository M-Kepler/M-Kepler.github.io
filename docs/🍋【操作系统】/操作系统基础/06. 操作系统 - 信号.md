- [信号](#信号)
  - [说一说你对信号的了解](#说一说你对信号的了解)
  - [可靠信号(实时信号)、不可靠信号(非实时信号)](#可靠信号实时信号不可靠信号非实时信号)
  - [系统如何将一个信号通知到进程](#系统如何将一个信号通知到进程)
  - [进程如何处理收到的信号](#进程如何处理收到的信号)
  - [信号是如何传递的](#信号是如何传递的)
  - [常见信号有哪些](#常见信号有哪些)
- [其他](#其他)

# 信号

[Linux 信号/软中断 signal 处理机制](https://blog.csdn.net/g1036583997/article/details/44935515)

## 说一说你对信号的了解

**什么是信号**

- 软中断信号，又称为信号，Linux 提供的一种通知进程发生了异步事件的方法

**信号处理函数***

- `SIGIGN`

  忽略信号的处理程序

- `SIG_DFL`

  默认信号处理程序

**怎么发信号**

- 命令 `kill -s SIGCHLD pid`

- 命令 `kill -9 pid`

- 向指定进程发送信号 `kill(pid, SIGUSR1)`

- 向自己发送信号 `raise(SIGUSR1)`

- 向进程发送 `SIGABRT` 信号 `abort()`

- 注册信号处理函数对信号做出响应，用户注册的信号处理函数是在用户态下运行

  ```cpp
  // SignalHandle 为信号处理函数, 收到SIGCHLD会调用该函数
  signal(SIGCHLD, SignalHandler);
  ```

## 可靠信号(实时信号)、不可靠信号(非实时信号)

[可靠信号(实时信号)、不可靠信号(非实时信号)](https://www.cnblogs.com/shichuan/p/4448030.html)

> 早期 UNIX 下的不可靠信号主要指的是`进程可能对信号做出错误的反应以及信号可能丢失`

- 进程每次处理信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理；因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用 `signal()` 重新安装该信号

- Linux 支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，Linux 下的不可靠信号问题主要指的是信号可能丢失

## 系统如何将一个信号通知到进程

[`Linux` 下的进程信号处理过程](https://blog.csdn.net/h___q/article/details/84245317)

> 内核在进程所在的`【进程表项的信号域】`设置对应的信号的位，进程 `维护一个未决信号的【链表】`，当进程从内核态返回【用户态】时就会第一时间处理

- 进程维护着一个`未决信号的链表`。内核给进程发送信号，是在进程所在的`进程表项的信号域`设置对应的信号的位

  ![alt](https://s1.ax1x.com/2018/11/19/FSqxRH.png)

- `进程处理信号的时机` 是从内核态返回用户态时，会去检查是否有信号要处理

- 信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中

- `可靠信号` 不管链表中是否已经有这个信号了，都会加进去

- `不可靠信号` 如果链表中已经有这个信号了，就会忽略。

- `执行用户自定义的信号处理函数的方法`

  内核 `【把信号处理函数的地址放在用户栈栈顶】` ，当进程从内核返回到用户态时（进入内核的方法就是异常、中断、系统调用），最先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态

## 进程如何处理收到的信号

- `忽略信号`

  即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL 及 SIGSTOP

- `捕捉信号`

  定义信号处理函数, 当信号发生时, 执行相应的处理函数

- `缺省操作`

  Linux 进程对实时信号的缺省反应是`终止进程`

## 信号是如何传递的

- 信号本质一个`软件模拟的中断`，或许是硬件中断 Ctrl-C 等操作，或许是软件 kill 函数等发送信号

- 进程注册信号，内核监控，`进程切换至内核，检测是否发生信号`，传递信号，进入进程的信号服务函数

## 常见信号有哪些

> - 可以通过 `kill -l` 查看系统支持哪些信号
> - [信号含义](https://blog.csdn.net/weixin_34121304/article/details/85553216)

- `SIGALRM`

  > 定时信号, 计算的是实际的时间或时钟时间，alarm 函数使用该信号.(alarm 闹钟)

  ```cpp
  signal(SIGALRM, SigHandler);

  // 设置闹钟时间为30秒，30秒后触发信号，SigHandler处理信号
  alarm(30);
  ```

- `SIGHUP`

  和控制台操作有关，`当控制台被关闭时`系统会向拥有控制台 sessionID 的所有进程发送 HUP 信号

- `SIGINT`

  `interrupt` 终止进程，用户按下`Ctrl + c`时发送

- `SIGQUIT`

  `Ctrl + \`

- `SIGSTOP`

  `Ctrl + z` 结束进程

- `SIGKILL`

  消息编号为 9，kill -9 来`杀死进程时`发送

- `SIGSEGV`

  `内存越界、权限问题`，试图访问未分配给内存, 或图往没有写权限的内存地址写数据

- [`SIGABRT`](https://blog.csdn.net/Season_hangzhou/article/details/54926636)

  - `abort()`函数生成的信号

  - 多次 `free`

  - 执行 `assert` 函数

- `SIGIO`

- `SIGSYS`

  系统调用中参数错，如系统调用号非法

- `SIGCHLD`

  通知父进程`处理僵尸进程`

- `SIGPIPE`

  > [`EPIPE` 和 `SIGPIPE`](https://blog.csdn.net/hellolingyun/article/details/34139471)

  - 这个是向一个 `没有读进程的管道写数据` 产生的错误

  - 在网络编程中这个信号发生在如果客户端已经关闭了套接字, 而服务器调用了一次 write，服务器就会收到一个 RST segment，如果服务器再次调用 write，这个时候就会产生 SIGPIPE 信号，系统默认的处理方式是关掉这个进程

- `SIGUSR1`

  用户自定义信号 默认处理：进程终止

# 其他

- `Ctrl-D` 不会发起信号，它表示 EOF（End-Of-File），关闭标准输入（stdin）管道（比如可以通过 Ctrl-D 退出当前 shell）。如果程序不读取当前输入的话，是不受 Ctrl-D 影响的。
