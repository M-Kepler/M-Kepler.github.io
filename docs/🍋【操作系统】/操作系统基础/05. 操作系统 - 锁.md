- [锁](#锁)
  - [Linux 下有的几种典型的锁](#linux-下有的几种典型的锁)
  - [自旋锁和互斥锁的区别](#自旋锁和互斥锁的区别)
  - [★ 什么是死锁，产生条件是什么，怎么解决](#-什么是死锁产生条件是什么怎么解决)
    - [死锁产生的四个必要条件](#死锁产生的四个必要条件)
    - [死锁的预防](#死锁的预防)
  - [并发控制中的锁](#并发控制中的锁)
  - [数据库中的锁](#数据库中的锁)
  - [`filelock` 文件锁](#filelock-文件锁)

## 锁

### Linux 下有的几种典型的锁

**读写锁**

- 多个读者可以同时进行读

- 写者必须互斥

- 写者优先于读者

**自旋锁**

- 如果进线程无法取得锁，进线程不会立刻放弃 CPU 时间片，而是`一直循环尝试获取锁，直到获取为止`。如果别的线程长时期占有锁，那么自旋就是在浪费 CPU 做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高

**互斥锁**

- 互斥锁，也称作独占锁，排它锁，`锁在某一时刻只能被一个线程占有，其它线程必须等待`锁被释放之后才可能获取到锁。

**条件变量**

- 与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量`用来自动阻塞一个线程，直到某特殊情况发生为止`。通常条件变量和互斥锁同时使用

- `互斥锁是线程间互斥的机制，条件变量则是同步机制`

- 条件变量使我们可以睡眠等待某种条件出现。条件变量是`利用线程间共享的全局变量进行同步的一种机制`，主要包括两个动作：一个线程等待 "条件变量的条件成立" 而挂起；另一个线程使 "条件成立"（给出条件成立信号）

### 自旋锁和互斥锁的区别

// TODO

- 自旋锁`不会引起调用者睡眠，执行效率比较高`

- 自旋锁会`一致占用 CPU` ，适合保持锁时间比较短的情况

- 自旋锁`很可能造成死锁`，比如递归地去调用

### ★ 什么是死锁，产生条件是什么，怎么解决

[死锁的处理基本策略和常用方法](https://blog.csdn.net/Beyond_2016/article/details/81359021)

- `什么是死锁`

  指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进，进入死等状态

#### 死锁产生的四个必要条件

> 我拿着你要的东西，你也拿着我要的东西；大家都在等着对方释放；而且又不能抢；

- `互斥`

  一个资源每次只能被一个进程使用

- `占有且等待`(请求与保持)

  进程因请求资源而阻塞时，对已获得的资源保持不放

- `不可剥夺`

  进程已获得资源，在使用完之前，不可强行剥夺

- `循环等待`

  A 锁住了 B 需要的资源，B 锁住了 A 需要的资源，导致 A 和 B 相互等待对方释放

#### 死锁的预防

> 通过破除死锁四个必要条件之一，来防止死锁产生

- `破坏占有且等待条件`

  进程在开始运行之前，`一次性地申请`其在整个运行过程中所需要的全部资源

- `破坏不可剥夺`条件`

  当进程申请的`资源被占用时，释放其已占有的资源`

- `破坏循环等待条件`

  `资源有序分配`，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反

### 并发控制中的锁

> 可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 `memcache`、`hibernate`、`tair` 等都有类似的概念

- `乐观锁`

  总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。

- `悲观锁`

  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

### 数据库中的锁

[[05. MySQL - 锁]]

### `filelock` 文件锁
