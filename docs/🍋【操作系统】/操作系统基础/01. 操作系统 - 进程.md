- [进程](#进程)
  - [进程调度策略](#进程调度策略)
  - [进程分类](#进程分类)
    - [说一说僵尸进程](#说一说僵尸进程)
    - [说一说孤儿进程](#说一说孤儿进程)
    - [说一说守护进程](#说一说守护进程)
  - [进程继承](#进程继承)
    - [★ 系统为进程分配了什么资源](#-系统为进程分配了什么资源)
    - [什么是进程上下文，为什么要进行上下文切换，上下文包含什么内容](#什么是进程上下文为什么要进行上下文切换上下文包含什么内容)
    - [★ 子进程可以从父进程继承到什么](#-子进程可以从父进程继承到什么)
  - [★ 进程间通信 `IPC`](#-进程间通信-ipc)
    - [管道](#管道)
      - [匿名管道](#匿名管道)
      - [命名管道](#命名管道)
    - [消息队列](#消息队列)
    - [共享内存](#共享内存)
    - [信号量 `Pv`](#信号量-pv)
    - [信号](#信号)
    - [套接字](#套接字)
  - [★ 进程的状态转换](#-进程的状态转换)
  - [Linux 进程状态](#linux-进程状态)
    - [D 状态](#d-状态)
      - [D 状态为什么不可中断啊](#d-状态为什么不可中断啊)
      - [D 状态很多怎么办](#d-状态很多怎么办)
      - [D 状态占用 CPU 吗](#d-状态占用-cpu-吗)
- [其他](#其他)

# 进程

## 进程调度策略

[操作系统中进程调度策略有哪几种](https://www.cnblogs.com/hjh-666/p/11449470.html)

- **先来先服务**

  每次调度是从进程队列中选择一个最先进入该队列的进程，为之分配资源投入运行。该进程一直运行完成或发生某事件而阻塞后才继续处理后面的进程。

- **优级别**

  有`短进程`优先级、`高优先权`优先级、`高响应比`优先级等，按照优先级来执行就绪进程队列中的调度（高响应比：（等待时间+服务运行时间）/服务运行时间）

- **时间片轮转**

  系统还是按照`先来先服务`调度就绪进程，但每次调度时，CPU 都会为队首进程分配并执行一个时间片（几 ms~百 ms）。`执行时间片用完后计时器即产生时钟中断，停止该进程并将它送到队尾`，其他依次执行。这样保证系统能在给定的时间内执行所有用户进程的请求。

- **多级反馈**

  - `设置多个就绪队列，每个队列优先级依次减小`。为各个队列分配的时间片大小不同，优先级队列越高，里面进程规定的执行时间片就越小。

  - 队列中还是按照 FCFS 原则排队等待，`如果第一队列队首进程在规定的时间片内未执行完，则直接调送至第二队尾，依次向后放一个队列的队尾`。因此一个长作业进程会分配到 n 个队列的时间片执行。

  - 按照队列先后依次执行，`如果新进的待处理进程优先级较高，则新进程将抢占正在运行的进程`，被抢占的进程放置正在运行的队尾。

## 进程分类

### 说一说僵尸进程

- [python3 僵尸进程](https://www.cnblogs.com/lilyxiaoyy/p/10967202.html)

- [孤儿进程与僵尸进程](https://www.cnblogs.com/anker/p/3271773.html)

**什么是僵尸进程**

- 父进程还在运行，而子进程挂了，但`父进程没有清理子进程的进程信息`，导致子进程虽然运行实体已消失，但是仍在内核进程表中占有数据，造成资源浪费

- 进程占有的所有资源将被回收，除了 `task_struct` 结构（以及少数资源）以外。于是进程就只剩下这个空壳，故称为僵尸

**如何检查是否存在**

```sh
# 进程状态为 Z
ps -ef | grep defunct | grep -v grep
```

**僵尸进程的危害**

`浪费系统资源`

- 子`进程号`会一直被占用，系统所能使用的进程号是有限的，如果产生大量的僵尸进程，最终可能导致系统没有可用的进程号，从而不能产生新的进程

- `该进程不占用内存和 CPU`，但是会`在进程任务管理树上占用一个宝贵的节点`。这样就造成了进程名额的资源浪费

**解决方法**

- 杀死其所属父进程, 使变成孤儿进程，由 `init` 进程会负责清理进程信息

- `wait` 主进程阻塞, 随便一个子进程结束就停止阻塞

- `waitpid` 非阻塞, 但需要用轮询的方式监控子进程

- `signal` 其实是子进程退出时会给父进程一个信号, signal 里用 wait 或 waitpid 都是非阻塞的，只要父进程还在就都会监测子进程信号, 可以把所有子进程都回收

- `kill -s SIGCHLD pid` 将这里的 pid 替换成父进程的进程 id, 这样父进程就会删除所有已经死掉的子进程了

### 说一说孤儿进程

- `什么是孤儿进程`

  `子进程还在运行, 而父进程挂了`, 子进程变为孤儿进程, 将由 `init` 进程收养并清理进程信息

- `孤儿进程的危害`

  孤儿进程会由 `init` 进程会负责清理进程信息，所以不会像僵尸进程那样，造成系统资源浪费

### 说一说守护进程

- 运行在后台的一种特殊进程。它`独立于控制终端`并且周期性地执行某种任务或等待处理某些发生的事件

  - 守护进程最重要的特性是`后台运行`

  - 守护进程必须`与其运行前的环境隔离`

    这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩码等; 这些环境通常是守护进程从执行它的父进程（特别是 shell）中继承下来的

    - 进程组

      就是多个进程，进程组由进程组 ID 标识，进程组 ID 也是一个进程的必备属性，每个进程组都有一个组长进程,
      组长进程的 ID 等于进程组的 ID，进程 ID 不会因为组长进程的退出而受到影响

    - 会话组

      是多个进程组组成的，一个会话开始于用户登录，终止于用户退出，在此期间用户运行的所有进程都属于这个会话期，

    - 除这些特殊性以外，守护进程与普通进程基本上没有什么区别
      编写守护进程实际上是把一个普通进程按照上述的守护进程的特性改造成为守护进程

- 步骤

  ```
  1. 【脱离终端】
      创建子进程，父进程退出
      所有工作在子进程中进行
      形式上脱离了控制终端

  2. 在子进程中【创建新会话】
      setsid()函数
      使子进程完全独立出来，脱离控制

  3. 【改变当前目录】为根目录
      chdir()函数
      防止占用可卸载的文件系统
      也可以换成其它路径

  4. 重设【文件权限掩码】
      umask()函数
      防止继承的文件创建屏蔽字拒绝某些权限
      增加守护进程灵活性

  5. 【关闭文件描述符】
      继承的打开文件不会用到，浪费系统资源，无法卸载
  ```

## 进程继承

### ★ 系统为进程分配了什么资源

> `PCB： process control block` 进程控制块

[`PCB` 与进程分配资源](https://blog.csdn.net/lvyibin890/article/details/82193900)

**标识相关**

`pid`，`ppid` 等等

**文件相关**

进程需要记录打开的文件信息，于是需要文件描述符表

**内存相关**

内存指针，指向进程的虚拟地址空间（用户空间）信息

**优先级相关**

进程相对于其他进程的调度优先级

**上下文信息相关**

- CPU 的所有寄存器中的值

- 进程的状态以及堆栈上的内容

**状态相关**

进程当前的状态，说明该进程处于什么状态

**信号相关**

进程的信号处理函数，以及记录当前进程是否还有待处理的信号

**`I/O` 相关**

记录进程与各种 I/O 设备之间的交互

### 什么是进程上下文，为什么要进行上下文切换，上下文包含什么内容

进程上下文是进程执行活动全过程的静态描述

- 把已执行过的 `进程指令` 和数据在相关 `寄存器与堆栈` 中的内容称为 `进程上文`

- 把正在执行的指令和数据在寄存器与堆栈中的内容称为 `进程正文`

- 把待执行的指令和数据在寄存器与堆栈中的内容称为 `进程下文`

### ★ 子进程可以从父进程继承到什么

- 父进程和子进程拥有独立的地址空间和 `PID` 参数

- 用户号和用户组号，`用户`信息，`目录`信息，`环境` (表)，打开的`文件描述符`，`堆栈`，`共享内存` 等

## ★ 进程间通信 `IPC`

[★ 进程间通信](https://blog.csdn.net/qq_34827674/article/details/107678226)

- 匿名管道 `pipe`

  管道`都是半双工通信`，FIFO，所以自带了同步互斥机制，即也可以用于线程间通信；本质是内核中的一串 `缓存`

  - 只是适用于父子进程间通信

  - 有消息大小限制，65536 字节

  - 生命周期随进程

  - 通信数据存放在内核中

- 命名管道 `fifo`

  和匿名管道除了可以在不同进程间通信外，没啥区别；本质是内核中的一串缓存

  - 可以在不同进程间进行通信（和匿名管道的区别）

  - 有消息大小限制

  - 生命周期随进程

  - 通信数据存放在内核中

- 消息队列 `message queue`

  本质是保存在内核中的 `消息链表`

  - 支持 `有类型的数据` 传输，解决了管道通信只能承载字节流地缺点

  - 支持全双工通信，`允许多个进程` 进行写入和读取

  - 生命周随内核

    创建后就由内核进行管理（`ipcs` 命令可以查看到其状态），如果不手动释放，就一直存在，除非重启系统

  - 也有消息大小限制

  - 缺点：需要在用户态和内核态之间进行数据拷贝

- 共享内存 `shared memory`

  本质是拿出一块虚拟地址空间来，映射到物理内存中

  - 解决消息队列需要在用户态和内核态之间拷贝数据带来的开销

  - 不需要在用户态内核态之间拷贝数据

  - 缺点：带来多进程同步互斥问题

- 信号量 `semaphore`

  本质是一个计数器，用来实现进程间的互斥和同步

  - 解决共享内存在多进程下的资源竞争的问题

- 套接字 `socket`

  用于不同主机间地进程通信

  - 解决跨主机进程通信的问题

### 管道

[IPC 通信之管道](https://blog.csdn.net/wangpeihuixyz/article/details/41653859)

- 管道都有`同步和阻塞的问题(即自带同步互斥机制、而且是半双工通信)`, 读写有等待的情况; 而且当读写的数据大于`最大长度(管道通信消息有最大长度限制，linux 上的 PIPE 容量为 65536 个字节)`时会阻塞等待

- 不管是匿名管道还是命名管道，进程写入的`数据都是缓存在内核中`，另一个进程读取数据时候自然也是从内核中获取，同时`通信数据都遵循 FIFO 先进先出原则`，不支持 lseek 之类的文件定位操作。

#### 匿名管道

- `shell` 里的 `|` 就是通过匿名管道进行进程通信的

- 通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道

- 匿名管道是只能用于`存在父子关系的进程间通信`，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失

- 本质是`内存中的一块缓冲区`，可以看作是打开到内存中的文件

  ```cpp
  // 依靠 fork 函数, 实现 父子进程间 共用一个管道进行通信
  // 和 linux 标准输入输出一样，0 表示标准输入、1 表示标准输出

  #define INPUT 0
  #define OUTPUT 1

  // 创建无名管道(fork之前)
  // 参数 filedis 返回两个文件描述符：filedes[0] 为读而打开
  int pipe(int fd[2])

  // 写之前，先关闭读端
  close(fd[INPUT]);
  write(fd[OUTPUT], "test data", strlen("test data") + 1);

  // 读之前，先关闭写端
  close(fd[OUTPUT]);
  read(fd[INPUT], buf, sizeof(buf));
  ```

#### 命名管道

- `可以认为是通过文件来进行进程间通信`，写入读出的对象都是一个文件

- 命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，毫无关系的进程就可以通过这个设备文件进行通信

  ```cpp
  // 命令管道中的数据是先进先出的传输方式
  mkfifo(PIPENAME, 0666);    // 1. 创建管道
  open(PIPENAME, O_WRONLY);  // 2. 打开管道
  write(fd, &i, sizeof(i));  // 3. 写数据
  close(fd);                 // 4. 关闭管道
  ```

- [如何查看管道容量](https://www.cnblogs.com/hanxiaoyu/p/5683248.html)

  ```sh
  ulimit -a   # pipe size
  ```

- `fcntl(fd, F_SETFL, O_NONBLOCK)` 设置管道工作为非阻塞 IO 方式

| `n` 表示写入字节数; `PIPE_BUF` 表示管道容量 | `n <= PIPE_BUF`                                                   | `n > PIPE_BUF`                                                                                                                                                                         |
| ------------------------------------------- | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `阻塞`                                      | 写操作是原子操作，如果 pipe 空间不足则阻塞                        | 写操作不是原子操作，写入的数据可能与其他进程写入的交叉排列，写操作阻塞直到所有数据写完                                                                                                 |
| `非阻塞`                                    | 写操作是原子操作，如果 pipe 空间不足，则失败，errno 设置为 EAGAIN | 写操作不是原子操作，如果 pipe 空间不足，则失败，errno 设置为 EAGAIN。写入的数据可能与其他进程写入的数据交叉排列。同时实际写入可能小于 n(部分写入)；调用者应该检查 write 实际写入的长度 |

### 消息队列

- `内核中的一个队列`，各个进程通过放置、获取节点来进行通信，`【有类型的数据块传输】`，克服了管道只能承载无格式字节流的缺点

- 消息队列通信的速度不是最及时的，毕竟`每次数据的写入和读取都需要经过【用户态与内核态之间的拷贝】过程`。

- 消息队列其实就是存消息的队列（链表实现的队列），消息有个字段是消息类型，接收进程可以独立接收具有不同类型的数据块

- `和有名管道一样, 发送的数据都【有最大长度限制】`

- 管道生命周期随进程；消息队列的 `生命周期`随内核；如果没有释放消息队列或没有关闭操作系统，消息队列会一直存在，需要我们显式的调用接口或使用命令删除

- 消息队列支持全双工通信，而且允许`一个或多个进程进行写入或读取消息`

  ```cpp
  #include <sys/msg.h>

  // 1. ftok 产生key
  key_t key = ftok("./", 88);

  // 2. 建立消息队列
  int msgget(key_t key, int msgflg);

  // 3.1 发送消息 0 阻塞 IPC_NOWAIT 非阻塞
  int msgsnd(int msgid, void *msg_ptr, size_t msg_sz, int msgflag);

  // 3.2. 接收消息类型为msgtype的消息
  int msgrcv(int msgid, void *msg_ptr, size_t msg_sz, long int msg_type, int msgflag);

  // 4. 控制消息队列，比如删除
  int msgctl(int magid, int cmd, struct msgid_ds *buf);
  ```

### 共享内存

- 共享内存可以`解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销`

- 它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，`不需要陷入内核态或者系统调用`，大大提高了通信的速度，是最快的进程间通信方式

- 带来新的问题，多进程竞争同个共享资源会造成数据的错乱

- 共享内存是临界资源，操作时必需保证原子性，可借助信号量或者互斥(linux 锁机制)

  ```cpp
  #include <sys/shm.h>

  // 1. ftok 产生key
  key_t key = ftok("./", 88);

  // 2. 产生信号量ID
  int shmget(key_t key, size_t size, int shmflag);

  // 3. 映射共享内存地址，返回地址指针
  void *shmat(int shm_id, const void *shm_addr, int shm_flag);

  // 4. 控制共享内存(也可以删除)
  int shmctl(int shm_id, int cmd, struct shmid_ds *buf);

  // 5. 解除映射
  int shmdt(const void *shm_addr);
  ```

### 信号量 `Pv`

> 内核中的计数器，实现进程间的同步与互斥

- 对临界区资源进行保护， 解决进程间同步与互斥问题的一种进程间通讯机制

  ```cpp
  #include <sys/sem.h>

  // 1. ftok 产生key
  key_t key = ftok("./", 88);

  // 2. 产生信号量ID
  int semget(key_t key, int num_sems, int sem_flgs);

  // 3. 控制信号量(也可以删除)
  int semctl(int sem_id, int sem_num, int command...);

  // 解锁或锁定共享资源
  int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);
  ```

### 信号

> 通常用于异常情况下通知进程

详见 [操作系统 - 信号.md]

### 套接字

- `服务器`

  - `socket` 创建套接字

    ```cpp
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    // AF_INET 表示使用TCP/IP协议族; SOCK_STREAM 表示使用TCP协议, SOCK_DGRAM 表示使用UDP协议;
    ```

  - `bind` 绑定地址和端口

  - `listen` 把套接字由默认的主动设置为被动连接状态，等待客户端链接

  - `accept` 接收到客户端连接进来, 返回新套接字与该客户端进行通信

  - 进行读写

    ```cpp
    int write(int fd, void *buf, size_t nbytes);
    int send (int sockfd, void *buf, int len, int flags)
    ```

  - `关闭套接字`

    ```cpp
    close(fd);
    ```

- `客户端`

  - 创建 socket 套接字

  - `connect`与服务器进行链接(三次握手)

  - 与服务器进行收 `recv` 发 `send` 通信

  - 关闭套接字

## ★ 进程的状态转换

- 运行状态（Runing）

  该时刻进程占用 CPU

- 就绪状态（Ready）

  可运行，但因为其他进程正在运行而暂停停止

- 阻塞状态（Blocked）

  该进程正在等待某一事件发生（如等待输入 / 输出操作的完成）而暂时停止运行，这时，即使给它 CPU 控制权，它也无法运行

![alt](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png)

- `就绪 --> 执行`

  对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态

- `执行 --> 阻塞`

  正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等

- `阻塞 --> 就绪`

  处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态

- `执行 --> 就绪`

  正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态

## Linux 进程状态

> - [Linux 进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)](https://blog.csdn.net/shenwansangz/article/details/51981459)

- `R（TASK_RUNNING）`

  > 教科书中把正在 CPU 上执行的进程定义为 RUNNING 状态，把已就绪，当未被调度执行的进程定义为 READY 状态，这两种状态在 Linux 下统一为 TASK_RUNNING 状态

  程序正在运行或者是在等待运行的队列中

- `S（TASK_INTERRUPTIBLE）`

  > 进程因等待某事情发生而被挂起，比如 等待 socket 链接、信号量等；就是`就绪状态`，万事具备了，就等 CPU 调度了

  可中断的睡眠状态

- `D（TASK_UNINTERRUPTIBLE）`

  > 和 S 状态类似，区别在于该状态是不可中断的；并非 CPU 不响应外部硬件中断，而是指进程不响应异步信号（这是进程状态，肯定与 CPU 无关啊），比如你不能通过 `kill -9` 来杀死处于 D 状态的进程

  不可中断的睡眠状态，比如调用 `read` 【对设备】进行写操作时，就需要 D 状态对进程进行保护，以免出现错误

- `T（TASK_STOPPED or TASK_TRACED）`

  暂停状态或跟踪状态

  - `TASK_STOPPED`

    进程响应 `SIGSTOP` 信号而进入该状态

  - `TASK_TRACED`

    进程被跟踪时处于该状态，比如 gdb 对进程打下一个断点

- `Z（TASK_DEAD、EXIT_ZOMBIE）`

  僵尸进程；等待父进程回收。这种进程不再占用内存和 CPU。

### D 状态

[Linux 进程状态解析之 D 状态](https://www.cnblogs.com/embedded-linux/p/7043569.html)

- D 状态存在的意义就在于，内核的某些处理流程是不能被打断的

- 在进程对某些硬件进行操作时（`比如进程调用 read 系统调用对某个设备文件进行读操作`，而 read 系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用 D 状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的 D 状态总是非常短暂的，通过 ps 命令基本上不可能捕捉到。

#### D 状态为什么不可中断啊

> 意义在于内核的某些处理流程是不能被打断的

在进程对某些硬件进行操作时（比如调用 read 系统调用对某个设备文件进行读写操作，而 read 系统调用最终执行到的是对应设备驱动的代码，并与对应的物理设备进行交互）可能需要使用 D 状态对进程进行保护，`以免进程与设备交互过程被打断`

#### D 状态很多怎么办

> D 状态是非常短暂的，通过 `ps` 命令基本不可能捕捉到

如果系统或硬件发生了故障，进程可能会在不可中断状态保持很久，甚至导致系统中出现大量不可中断进程。这时，就很有可能`【引起 I/O 等性能问题】`

#### D 状态占用 CPU 吗

不占，占用的是磁盘

# 其他
