- [参考资料](#参考资料)
- [Golang](#golang)
  - [安装配置](#安装配置)
  - [工程目录](#工程目录)
  - [环境变量](#环境变量)
- [编译与链接](#编译与链接)
  - [编译](#编译)
- [包管理](#包管理)
  - [第三方模块安装](#第三方模块安装)
    - [go get 和 go install](#go-get-和-go-install)
    - [`GOPATH` 模式](#gopath-模式)
    - [`Modules` 模式](#modules-模式)
    - [工作区模式](#工作区模式)
    - [离线安装](#离线安装)
    - [自定义的包](#自定义的包)
    - [`main` 包](#main-包)
  - [私有仓库](#私有仓库)
- [输入输出](#输入输出)
  - [格式化输出](#格式化输出)
- [变量类型](#变量类型)
  - [空值](#空值)
  - [boolean 布尔](#boolean-布尔)
  - [numeric 数字](#numeric-数字)
  - [array 数组](#array-数组)
  - [slice 切片](#slice-切片)
  - [map 字典](#map-字典)
  - [byte 字节](#byte-字节)
  - [string 字符串](#string-字符串)
    - [内置方法](#内置方法)
  - [struct 结构体](#struct-结构体)
  - [pointer 指针](#pointer-指针)
  - [function 函数](#function-函数)
  - [interface 接口](#interface-接口)
  - [channel 通道](#channel-通道)
  - [变量作用域](#变量作用域)
  - [类型转换](#类型转换)
- [运算符](#运算符)
- [条件判断](#条件判断)
- [循环](#循环)
- [函数](#函数)
  - [函数参数](#函数参数)
  - [`init` 函数](#init-函数)
  - [defer 机制](#defer-机制)
  - [函数作为值](#函数作为值)
  - [闭包](#闭包)
- [管道](#管道)
- [协程](#协程)
- [反射](#反射)
- [单元测试](#单元测试)
  - [覆盖率](#覆盖率)
  - [遇到的问题](#遇到的问题)
- [调试](#调试)
- [学习过程中的疑问](#学习过程中的疑问)
- [其他](#其他)

# 参考资料

- [Go 入门的学习笔记](https://github.com/xinliangnote/Go)

- [7 天用 Go 从零实现系列](https://github.com/geektutu/7days-golang)

- [Go 语言高级编程](https://github.com/chai2010/advanced-go-programming-book)

- [★ Golang 内置库文档](https://pkg.go.dev/golang.org/x)

- [Go 语言入门教程，Golang 入门教程](http://c.biancheng.net/golang/)

- [Go 语言教程](http://www.runoob.com/go/go-tutorial.html)

- [Go 语言中文网](https://studygolang.com)

- [Go 语言中文文档](https://www.topgoer.cn/docs/golang/golang-1ccjbpfstsfi1)

- [Go 学习笔记](https://juejin.im/post/5cc7a20051882512fa03a3cf)

- [★ Go 语言中文文档](https://topgoer.com)

- [★ 地鼠文档](https://www.topgoer.cn/)

- [Golang 教程](https://www.kancloud.cn/pshizhsysu/golang/2139484)

- [GO 语言圣经](https://books.studygolang.com/gopl-zh/)

- [Go by Example 基础学习](https://gobyexample-cn.github.io/)

- [Go 语言快速入门](https://wangchujiang.com/golang-tutorial/index.html)

- [【置顶】Go 语言学习之路/Go 语言教程](https://www.liwenzhou.com/posts/Go/golang-menu/)

# Golang

## 安装配置

**[通过 apt 安装 golang 并初始化](https://www.jianshu.com/p/623c5cfba809)**

```sh
sudo add-apt-repository ppa:longsleep/golang-backports
sudo apt-get update
sudo apt-get install golang-go

```

**[设置代理](https://blog.csdn.net/love666666shen/article/details/104382356)**

```sh
# 等号左右不能有空格
go env -w GOPROXY=https://goproxy.cn,direct

```

**安装依赖**

```sh
# 用 MOD 模式,打开 GO111MODULE=on

# go install [pkg_name]@[tag]
go install github.com/mdempsky/gocode@latest
go install github.com/uudashr/gopkgs/cmd/gopkgs@latest
go install github.com/ramya-rao-a/go-outline@latest
go install github.com/acroca/go-symbols@latest
go install github.com/fatih/gomodifytags@latest
go install github.com/josharian/impl@latest
go install github.com/davidrjenni/reftools/cmd/fillstruct@latest
go install github.com/haya14busa/goplay/cmd/goplay@latest
go install github.com/godoctor/godoctor@latest
go install github.com/go-delve/delve/cmd/dlv@latest
go install github.com/stamblerre/gocode@latest
go install github.com/rogpeppe/godef@latest
go install github.com/sqs/goreturns@latest
go install golang.org/x/tools/cmd/guru@latest
go install golang.org/x/tools/cmd/gorename@latest
go install golang.org/x/lint/golint@latest

```

**GOPATH 模式，开发包的安装目录的功能及说明**

> Modules 和传统的 GOPATH 不同，不需要包含例如 src，bin 这样的子目录，一个源代码目录甚至是空目录都可以作为 Modules，只要其中包含有 go.mod 文件。

```log
go_proj/
    ├── api  每个版本的 api 变更差异
    ├── bin  go 源码包编译出的编译器（go）、文档工具（godoc）、格式化工具（gofmt）
    ├── doc  英文版的 Go 文档
    ├── lib  引用的一些库文件
    ├── misc 杂项用途的文件，例如 Android 平台的编译、git 的提交钩子等
    ├── pkg  编译好的中间文件
    ├── src  标准库的源码
    └── test 测试用例

```

## 工程目录

![alt](https://www.topgoer.com/static/2/7.png)

Go 语言项目的目录一般包含以下三个子目录：

**src 目录**

放置项目和`库的源文件`

- 用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。

- 包是 Go 语言管理代码的重要机制，其作用类似于 Java 中的 package 和 C/C++ 的头文件。Go 源文件中第一段有效代码必须是 `package <包名>` 的形式。

**pkg 目录**

放置编译后生成的包/库的归档文件

用于存放通过 `go install` 命令安装某个包后的归档文件。归档文件是指那些名称以 `.a` 结尾的文件。

**bin 目录**

放置编译后生成的可执行文件

与 pkg 目录类似，在通过 `go install` 命令完成安装后，保存由 Go `命令源文件`生成的可执行文件，可执行文件的名称与命令源文件的文件名相同。

**源文件**

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须一致的。

- `命令源文件`: 包含 main 函数的源代码文件

  有点像 python 中 `if __name__ == "__main__"` 的意思

  如果一个 Go 源文件被声明属于 main 包，并且该文件中包含 main 函数，则它就是命令源码文件。命令源文件属于程序的入口，可以通过 Go 语言的 go run 命令运行或者通过 go build 命令生成可执行文件。

- `库源文件`: 不包含 main 函数的源代码文件

  有点像 python 中的模块，有 `__init__.py` 的就是一个模块

  库源文件则是指存在于某个包中的普通源文件，并且库源文件中不包含 main 函数。

## 环境变量

[环境变量](https://cloud.tencent.com/developer/article/1650021)

```sh
# GOROOT golang 的安装的绝对路径

# GOBIN golang 安装目录下的 bin 目录，记得把 GOBIN 加入到 PATH 环境变量

# GOPATH go 编译时严格按照设置的工作目录中查找程序，编译

# 查看全部环境变量
go env

# 查看某一个环境变量
go env GOPATH

# 设置
# 等号左右不能有空格
go env -w GOPROXY=https://goproxy.io,direct

```

# 编译与链接

## 编译

- `go run hello.go` 编译链接并运行

- `go run hello.go -f /path/to/config` 指定配置

- `go build hello.go` 编译生成可执行文件

  `go build [file_name1] [file_name2] ...`

  **file_name 非空时**

  - 如果 file_name 为同一 main 包下的所有源文件名（可能有一个或者多个），**编译器将生成一个与 第一个 file_name 同名的可执行文件**（如执行 `go build abc.go def.go ...` 会生成一个 abc.exe 文件）；

  - 如果 file_name 为非 main 包下的源文件名，编译器将只对该包进行语法检查，不生成可执行文件。

  **file_name 参数为空时**

  - 如果当前目录下存在 main 包，则会生成一个与当前目录名同名的 `目录名.exe` 可执行文件（如在 hello 目录中执行 go build 命令时，会生成 hello.exe 文件）；

  - 如果不存在 main 包，则只对当前目录下的程序源码进行语法检查，不会生成可执行文件。

- `go install hello.go` 编译并安装，会在 `$GOPATH/bin/` 下生成可执行文件

# 包管理

Go 语言的包与文件夹是一一对应的，它具有以下几个特性：

- 一个目录下的同级文件属于同一个包。

- 包名可以与其目录名不同。

- main 包是 Go 语言程序的入口包，一个 Go 语言程序必须有且仅有一个 main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件。

- main 函数是 Go 语言程序的入口函数，也即程序启动后运行的第一个函数。main 函数只能声明在 main 包中，不能声明在其他包中，并且，一个 main 包中也必须有且仅有一个 main 函数。（和 cpp 一样）

**包的查找**

Go 首先会在 `$GOROOT/src` 目录中搜索指定的包，如果找不到，再去 `$GOPATH/src` 目录中找。

**包的别名**

在关键字 import 和包名之间，声明一个变量名，用以表示这个包。Go 中，`下划线`是一个特殊的符号，表示 null 容器。如果我们引用了 greet 包，但是暂时没有用到它，Go 在编译的时候就会抱怨这个问题。为了避免这个问题，我们就可以把暂时用不到的引用放在 `_` 中，这样编译器就会忽略它。

给一个包加上 `下划线` 别名看似没有意义，但其实在某些情况下还是很有用的，比如在包初始化时用不到的变量。引入了一个包 `_ "quickstart/routers"` 这个包只引入执行了里面的 init 函数。

```go
import (
    alias_name "greet"
)
```

## 第三方模块安装

### go get 和 go install

[go get 和 go install](https://blog.csdn.net/jarvan5/article/details/117917790)

如果只是下载第三方库，可以用 `go get`（会自动安装依赖）；如果要下载第三方库提供的可执行程序，用 `go install`

```sh
# 必须在有 go.mod 的目录下执行（go mod init 初始化一个项目）
# 自动下载到 $GOMODCACHE 下
# go get -u github.com/zeromicro/go-zero

go install github.com/zeromicro/go-zero/tools/goctl@latest

```

- `go get` 必须在有 `go.mod` 的目录下才可以执行，比如你想装个第三方包，不好意思，你不能在任意地方执行命令，必须得在包目录下执行...

  ```sh
  # go get github.com/astaxie/beego
  # go: go.mod file not found in current directory or any parent directory.
  #         'go get' is no longer supported outside a module.
  #         To build and install a command, use 'go install' with a version,
  #         like 'go install example.com/cmd@latest'
  #         For more information, see https://golang.org/doc/go-get-install-deprecation
  #         or run 'go help get' or 'go help install'.

  cd /path/to/your/package
  go mod init
  go get github.com/astaxie/beego
  ```

- `go get` 第一步就是下载远程的库，如果就想要使用本地的版本是办不到的，所以如果你不需要 download 你需要就可以使用 `go install`

- 在新版本的 go 1.15 `go install` 如果本地没有 package 会自动从远程下载包，所以是十分方便的

```sh
mkdir hello/
cd hello/

# 指定了模块导入路径为 gitee.com/biexiaoyansudian/my.cn
go mod init gitee.com/biexiaoyansudian/my.cn

# 当其他项目引用这个模块下的 package 时都会以该 import path 作为共同的前缀，比如：
# import "gitee.com/biexiaoyansudian/my.cn/mypkg"

################### 库安装

################### 可执行程序的安装
# GOPATH 模式：
# go get github.com/beego/bee@latest
# go install github.com/beego/bee

# MOD 模式
go install github.com/beego/bee@latest

# 可执行文件 bee.exe 会被安装到
$GOPATH/bin 下
```

```sh
# 项目中用到一些库，但是还是冒红线，需要执行 go mod init

cd hello/
go mod int hello

```

```sh
######### 我真是服了这傻逼包管理机制 #########

go get github.com/astaxie/beego
go: go.mod file not found in current directory or any parent directory.
        'go get' is no longer supported outside a module.
        To build and install a command, use 'go install' with a version,
        like 'go install example.com/cmd@latest'
        For more information, see https://golang.org/doc/go-get-install-deprecation
        or run 'go help get' or 'go help install'.

--------->

go install github.com/astaxie/beego
go: 'go install' requires a version when current directory is not in a module
        Try 'go install github.com/astaxie/beego@latest' to install the latest version

--------->

go install github.com/astaxie/beego@latest
go: github.com/astaxie/beego@latest (in github.com/astaxie/beego@v1.12.3):
        The go.mod file for the module providing named packages contains one or
        more replace directives. It must not contain directives that would cause
        it to be interpreted differently than if it were the main module.

go install https://github.com/beego/bee/v2@latest
go: https://github.com/beego/bee/v2@latest: argument must be a clean package path

go mod init hello
go get github.com/astaxie/beego@latest

```

### `GOPATH` 模式

设置 `GO111MODULE` 环境变量为 `off`

- GOPATH 模式才可以使用相对导入， mod 模式不允许相对导入，会报错：`main.go:3:8: "./src/modules" is relative, but relative import paths are not supported in module mode`

- fmt 的包在 GOROOT 下可以找到，而第三方包的搜索目录与该 go 项目使用的依赖管理工具有关。

  比如使用 GOPATH 管理依赖，那么会去 `$GOPATH/src` 下搜索，如果使用 go module 管理依赖，会去 `$GOMODCACHE` 下搜索

- GOPATH 模式下，go get 命令使用时，没有版本选择机制；因此 Go1.13 起，官方就不再推荐使用 GOPATH 的模式了。

### `Modules` 模式

go path 模式的进化版本

[mod 模式下如何使用相对导入](https://blog.csdn.net/guoguangwu/article/details/124304280)

**包管理工具 go mod**

- 在 Golang 1.11 版本之前如果我们要自定义包的话必须把项目放在 $GOPATH 目录下。

- Go1.11 版本之后无需手动配置环境变量，使用 go mod 管理项目，也不需要非得把项目放到 $GOPATH 指定目录下，你可以在你磁盘的任何位置新建一个项目；（就是说你可以在你自己的项目下通过 go.mod 来管理依赖），Go1.13 以后可以彻底不要 GOPATH 了。

- mod 机制会自动从 $GOPROXY 拉取依赖到本地缓存

```sh
# go mod 模式下，$GOPATH 路径没啥用了
$GOROOT/mod/github.com/beego/beego/v2@v2.0.1

# 模块管理打开
set GO111MODULE = on
# on    会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。

# auto  自动检测是否使用 modules 功能，如果当前目录不在 $GOPATH 并且当前目录（或者父目录）下有 go.mod 文件，则使用 GO111MODULE， 否则仍旧使用 GOPATH 模式

# off   不使用 modules 功能，查找 vendor 和 GOPATH 目录

# 在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOMODCACHE 中，也会把 go install 的结果放在 $GOPATH/bin 中。

```

**go.mod**

```sh
# go.mod 文件。它记录了当前项目的模块信息，每一行都以一个关键词开头
# 应用项目需要的依赖增加到 go.mod 文件
# 去掉 go.mod 中项目不需要的依赖

# 指定了模块导入路径为 gitee.com/biexiaoyansudian/my.cn
go mod init gitee.com/biexiaoyansudian/my.cn

# 当其他项目引用这个模块下的 package 时都会以该 import path 作为共同的前缀，比如：
# import "gitee.com/biexiaoyansudian/my.cn/mypkg"

# 使用 go get 命令，相关信息可以自动记录到 go.mod 文件中
# 生成 go.sum
go get github.com/astaxie/beego@latest

go install github.com/astaxie/beego

############### 那我怎么在其他项目中用这个包呢?
cd /path/to/your/package
go get github.com/astaxie/beego
# 这样，就不会报错找不到第三方包了
```

**go mod tidy**

- `-v` 显示整个命令的执行过程

- 引用项目需要的依赖增加到 go.mod 文件。

- 去掉 go.mod 文件中项目不需要的依赖。

**如何调用同一个 package 内的其他文件中的函数**

```sh
go mod init test
# 一般是 go run xxx.go
go run .

```

### 工作区模式

[Golang 1.18 工作区模式(workspace mode)](https://www.sakishum.com/2022/04/13/Golang-1-18-%E5%B7%A5%E4%BD%9C%E5%8C%BA%E6%A8%A1%E5%BC%8F-workspace-mode/#/%E4%BD%BF%E7%94%A8)

### 离线安装

**GOPATH 模式下**

[如何安装 第三方 Go 离线包](https://www.cnblogs.com/52php/p/6245375.html)

- 从 github 下载代码 https://github.com/dgrijalva/jwt-go 得到 zip 压缩包

- 放到 $GOPATH 下

  ```sh
  go install $GOPATH/github.com/dgrijalva/jwt-go
  ```

**MOD 模式下**

### 自定义的包

包下面的所有 go 文件首行都需要声明包名 `package pkg_name`

文件的名称首字母为大写的函数是对外暴露的，外部只要 `import pkg_name` 引入这个包就可以使用这个包下面所有的大写字母开头的函数 `pkg_name.Somefunc`

[使用 go module 导入本地包](https://zhuanlan.zhihu.com/p/109828249)

- **同一个项目下**

  ```sh
  moduledemo
  ├── go.mod
  ├── main.go
  └── package
      └── mypackage.go -----> # 首行： `package test_package`

  #### 注意，包只和代码首行 package xxx 有关系，与文件名，目录名无关

  # moduledemo/go.mod 中按如下定义：
  # go mod init github.com/moduledemo

  module github.com/moduledemo
  go 1.18

  ```

  ```go
  // moduledemo/main.go 中按如下方式导入 package
  package main
  import "github.com/moduledemo/test_package"  // 导入同一项目下的mypackage包
  ```

- **不同项目下**

  ```log
  # 目录结构
  ├── moduledemo
  │   ├── go.mod
  │   └── main.go
  └── package
      ├── go.mod
      └── mypackage.go
  ```

  package 也需要进行 module 初始化，即拥有一个属于自己的 go.mod 文件，内容如下：

  ```go
  // go int github.com/test_package
  module github.com/test_package

  go 1.18
  ```

  在 `moduledemo/main.go` 中按如下方式导入：

  ```go
  import (
      "fmt"
      "github.com/test_package"
  )
  ```

  因为这两个包不在同一个项目路径下，且还没把 test_package 上传到 github，所以需要在 go.mod 文件中使用 replace 指令，`moduledemo/go.mod` 指明通过相对路径查找这个包

  ```go
  module moduledemo

  go 1.18

  require (
    "github.com/test_package" v0.0.0
  )

  replace (
    "github.com/test_package" => "../package"
  )
  ```

  **或者把你的包源码（快捷方式不行）放到 $GOROOT/src 目录下面**

### `main` 包

- golang main 包下推荐只有一个 main.go 的入口文件

- 当有其他的 go 文件 ， 并且在其他 go 文件中定义了函数

- 在 main.go 入口文件中调用了该函数 ， 执行 go run main.go , 会提示 undefined；如果非得这样做那么 `go run` 的时候把所有文件都得加上，否则默认只加载 main.go 这一个文件

- 只有非 main 包里的文件才会通过依赖去自动加载。所以你需要输入多个文件作为参数。应该使用 `go run a.go b.go c.go` 或 `go run *.go` 、`go run .` 来运行，编译同理

## 私有仓库

- [完美解决 golang go get 私有仓库的问题](http://www.iis7.com/a/nr/wz/202105/11699.html)

- [如何使用 gitlab 自建 golang 基础库](http://t.zoukankan.com/chenqionghe-p-11309202.html)

```sh
# 由于仓库路径非go get标准命名，需要设置替换
# 替换 git 的 https 为 ssh，避免下载包的过程让输入密码
git config --global url."git@gitlab.xxx.com:".insteadOf "https://gitlab.xxx.com/"

```

# 输入输出

## 格式化输出

[Go 语言中的格式化输出](https://www.cnblogs.com/golove/p/3284304.html)

| 格式     | 说明                                                                       |
| :------- | :------------------------------------------------------------------------- |
| `%d`     | 格式化整数                                                                 |
| `%0d`    | 用于规定输出定长的整数 其中开头的数字 0 是必须的                           |
| `%t`     | bool 布尔型                                                                |
| `%g`     | 格式化浮点型                                                               |
| `%n.mg`  | 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f |
| `%f`     | 格式化浮点数                                                               |
| `%X, %x` | 格式化 16 进制表示的数字                                                   |
| `%b`     | 位的格式化标识符                                                           |
| `%e`     | 科学计数表示法                                                             |
| `%t`     | 格式化布尔型                                                               |
| `%c`     | 格式化字符                                                                 |
| `%s`     | 格式化字符串                                                               |
| `%U, %u` | Unicode，格式为 U+hhhh 的字符串                                            |
| `%p`     | 格式化指针                                                                 |
| `%v`     | 使用类型的默认输出格式的标识符                                             |
| `%+v`    | 输出结构体成员                                                             |

- `Print` 输出到控制台（`不接受任何格式化`，它相当于对每一个操作数都应用%v）

- `Printf` printf formate 只可以打印出格式化的字符串，只可以直接输出字符串类型的变量，不可以输出整形变量和整形

- `Sprintf` 格式化并返回一个字符串而不带任何输出，像 snprintf

- 打印结构体

  ```go
  fmt.Printf("%+v", user)
  ```

# 变量类型

## 空值

## boolean 布尔

## numeric 数字

## array 数组

- 声明长度为 4 的数组 `var array[4] int`

- 声明长度为 4 的数组并初始化 `var array[4] int = [4]int{1, 2, 3, 4}`

- 字符串数组 `array := [5]string{"abc", "def", "ghi", "jkl"}`

- 无需指定个数 `int s[] = {1,2,3}; array := [...]int{1,2,3,4,5}`

- 指定初始化某几个元素，其他未指定的使用类型默认值 `int s[5] = {1,2}`

- 初始化指定索引的元素，其他未指定的使用类型默认值 `array := [5]int{1:10, 3:30}`

  ```go
  len(array) 长度
  cap(array) 容量
  ```

- 类型和长度相同的数组可以直接赋值

  ```go
  var arr1[3]string
  var arr2[3]string ={"abc", "def", "ghi"}
  ```

## slice 切片

- [[] 和 nil 的差异](https://blog.csdn.net/liracle/article/details/124622638)

  判断问题，首先两者是不等的；其次在判断是否空时，建议统一使用 len(a)==0 做判断

  ```go
  // json 序列化时，会序列化为 null
  var [] int

  // json 序列化时，会序列化为 []
  a := make([]int, 0)
  ```

## map 字典

[Golang 缺少逗号报错问题](https://www.cnblogs.com/NolaLi/p/10330944.html)

## byte 字节

```go
str := "huangjinjie"
[]byte(str)
```

- `key.([]byte)` 类型转换，把 `interface{}` 转换成 `byte` 数组

## string 字符串

### 内置方法

## struct 结构体

go 语言没有 typedef, 以下声明相当于声明了 Books 类型

- 声明定义

  ```go
  type Books struct {
      author string
      title string
      subject string
      book_id int
  }
  test := Books {}
  ```

- 初始化

  ```go
  Books{"go语言", "标题", "主题", "id"}

  // 采用 key value 的方式初始化，如果只初始化了某几个，未初始化的为默认值(输出就能看到了)
  Books{title: "go语言", title: "标题", subject: "主题", book_id: "编号"};
  ```

- 使用

  ```go
  book Books // 声明book为Books类型
  book.title
  ```

## pointer 指针

go 语言的结构体指针访问成员居然也用 `.` 操作符（c++ 里指针是要用 `->`）

```go
var p_book *Books
```

[golang 值类型与引用类型的区别](https://blog.csdn.net/u014630623/article/details/103930646)

- 值类型：声明变量之后可以直接使用

- 引用类型：对于引用类型，若使用 var 进行声明变量，必须使用 make 函数对其进行分配内存。若不初始化，该变量默认值为 nil，向其添加元素时会导致 panic。

## function 函数

## interface 接口

```go
// 空接口
interface{}
```

## channel 通道

## 变量作用域

## 类型转换

# 运算符

https://www.bookstack.cn/read/jaywcjlove-golang-tutorial/spilt.8.golang.md

基本和 cpp 一样

# 条件判断

# 循环

没有 `while` 循环

```go
for a := 0; a < 10; a++ {
    // ...
}
```

# 函数

[Go - 函数详解（参数、返回值、init 函数、匿名函数、defer）](https://blog.csdn.net/lady_killer9/article/details/115645849)

## 函数参数

- 有值传递、指针传递、没有引用传递（但是有引用类型）

- 指针 `var p *int`

  [Golang 中设置函数默认参数的优雅实现](https://www.cnblogs.com/smartrui/p/10324320.html)

## `init` 函数

- `init` 函数 的主要工作就是，初始化无法在全局范围内初始化的全局变量 。例如，初始化数组

- 跟 main 函数一样，当初始化包的时候，init 函数也会被执行。它没有参数，也没有返回值。

- init 函数是由 Go 来声明的，你无法引用这个函数（ 也不能用类似 `_init()_` 的方式调用它）。

- 你可以在一个文件或一个包中 **定义多个 init 函数**。在同一个文件中，init 函数是按照它们被定义的先后顺序被执行的。

## defer 机制

defer 用来声明一个延迟函数，把这个函数放入到一个栈上，当外部的包含方法 return 之前，返回参数到调用方法之前调用，也可以说是运行到最外层方法体时调用。我们经常用他来做一些资源的释放，比如关闭 io 操作。

## 函数作为值

- 直接赋值给变量，省去了定义函数指针的麻烦

  ```c++
  typedef void (*pFunc)(char *);
  pFunc lfunc;
  lfunc(3);

  // lambda
  auto addFunc = [](int a, int b)->int { return a+b;};
  addFunc(2, 5);
  ```

  ```go
  /* 声明函数变量 */
   getSquareRoot := func(x float64) float64 {
      return math.Sqrt(x)
   }

   /* 使用函数 */
   fmt.Println(getSquareRoot(9))
  ```

- golang 没有导出接口的吗？都是隐藏在一个文件夹下的一个文件里面

## 闭包

# 管道

# 协程

# 反射

# 单元测试

[注意事项](https://studygolang.com/topics/8289)

[gomonkey 打桩](https://blog.csdn.net/weixin_30337227/article/details/121316675)

模拟 HTTP 服务端、模拟 Redis: [单元测试教程](https://www.liwenzhou.com/posts/Go/golang-menu/)

默认按照单测函数的定义顺序执行（Python 的 unittest 是按照函数名）

```go
package unit

import (
  "reflect"
  "testing"
)

func TestGetPersonDetail(t *testing.T) {
  type args struct {
    username string
  }

  // NOTICE: 构造测试数据
  tests := []struct {
    name    string
    args    args
    want    *PersonDetail
    wantErr bool
  }{
    // TODO: Add test cases.
  }

  for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
      got, err := GetPersonDetail(tt.args.username)
      if (err != nil) != tt.wantErr {
        t.Errorf("GetPersonDetail() error = %v, wantErr %v", err, tt.wantErr)
        return
      }
      if !reflect.DeepEqual(got, tt.want) {
        t.Errorf("GetPersonDetail() got = %v, want %v", got, tt.want)
      }
    })
  }
}
```

## 覆盖率

- [无法获取到覆盖率 `coverage: [no statements]`](https://www.cnblogs.com/l1ng14/p/14145091.html)

- [`-coverpkg 测试跨包代码覆盖率](https://www.cnblogs.com/HuangWj/p/14978365.html)

  ```sh
  # beego 中写 controllers 层测试函数，同时计算 models 的覆盖率
  cd controllers
  go test -v -coverpkg .,../models -coverprofile=c.out && go tool cover -html=c.out -o test.html
  ```

  ```sh
  go test -v -coverpkg ./... -coverprofile=c.out && go tool cover -html=c.out -o test.html
  ```

## 遇到的问题

- **在 beego 的 controllers 写了一些单测代码，而且可以输出覆盖率了，但是向输出 html 的时候报错找不到包**

  ```log
  === RUN   TestDeviceJoin
  --- PASS: TestDeviceJoin (0.00s)
  PASS
  coverage: 5.7% of statements in ./...

  cover: can't find "base.go": cannot find package "_/root/hjj/sources/easydeploy/src/daemon/easydeploy/controllers/" in any of:
  ```

  [相似问题：关于代码覆盖率：在 GVM 中使用 Go 1.2 Cover 工具](https://www.codenong.com/21174766/)

# 调试

# 学习过程中的疑问

- **把文件内大写字母开头的函数当作暴露的函数，这样不好区分哪些接口是暴露的，哪些是私有的。。。**

  要么就专门弄一个文件，写暴露的接口，私有的接口写到另外的包里面

# 其他

- [gopls requires a module at the root of your workspace](https://blog.csdn.net/weixin_45111820/article/details/113097591)

- 左大括号 `{` 必须紧接着语句，不能换行。其他样式的括号将被视为代码编译错误。

- [JSON 解码函数 UNMARSHAL](https://blog.csdn.net/Ming13416908424/article/details/123370426)

- `var test[] int`

- `interface{}`

```go
kv := map[string]interface{}{
  "Ccode": ccode,
  "Type":  devType.Type,
}
```

- [GoLand 2021.1.3 中文注册特别版免费下载](http://www.520rj.com/xiazai/GoLand.html)

- 可以用未知参数，可变参数，不支持关键字参数、默认参数

- 时间戳转时间

  ```go
  func ConvertTime(utime uint64) string {
    format := time.Unix(int64(utime), 0).Format("2006-01-02 15:04:05")
  return format
  }
  ```

- [golang 函数中的参数为什么不支持默认值？](https://www.zhihu.com/question/24368980)
