- [参考文档](#参考文档)
- [Python](#python)
  - [解释器](#解释器)
  - [编译](#编译)
  - [开发环境](#开发环境)
    - [虚拟环境](#虚拟环境)
      - [virtualenv](#virtualenv)
      - [venv](#venv)
      - [pyevnv](#pyevnv)
  - [编码](#编码)
    - [基础知识](#基础知识)
    - [其他](#其他)
  - [基础](#基础)
  - [调试](#调试)
    - [`rpd` 远程调试](#rpd-远程调试)
  - [★ 下划线](#-下划线)
  - [反射](#反射)
  - [命令行参数](#命令行参数)
  - [格式化](#格式化)
- [Python2 和 Python3 的区别](#python2-和-python3-的区别)
  - [Python3 中的 `bytes` 和 `str`](#python3-中的-bytes-和-str)
  - [python2 转 python3](#python2-转-python3)
- [异常处理](#异常处理)
- [其他](#其他-1)

# 参考文档

- [官方文档](https://docs.Python.org/zh-cn/3.7)

- [Python 高并发的详解](https://www.cnblogs.com/daofaziran/p/10154986.html)

- [编写高质量代码改善 Python 程序的 91 个建议](https://l1nwatch.gitbook.io/writing_solid_Python_code_gitbook/di-1-zhang-yin-lun)

- [Python Cookbook](https://Python3-cookbook.readthedocs.io/zh_CN/latest/index.html)

- [Python 中文学习大本营](http://www.pythondoc.com/)

# Python

## 解释器

Python 解释器将源码转换为字节码，然后再由解释器来执行这些字节码

- `解释器的工作原理`

  > 完成模块的加载和链接

  - 将源代码编译为 PyCodeObject 对象(即**字节码**)，写入内存中，供 CPU 读取

  - 从内存中读取并执行，结束后将 PyCodeObject 写回硬盘当中，也就是复制到.pyc 或.pyo 文件中，以保存当前目录下所有脚本的字节码文件

  - 之后若再次执行该脚本，它先检查【本地是否有上述字节码文件】和【该字节码文件的修改时间是否在其源文件之后】，是就直接执行，否则重复上述步骤。

- 程序第一次运行后，工程根目录下生成了一个`__pycache__`文件夹，里面是和 py 文件同名的各种以 `xxx.cPython-35.pyc` 结尾的文件，这些是编译之后的文件

  `cPython-35` `cPython`代表的是 c 语言实现的 Python 解释器，`-35`代表的是版本为 3.5

- `__name__`

  不涉及模块导入的话，`__name__`的值就是`__main__`，如果当此模块被导入引用的话，那么这个模块内的`__name__`值就是文件的名字（不带.py）

  ```py
  # test1.py
  print(__name__) # 输出为  __main__

  # test2.py
  import test1
  print('xxx')
  # 输出为 test1 xxx
  ```

- [离线安装第三方库](https://blog.csdn.net/leechenglove/article/details/80090609)

  - 可以找台能安装的，然后把文件拷贝过去，比如 windows 下包是安装在`C:\Users\sangfor\AppData\Roaming\Python\Python37` 把该路径下两个文件夹放到目标机器相同文件夹下就可以了，可以用 `pip list` 验证

  - 安装 `whl` 包

    `pip install \*\*.whl`（前提是要安装好 pip 和 wheel）

  - 安装 `tar.gz` 包

    cd 到解压后路径，`Python setup.py install`（安装 pip 和 wheel 都可以参照这种方法）

- [头部注释](https://www.cnblogs.com/CoXieLearnPython/p/9185669.html)

  ```py
  #!/usr/bin/env python
  #!/usr/bin/python3
  ```

## 编译

- 手动生成字节码 `.pyc` 文件

  ```sh
  python -c "import compileall; compileall.compile_dir('/path/to/your/source/directory')"
  ```

- [反编译工具](https://blog.csdn.net/zhangmiaoping23/article/details/79045308)

## 开发环境

- [`Python3` 安装](https://www.cnblogs.com/zdqc/p/11788212.html)

- 获取系统环境变量

  ```py
  # environ 是一个字符串所对应环境的映像对象

  import os
  print(os.environ.keys())  # 主目录下所有的key
  print(os.environ) # 显示key+内容
  print(os.environ['GOPATH'])
  # 相当于 echo $HOME
  ```

### 虚拟环境

[Python 虚拟环境 pyenv、venv(pyvenv)、virtualenv 之间的区别](https://blog.csdn.net/lovedingd/article/details/106721585)

> 推荐使用 venv

- `venv` 模块是 Python3.3 之后标准库自带的虚拟环境创建和管理工具，在一定程度上能够替代 virtualenv。但 venv 是 Python3.3 才有的，Python2.X 不能使用

- `virtualenv` 同时支持 Python2.X 和 Python3.X，特别是在当前的生产环境中 Python2.X 还占有很大比例的情况下我们依然需要 virtualenv。

- 尽管 Python 3.7.3 的 bin 目录下依然有 pyvenv 的脚本，但是在打印的 help 信息的第一行明确警告说：这个脚本是过时的，推荐使用 python3.7 -m venv 命令

#### virtualenv

- 创建虚拟环境

  ```sh
  # virtualenv 早就默认这个参数了
  # virtualenv -p /usr/bin/python3 --no-site-packages envdir
  virtualenv -p /usr/bin/python3 envdir

  # 如果想依赖系统环境的第三方软件包，可以使用参数 --system-site-packages
  pip install -r keplrblog/requirements/requirements.txt
  ```

- 打包虚拟环境 `virtualenv`

  修改虚拟环境下的 `envdir/bin/activate`

  ```py
  # 注释或删掉这两句：
  VIRTUAL_ENV="××××"
  export VIRTUAL_ENV
  # 添加：
  export VIRTUAL_ENV=`pwd`
  # 激活的方法略有不同：source bin/active
  ```

#### venv

```sh
apt install python3-venv -y

# 创建虚拟环境
# 默认也是只有 pip 和 setuptools 这两个基础的库

python3 -m venv venvdir

##### 把自己的库加入到环境中 #####

VENV_LIB=$(python3 -c "import site; print(site.getsitepackages()[0])")

ln -s $BASE_PATH/swordfish/swordfish/ $VENV_LIB/
ln -s $BASE_PATH/api_auto/api_auto/ $VENV_LIB/
ln -s $BASE_PATH/sa_api/sa_api/ $VENV_LIB/

##### 获取 python 可执行文件路径

```

#### pyevnv

已废弃旧命令

## 编码

- [用讲故事的方式，带你认识 Python 编码问题的起源和发展！](https://mp.weixin.qq.com/s/BNp6ZVTZwC258QT71iYnCg)

[解决 python2 中 unicode()函数在 python3 中报错的问题](https://www.jb51.net/article/212053.htm)

- [Python 中 `import sys ; reload(sys) ; sys.setdefaultencoding("utf-8")` 的作用](https://blog.csdn.net/yjk13703623757/article/details/105720059)

  - Python2 解释器没法处理非 ascii 编码，此时我们需要设置 Python 默认编码，一般设置为 utf-8 编码格式。在程序中加入以下代码，即可将编码设置为 utf-8。

  - Python3 系统默认使用的就是 utf-8 编码。所以，对于使用 Python3 的情况，就不需要以上代码了，这么做也不会有什么实际意义

  ```py
  import sys
  reload(sys)
  sys.setdefaultencoding("utf-8")
  ```

### 基础知识

- `ASCII`

  127 个字母，也就是大小写英文字母、数字和一些符号

- 设计的时候还好在前面加了一位作为扩展位

- `GB2312`

  中国制定的，用来显示中文的编码集

- `Unicode`

  - `unicode` 编码前面会有个`u`, 比如 `u'xxxxx'`

  - `unicode` 把所有语言都统一到一套编码里

  - `ASCII` 编码是 1 个字节，而 Unicode 编码通常是 2 个字节或更多

- `UTF-8`

  如果全部用 `Unicode` 编码，那么有的英文字母 1 字节就能表示，现在却要用 2 字节，所以把 `Unicode` 编码转化为`可变长编码` 。UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节

- `# -*- coding: utf-8 -*-`

  作用就是为了让 Python 解释器读取源代码时，让它按 UTF-8 编码读取；Python2 默认编码是 ASCII 编码，Python3 编码默认是 unicode 编码

- 在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码

- 和 C 语言不同，C 语言格式化字符串如果不是对应的类型会报错，比如 `%s` 但是给了个整形, `Python` 中无论什么类型都可以用 `%s`

- `chr(66) 和 ord('中')` 编码和字符的转换

### 其他

- `'ABC' 和 b'ABC'` 的区别

  Python 的字符串类型是 str，在内存中是`以unicode表示的`，一个字符对应若干个字节，而比特类型 bytes 的字符都只占用一个字节

  ```py
  '中文'.encode('utf-8')  # str 转 bytes
  b'ABC'.decode('ascii')  # bytes 转 str
  ```

- `len(xx)`

  如果参数是 `str`，则是计算字符数；若是 `bytes` 则是计算字节数

  ```py
  >>> len('中文')
  >>> 2 # 两个字符
  >>> len(b'ABC')
  >>> 3
  >>> len('中文'.encode('utf-8'))
  >>> 6 # 6个字节
  ```

- [加载 py 文件中文出错: `'ascii' codec can’t decode byte 0xe4 in position 0: ordinal not in range(128)`](https://blog.csdn.net/gaoyueace/article/details/80480925)

- `base16` 编码其实就是十六进制

## 基础

- 小整数

  `Python` 内置了一些范围内的数据在内存，这些数字的地址是一样的

  ```py
  >>> a = 11
  >>> b = 11
  >>> id(a)
  34123
  >>> id(b)
  34123
  ```

- `==` 和 `is` 的区别

  `!=` 和 `is not` 同理

  ```py
  # == 比较两个对象或值的相等性。
  # is 运算符用于检查两个对象是否属于同一内存对象。

  # 这里用大整数是为了排除小整数池的影响
  >>> a = 111111111111111111111
  >>> b = 111111111111111111111
  >>> a == b
  True
  >>> a is b
  False
  >>> id(a)
  30586352
  >>> id(b)
  30188325

  >>> lst1 = [1,2,3]
  >>> lst2 = [1,2,3]
  >>>
  >>> lst1 == lst2
  >>> True
  >>>
  >>> lst1 is lst2
  >>> False
  ```

- `not xxx in`、`xxx not in`、`xx != yy`、`xx is not yy`、`xx == yy`、`xx is yy`

  ```sh
  flake8 建议使用 xxx not in 而不是 not xxx in
  ```

- [命令行参数 `argc 和 argv`](https://blog.csdn.net/plutus_sutulp/article/details/7665439)

  ```py
  命令行执行 python test.py 1 2 3

  sys.argv 结果为 ['test.py', '1', '2', '3']
  # 不像 c，有 argc 表示命令行参数个数，需要自己 len(sys.argv)
  ```

- 逻辑符换行

  ```py
  if item.delete_flag == DEV_INFO_NORMAL and \
     item.dhcp_source != DHCP_GENE_BY_IMPORT:
      pass
  ```

- 过滤特定字符

  [python 去除字符串中指定字符](https://blog.csdn.net/zdz0200/article/details/81453367)

  [replace 函数在 python2 中编码格式的转换](https://blog.csdn.net/yangfengling1023/article/details/82663360)

  ```py
  # 去除字符串中所有特定字符
  s.replace('-', '')

  # 取出前后的特定字符
  s.strip('-')
  # 去左右边特定字符
  s.lstrip('-') # s.rstrip('-')
  ```

- `json`

  ```py
  # dumps()返回一个str，内容就是标准的JSON, dump()则直接写入文件

  import json
  d = dict(name='Jack', age=21, score=99)
  with open('json_str.txt', 'w') as f:   # 这里直接以读的形式打开
      json.dump(d, f)

  with open('json_str.txt', 'r') as f:
      test = json.load(f)
  ```

- [类继承 object](https://blog.csdn.net/DeepOscar/article/details/80947155)

  > 实际上在 Python 3 中已经默认就帮你加载了 object 了（即便你没有写上 object）

  - 经典类：不继承 object 对象，只拥有了`__doc__ , __module__ 和 自己定义的变量`, 也就是说这个类的命名空间只有三个对象可以操作.

  - 新式类：继承了 object 对象，拥有了好多可操作对象，这些都是类中的高级特性

- `dict.get('tpl_id', -1) > 0`
  get 方法如果没取到 tpl_id， 则 get 结果为 -1

- `index outof range` 不一定是超过范围，有可能是在遍历一个空列表

- [三元运算符](https://www.cnblogs.com/mywood/p/7416893.html)

  ```py
  >>> a = 1 if 1 > 2 else 0 # 没有冒号
  >>> a
  0
  ```

- [`__init__.py 的作用`](https://www.cnblogs.com/tp1226/p/8453854.html)

- `vars()` 以字典形式列出对象的属性和值

  - `dir` 展示对象的所有属性

  - `vars` 展示对象的所有属性和值

  ```py
  class test:
      name = "huangjinjie"
      age = 25
      _score = 38.13

  print(vars(test))
  print("age: %(age)s, name: %(name)s" % vars(test))
  ```

- [getattr 函数](https://blog.csdn.net/xlengji/article/details/81412899)

  ```py
  # 返回对象的属性
  a = getattr(obj, attr [, default])
  ```

- 尽量避免使用通配符导入

  ```py
  # module.py
  def test():
    pass
  def _test():
    pass

  # test.py
  from module import *
  _test() # Error 通配符导入不会导入前导下划线的名称
  # 还有一个问题是如果多个文件都用通配符导入，会污染名字空间，比如多个文件中定义了相同的方法
  ```

- [`range`为什么是左闭右开](https://blog.csdn.net/hdoj_lin/article/details/78831868)

  ```py
  >>> a = range(3)
  >>> a
  >>> [0, 1, 2]
  >>> b = range(1, 3)
  >>> b
  >>> [1, 2]
  ```

- `Python2` 中的 `xrange` 如何使用

  ```py
  xrange(stop)
  >>> xrange(9) # 得到的是对象
  >>> list(xrange(9)) # 得到的是列表
  >>> list(xrange(3, 5))
  >>> [3, 4] # 和range一样，也是左闭右开的区间
  xrange(start, stop[, step])
  >>> list(xrange(0,6,2)) # 制定步长
  >>> [0, 2, 4]
  ```

- `main` 函数

  [Python 如何写好 main 函数](https://blog.csdn.net/sexgeek/article/details/80677474)

- `sys.exist()`

  - `os._exit()` 直接退出 Python 程序，其后的代码也不会继续执行

  - `sys.exit()` 引发一个 SystemExit 异常，若没有捕获这个异常，Python 解释器会直接退出；捕获这个异常可以做一些额外的清理工作。0 为正常退出，其他数值（1-127）为不正常，可抛异常事件供捕获。exit() 跟 C 语言等其他语言的 exit() 应该是一样的。

- [字符串中的单引号和双引号的区别](https://www.cnblogs.com/utsuro/p/8657817.html)

- `__init__` 函数回去初始化一些类变量，如果想用函数的话，可以把函数写在类外面，在`init`调用

- `unicode` 和 `str`

  因为 unicode 可以保存到类型为 string 的字段里，所以有时候一不小心就拿 unicode 和 str 做比较了

- 空字符串和`None`

  ```py
  # 这种情况无法保存空字符串
  if backup_dns:
    conf.backup_dns = backup_dns

  # ok
  if backup_dns is not None:
    conf.backup_dns = backup_dns

  >>> a = ''
  >>> if a:
  ...     print 'a'
  ...
  >>> if a is not None:
  ...     print 'a'
  ...
  >>> if a is not None and a != '':
  ...     print 'a'
  ...
  ```

- 空列表和 `None`

  ```py
  a = list() #[]
  def test(a=None):
    if not a: #空列表也会进去
      print 'x'
    if a is not None: # 空列表不会进去
      print 'x'
  ```

- [`__dict__ 与 dict(xx)的区别`](https://www.cnblogs.com/zjchao/p/7894477.html)

  - `dir()` 用来寻找一个对象的所有属性，包括 `__dict__` 中的属性，`__dict__` 是 `dir()` 的子集，`dir()`函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。

  - 一个实例的`dict`属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性

  ```py
  class Test(object):
    class_var = 11 # 类变量
    def __init__(self):
      self.name = 'huangjinjie'
      self.age =25

    def _aaa(self):
      pass

    def __aaa__(self):
      pass

    def bbb(self):
      pass

    @property
    def property_var(self):
      return 1000

    def static_func():
      pass

    @classmethod
    def class_func(cls):
      pass

  t = Test()
  # `__dict__` 是一个字典，键为属性名，值为属性值
  # 实例属性 `__dict__` 仅存储与该实例相关的实例属性，所以 每个实例的实例属性才会互不影
  print(t.__dict__)
  """
  {'name': 'huangjinjie', 'age': 25}
  """

  print(Test.__dict__)
  """
  {
    '__module__': '__main__',
    'class_var': 11,
    '__init__': <function Test.__init__ at 0x7fc36689b620>,
    '_aaa': <function Test._aaa at 0x7fc36689b8c8>,
    '__aaa__': <function Test.__aaa__ at 0x7fc36689b950>,
    'bbb': <function Test.bbb at 0x7fc36689b9d8>,
    'property_var': <property object at 0x7fc366a27228>,
    'static_func': <function Test.static_func at 0x7fc36689bae8>,
    'class_func': <classmethod object at 0x7fc3668ab908>,
    '__dict__': <attribute '__dict__' of 'Test' objects>,
    '__weakref__': <attribute '__weakref__' of 'Test' objects>,
    '__doc__': None
  }
  """
  ```

- [`Python2 Python3` 除法的差异](https://www.cnblogs.com/36bian/p/7201363.html)

  ```py
  # Python2
  # 与传统语言(c、c++、java)无异，也是得到整数部分
  >>> 10/3
  >>> 3
  >>> 10//3  # 和 / 一样
  >>> 3

  # Python3
  >>> 10/3
  >>> 3.3333333333333335
  >>> 10//3
  >>>> 3

  # Python2 中 也可以进行精确除法，只需要导入division
  >>> from __future__ import division
  >>> 10/3
  >>> 3.3333333333333335
  ```

- 文件头

  ```py
  #!/usr/bin/env Python
  # 必须在第一行，否则chmod a+x a.py后无法直接./a.py 运行

  #-*-coding:utf-8-*
  ```

- 查看函数解释

  ```py
  >>> help(cmp)
  ```

- `print` 输出语句, 遇到逗号会输出空格

- 从命令行获取数据

  > getopt 或 argparse 模块

  - `sys`

    ```py
    import sys
    sys.argv[1]
    # Python中没有argc来获取命令行参数数量
    argc = len(sys.argv)
    name = input() # 获取输入
    # name = raw_inupt()
    ```

- [`input()` 和 `raw_input()` 的区别](https://blog.csdn.net/weixin_29370665/article/details/89931376)

  ```py
  >>> input("age:")
  age:25                            # 输入的是整型
  25
  >>> input("name:")
  name: huangjinjie                  # 必须用引号输入字符串："huangjinjie"
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<string>", line 1, in <module>
  NameError: name 'huangjinjie' is not defined

  # 对于 raw_input，你输入什么都是字符串，而且不需要输入引号
  >>> raw_input("age:")
  age:25
  '25'
  >>> raw_input("name:")
  name:huangjinjie
  'huangjinjie'
  >>>
  ```

- 字符串

  可以用单引号引起来，也可以用双引号

  ```py
  str_a = 'I am string'
  str_b = "I'm string"
  str_c = "I'm \"string\""
  str_c = """line_1
        line_2
        line_3"""
  ```

- 常量变量名通常用大写，比如 `PI = 3.14159`，这个变量还是可以被改变的，没有语法拦着你

- 除法

  和其他语言一样 `%` 是整除求余，但这里`//` 才是整除求整，`/`结果是浮点数，相当于两个浮点数做除法

## 调试

> 使用方法基本和 `gdb` 基本一样

- 开始

  - 以`Python -m pdb main.py` 运行则会停在第一行

  - 代码中 `import pdb pdb.set_trace()` 则是在当前行设置断点

- 断点

  - `b` 显示断点列表

  - `b 10` 在本 py 文件第 10 行设置断点

  - `b test.py 20`

  - `cl` 删除所有断点

  - `cl 2` 删除第 2 个断点

- `!arg_a` 直接修改`arg_a`的值

- `j 20` 调到 20 行

- `r` return 当前函数

### `rpd` 远程调试

- 使用方法

  ```py
  ...

  import rpdb
  rpdb.set_trace()
  # 运行到这里会在默认端口4444开服务，在终端 tellnet x.x.x.x 4444 即可进行调试
  ...

  ```

- 比如一个 `Flask` 应用，如果使用 Apache 部署，那就需要用到 rpdb 来进行调试，因为即使开了 `app.debug=True`，界面上也不会显示出调试信息的

## ★ 下划线

[Python 中下划线的 5 种含义](https://blog.csdn.net/tcx1992/article/details/80105645)

![s](https://img-blog.csdn.net/20180427113429590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RjeDE5OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 单前导下划线 `_var`

  一种`约定俗成`的写法吧，就像 c++中也会在私有变量前面加一个下划线，表示这是类的成员，一般只是内部可见

- 单末尾下划线 `var_`

  也是一种`编码约定`，约定是如果与关键字冲突，则在后面加下划线区分，比如 `class_`

- 双前导下划线 `__var`

  名称修饰，`解释器更改变量名称，以避免子类中的命名冲突`；有点类似 c++编译出来后的函数符号也是带有前缀来进行区分的

  ```py
  class Test:
    def __init__(self):
      self.__var = 12

  t = Test()
  # 查看对象属性列表, 没有__var，名字变为了 _Test__baz
  dir(t)
  ```

- 双前导和末尾下划线 `__var__`

  如果一个变量同时以双下划线开始和结束，则不会应用名称修饰，即不会被 Python 解释器修改

  这在 Python 关键字中挺多的吧，比如`__init__` 和 `__name__` 感觉像是宏

- 单下划线 `_`

  - 用来当一个占位符，没有意义或者是临时无关紧要的变量

    ```py
    for _ in range(3):
        print 'Hello'
    # 比如ret = (a,b)，则color为b, 第一个位置的值不关心
    _, color = ret
    ```

  - XXX 单下划线还表示解释器评估的最近一个表达式中的结果

    ```py
    >> 1 + 1
    >> 2
    >> _ # 最近表达式的结果，即2
    >> 2
    ```

## 反射

> 反射机制: 让对象告诉我们它的相关信息(对象拥有的属性和方法，对象所属的类，这个类是否有某个属性或者方法等等)

- 反射允许我们`用字符串的方式访问对象的属性`，调用对象的方法

## 命令行参数

- `python -c test.py` 在 `shell` 中执行 `Python` 代码

  ```sh
  # Python 可以把多个语句放在一行内，只要用分号分隔就好了
  # -c cmd的意思
  you_are_ok=$(cat $json_path | python -c "import sys,json; print(json.load(sys.stdin)['are_you_ok']); print('hello world')")
  # False hello world
  ```

- [`Python -u test.py`](https://www.jb51.net/article/151913.htm)

  `Python` 命令加上 `-u（unbuffered）` 参数后会强制其标准输出也同标准错误一样不通过缓存直接打印到屏幕。

- [`Python -m module_name`](https://mp.weixin.qq.com/s/co_OAaVQ49rPfgoAh6Pejw)

  直接执行 `Python xxx.py` 前提是当前路径是 `xxx` 所在的路径，而 `python -m xxx` 解释器会根据 `sys.path` 自行查找名字为 `xxx` 的模块，若找到，则当成脚本执行

  ```py
  echo '{"test": 1}' | python -m json.tool`
  ```

## 格式化

- 知道可以用`%s`来进行格式化，但是如果有很多个参数，就会导致很长，怎么做更优雅呢

  ```py
  content_pattern = 'aaaaaa:%s, bbbbbbb:%s, cccc:%s, dddd:%s, eeeee:%s'
  content = content_pattern % ('1111', '22222', '33333', '44444', '55555')

  # 优雅地做法用dict
  msg_pattern = '\n客户正在申请获取设备订单：\n' \
      '【客户姓名】：%(name)s\n' \
      '【手机号码】：%(phone)s\n' \
      '【公司名称】：%(company)s\n' \
      '【订单号码】：%(order_num)s\n' \
      '【邮箱地址】：%(email)s\n'
  param = {
      'name': 'huangjinjie',
      'phone': '15907877688',
      'company': '中国广东省深圳市',
      'order_num': 'e54323ae232d1',
      'email': '870193518@163.com'
  }
  msg = msg_pattern % param
  ```

- XXX 没见过这样用的

  ```py
  >>> a = "ddddddddd %s ccccccccc"
  >>> a %= "11111"
  >>> a
  >>> ddddddddd 11111 ccccccccc
  ```

- [`format 和 %s`](https://www.cnblogs.com/mianbaoshu/p/12022777.html)

  ```py
  # 普通使用 %s 占位符进行输出，可是当参数多了之后就不清楚哪个参数对应哪个位置了
  print("my name is %s, age is %d" % ("huangjinjie", 25))

  # 使用字典
  print("my name is %(name)s" % {"name": "huangjinjie"})

  # 使用 format，用 {} 来表示占位符
  # 设置指定位置，按默认顺序
  print("{} {}".format("hello", "huangjinjie"))
  # 设置指定位置
  print("{1} {0} {1}".format("hello", "huangjinjie"))

  # 可以使用解列表的方式
  str_input = ["hello", "huangjinjie"]
  print("{} {}".format(*str_input))

  # 可以进行格式化, 冒号表示元素需要进行操作
  print("score: {:.3f}".format(42.1212121))

  # 进行转义
  print("{!r}".format("\r\n"))
  # 输出: \\r\\n
  print("{}".format("\r\n"))
  # 输出: \r\n
  ```

- 用 `f"xxx"` 来格式化

  ```py
  # 适用于3.6以上的Python版本，使用上和 %(arg)s 没啥区别
  # 在同等情况下，优于%s对字符串的处理。
  name = "huangjinjie"
  age = 25
  print(f"name is {name}, age is {age}")
  # 或者 print(f"name is {name}, age is {age}" % dict(name="huangjinjie", age=25))
  ```

- 常见格式化占位符

  | 符号   | 说明                                                         |
  | ------ | ------------------------------------------------------------ |
  | `%s`   | 字符串 `__str__`                                             |
  | `%3s`  | 输出至少 `3` 个字符，不够用空格补全，`正负`表示在前/后补空格 |
  | `%r`   | 字符串 `__repr__`                                            |
  | `%c`   | 单个字符                                                     |
  | `%b`   | 二进制整数                                                   |
  | `%d`   | 十进制整数                                                   |
  | `%i`   | 十进制整数                                                   |
  | `%o`   | 八进制整数                                                   |
  | `%x`   | 十六进制整数                                                 |
  | `%e`   | 指数（基底为 e）                                             |
  | `%E`   | 指数（基底为 E）                                             |
  | `%f`   | 浮点数                                                       |
  | `%.nf` | 浮点数, 保留小数点后 `n` 位，不够在后面补 `0`                |
  | `%n.f` | 浮点数, 同`%ns`                                              |
  | `%F`   | 浮点数，与上相同                                             |

# Python2 和 Python3 的区别

| 说明                                                                                                   | `Python2`                                   | `Python3`                                          |
| :----------------------------------------------------------------------------------------------------- | :------------------------------------------ | :------------------------------------------------- |
| `range()`、`map()`、`filter()`、`zip()` 等函数编程迭代器了，如果要获取列表，需要转一下                 |                                             |                                                    |
| `super()` 子类的初始化变了                                                                             |                                             |                                                    |
| `/` 除号的意义变了                                                                                     |                                             |                                                    |
| `print` 用法变了                                                                                       | 在 py2 是关键字                             | 在 py3 是函数                                      |
| `bytes` 类型没了                                                                                       |                                             |                                                    |
| 多了 `enum` 枚举库                                                                                     |                                             |                                                    |
| 多了 `nonlocal` 关键字                                                                                 |                                             |                                                    |
| `except Exception, e` 不能这样用了                                                                     |                                             |                                                    |
| 对于 `Python2`，`bool` 是 `int` 的子类，不是关键字，因此可以进行赋值 `True = 11`，`Python3` 中就不行了 |                                             |                                                    |
| `Python2` 中默认继承经典类，要显示继承新式类 `object`，`Python3` 则不需要                              |                                             |                                                    |
| `configparser` 模块: `configparser`: 在 `Python3` 中的包名, `ConfigParser`: 在 `Python2` 中的包名      |                                             |                                                    |
| `Python2` 里 `True` 还不是关键字，可以被赋值和计算，在 Python3 中编程关键字了，不能被赋值              |                                             |                                                    |
| `Python2` 里不支持对列表和字典`解包`                                                                   |                                             | `a = list(range(3)); b = ['a', 'b']; c = [*a, *b]` |
| 元类的定义不一样                                                                                       | `class A(object): __meta_class__ = ABCMeta` | `class A(metaclass=ABCMeta): pass`                 |
| 获取中段输入变了                                                                                       | `raw_input`                                 | `input`                                            |

## Python3 中的 `bytes` 和 `str`

- [浅析 Python3 中的 bytes 和 str 类型](https://blog.csdn.net/q389797999/article/details/81301199)

- [Python3 报错：TypeError: a bytes-like object is required, not 'str'](https://blog.csdn.net/weixin_40283816/article/details/83591582)

- [AttributeError: 'str' object has no attribute 'decode' 解决方法](https://blog.csdn.net/qq_43192819/article/details/108981008)

  - Python3 的 str 默认不是 bytes，所以不能 decode，只能先 encode 转为 bytes，再 decode

  - Python2 的 str 默认是 bytes，所以能 decode

- 本来在 `Python2` 中可以不用区分 `bytes` 和 `str` 的，都按 string 处理；`Python3` 中 str 是文本系列，bytes 是字节系列，文本有编码（UTF-8，GBK，GB2312 等）字节没有编码。文本的编码指的是字符如何使用字节来表示组织方式，`linux`下默认都使用`UTF-8`

- `protobuf` 通过 `SerializeToString` 序列化后通过 `socket` 传输，并使用`ParseFromString` 进行解析，由于 Python2 不区分 bytes 和 str，所以运行正常，但是 Python3 中不行，而且 socket 传输必须传入 bytes，所以 SerializeToString 序列化后的数据还要转为 bytes 才可以通过 socket

- 好吧，还是要先冷静分析，想过 protoc 序列化成 bytes，想过序列化后转换成 bytes（这样会乱，因为是 client 先组装数据然后序列化成 str，然后转 bytes，传输给 service，service 再由 bytes 转 str，再解序列化）；其实只要用 **`b'xxx'`**就行了....

  ```py
  def send_data(conn, msg):
      # 前10字节存放msg的长度
      data = b"%10d%s" % (len(msg), msg)
      conn.sendall(data)

  def recv_data(conn):
      data_len_bytes = conn.recv(10).strip()
      data_len = int(data_len_bytes)
      datas = b''
      read_len = 0
      while read_len < data_len:
          recv_data = conn.recv(_RECV_BUF)
          datas += recv_data
          read_len += len(recv_data)
      return datas[:data_len]
  ```

## python2 转 python3

[python2 转 python3](https://blog.csdn.net/zzjxx_/article/details/123805698)

```sh
# 坑，除非你的代码是纯净的 python2，否则不要用
# 因为他会把 print 替换为 print()，如果你代码已经用了 print(xxx) 则会被替换成 print((xxx))
$python /c/Users/sangfor/AppData/Local/Programs/Python/Python37/Tools/scripts/2to3.py -w .
```

# 异常处理

```
IOError：输入输出异常。

AttributeError：试图访问一个对象没有的属性。

ImportError：无法引入模块或包，基本是路径问题。

IndentationError：语法错误，代码没有正确的对齐。

IndexError：下标索引超出序列边界。

KeyError: 试图访问你字典里不存在的键。

SyntaxError:Python 代码逻辑语法出错，不能执行。

NameError: 使用一个还未赋予对象的变量。
```

# 其他

- 查看帮助文档 `print(os.path.__doc__)`

- `int(1.111) = 1` 这可不是转类型，会丢失精度

- `^` 表示异或；`**` 才表示次方

- `Python` 没有 `switch` 语句，不过可以用 `dict` 来做

- Python 对象的内存占用，这个值包括该对象的数值、签名（包括数据类型、参数、调用方式等）等一系列数据所占总内存

  ```py
  import sys
  variable = 30
  print(sys.getsizeof(variable))  # 24
  ```

- 字节占用

  ```py
  def byte_size(string):
      return len(string.encode('utf-8'))

  byte_size('')  # 4
  byte_size('Hello World')  # 11
  ```

- 首字母大写

  ```py
  >>> s = "hello huangjinjie"
  >>> s.title() # 把字符串中每个单词首字母大写
  >>> Hello Huangjinjie
  ```

- XXX `is 和 ==` 的区别

  ```py
  # is 用于判断两个变量引用对象是否为同一个，即【内存 ID】 是否相等
  # == 用于判断引用【变量的值】是否相等

  # 如果对象的类型为整数或字符串且值一样，则 x == y和 x is y 的值为True。（经测试浮点型数值，只有正浮点数符合这条规律，负浮点数不符合）
  # list，tuple，dict，set值一样的话，x is y 则为False；

  ## 整数
  x = 5
  y = 5
  print(x is y)   # True
  print(x == y)   # True
  print(id(x))
  print(id(y))

  ## 字符串
  x = "5"
  y = "5"
  print(x is y) # True
  print(x == y) # True

  ## 列表
  x = [11]
  y = [11]
  print(x is y) # False
  print(x == y) # True

  ## 元组
  x = (111,)
  y = (222,)
  print(x is y) # False
  print(x == y) # True

  ## 字典
  x = {"id": 1, "name": "Tom", "age": 18}
  y = {"id": 1, "name": "Tom", "age": 18}
  print(x is y) # False
  print(x == y) # True

  ## 集合
  x = set([1, 2, 3])
  y = set([1, 2, 3])
  print(x is y) # False
  print(x == y) # True
  ```

- [判断类型，为什么建议用 `isinstance`，不建议用 `type`](https://blog.csdn.net/bitcarmanlee/article/details/85263614?)

  ```py
  # type()不会认为子类是一种父类类型
  # isinstance()会认为子类是一种父类类型
  # 也就是说对于内建的数据类型，二者没啥差别，但是对于自定义的类，就不一样了
  class A:
    pass

  class B(A):
    pass

  isinstance(A(), A) # True
  isinstance(B(), A) # True
  type(B()) is A # False

  a = list()
  isinstance(a, list) # True
  type(a) is list # True
  ```

- 在 `lib/` 下定义了一个类 `Test` 来写业务逻辑，在 `cgi/` 下也定义了一个类 `Test` 提供 cgi 接口，如果我在 `cgi/Test` 引入 `lib/Test` 会报 `Test` 重定义了，除了导入的时候用 `as` 来重命令或者修改名字外还有什么更好的方法吗

  ```py
  from path.to.lib import Test as TestLib

  class Test:
    pass
  ```

- XXX `while/for` 与 `else` 搭配

  当迭代对象`完成所有迭代后且此时的迭代对象为空时`，如果存在 else 子句则执行 else 子句

  没有则继续执行后续代码；如果迭代对象因为某种原因（如带有 break 关键字）提前退出迭代
  则 else 子句不会被执行，程序将会直接跳过 else 子句继续执行后续代码

  ```py
  def Pythonic():
      count = 0
      while count < 10:
          count += 1
          print('do_something...')
      else:
          print('index < 10')

      # 即有一部分逻辑需要在不满足循环条件的时候才执行
      for index in range(0, 10):
          print('do_something...')
          if index == 4:
              break  # 如果没有break这段，则都会执行else块，如果有break段，则认为for循环执行不完整，不会执行else块
      else:
          print('index out of range(0, 10)')
  ```

- XXX [`try ... except ... else ... finally`](https://www.jianshu.com/p/343fe0942b80)

  ```py
  def Pythonic():
    """
    有异常，则进入异常处理代码
    没异常，则进入 else
    无论有无异常，都会进入 finally
    """
    try:
        1 + "s"
    except Exception as ex:
        # 当有异常发生时

        # 如果 return 在 raise 后面，那么raise会直接跳出去，不会执行后面的 return
        # return 2

        # ⭐ 如果不抛出异常，而是 return，最终还是会去执行 finilly
        # 如果 finally 里有 return 语句的话，则返回的是 finally 里的结果
        print(ex)
        raise Exception('raise exception')
    else:
        # 当没有异常发生时
        print 'do_something() run succerss, return in else.'
        return 3
    finally:
        # 无论有没有异常，finally 都会执行
        # 如果有异常，则会先抛出异常
        print 'nomatter what, finally whill be run.'
        return 4
  ```

- 获取函数运行时间

  ```py
  import time
  import timeit
  def do_something():
    pass

  # 运行五次
  print(timeit.timeit(do_something, number=5))
  ```

- 逻辑判断

  ```py
  a = {}
  # 如果a是空，后面的条件不会判断
  if a and a.get('a') == 1:
    print('a')
  ```

- [不建议使用 `assert`](https://blog.csdn.net/lml282518588/article/details/52994313)

  ```py
  assert 1 + 1 == 33
  # 报了个 AssertionError，不知道是那里出错，还不如抛个异常
  ```

- 排序后转化成 dict 会导致乱序

  ```py
  a = defaultdict(int)
  a = {'LOG_QUERY': 609, 'GET_ORG_DHCP_CFG': 211, 'SUBLOG_QUERY': 1, 'CGI_GET_DEVICE_INFO': 3642, 'GET_DEV_STATUS': 7}

  aa = sorted(a.items(), key=itemgetter(1), reverse=True)
  # 此时 aa 是已排序的

  dict(aa)  # Python2 中转化后就又乱序了，Python3 就没这个问题
  # 用 OrderedDict
  from collections import OrderedDict
  od = OrderedDict(aa)
  ```

- 输出当前行号

  ```py
  import sys
  print sys._getframe().f_lineno
  ```

- 根据入参返回，一般都是写一堆 `if else`，可以用 map 来优化

  ```py
  def conver_status_id_to_name(status_id):
      if status_id = 1:
          return "aaa",
      elif status_id = 2:
          return "bbb"
      else:
          return "default"

  def conver_status_id_to_name_pro(status_id):
      return {
          1: "aaa",
          2: "bbb"
      }.get(status_id, "default")
  ```

- 解包

  ```py
  def a():
      return 1, 2

  def b(arg1, arg2):
      print(arg1, arg2)

  b(*a())
  ```

- json

  ```py
  headers = {'typ': 'JWT', 'alg': 'none'}
  # 头部序列化
  headers_json = json.dumps(headers, separators=(',', ':'))
  ```

- [Python 解析 http 报文格式](https://zhuanlan.zhihu.com/p/63708414)

  ```py
  def get_header_from_http(self, request_raw):
    """
    从 HTTP 请求报文中获取 UserInfo 请求头

    :param requeset_raw  请求报文
    """
    from urllib import quote
    header_content = request_raw.split('\r\n\r\n', 1)[0].split('\r\n')[1:]
    result = {}
    for line in header_content:
        k, v = line.split(': ')
        result[quote(k)] = quote(v)
    return resul
  ```

- https://www.jianshu.com/p/43d58b0ccd8b

- `import_patched`

- 把 json 数据一行行写入文件

  ```py
  for cnt in range(1, conf["count"]):
    # 从当前时间开始往前构造，一天数据提交一次
    tm -= conf["per"] * 60
    rows.append(json.dumps({
        "time": tm,
        "cpu": random.SystemRandom().randint(0, 100),
        "ram": random.SystemRandom().randint(0, 100),
        "device_id": self.device_id
    }) + '\n')
    with open(tmp_file, "w+") as fd:
        fd.writelines(rows)
  ```

- get 的时候而是会取到 None 的

  ```py
  >>> a = {'a': None}
  >>> b = a.get('a', '---')
  >>> type(b)
  <type 'NoneType'>
  >>> c = a.get('aa', '---')
  >>> type(c)
  <type 'str'>
  >>>
  ```
