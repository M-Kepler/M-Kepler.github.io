- [参考资料](#参考资料)
- [多进程](#多进程)
- [多线程](#多线程)
- [其他](#其他)
  - [★ GIL 全局解释锁](#-gil-全局解释锁)

# 参考资料

- [Python 高并发的详解](https://www.cnblogs.com/daofaziran/p/101586.html)

- 一直说并发并发，那什么时候才需要上并发呢?

  - CPU 密集型：程序需要占用 CPU 进行大量的运算和数据处理

  - IO 密集型：程序中需要频繁进行 IO 操作，例如读写文件、读写 socket

  - CPU + IO

- [Python 中的进程、线程、协程、同步、异步、回调](https://segmentfault.com/a/1190000001813992)

- [Python 并发编程之线程池 / 进程池](https://www.cnblogs.com/dylan-wu/p/7163823.html)

# 多进程

# 多线程

# 其他

## ★ GIL 全局解释锁

> - [关于 Python 线程的 GIL](https://blog.csdn.net/qq_36853469/article/details/100072902)
> - [不得不知道的点——GIL](https://blog.csdn.net/weixin_41594007/article/details/79485847)

- `问题的引入`

  - 由于 `CPython 解释器`在运行 Python 文件时，`CPython 进程与其运行文件所产生的主进程是一个进程（文件进程相当于 CPython 的一个线程）`

  - 线程的特点是数据资源是共享的，而多个线程又都要共享 CPython 的解释权限，共享意味着竞争，有竞争数据就不安全，所以 CPython 的 GIL 锁（CPython 的一个线程）就产生了

  - 根本作用是，当 Python 文件中的线程想要执行其代码，必须获得 GIL 权限，否则不能执行， 所以 cpu 的多核优势也没有了，除非多开 CPython 解释器或多进程，否则同时只能运行一个线程

- 好在这个问题可以通过一些方法来避免，比如标准库的 `multiprocessing`，或 `numexpr、Cython` 等技术，或分布式计算模型等

- Python 的线程虽然是真正的线程，但是解释器执行代码的时候，有一个 `GIL` 锁，任何 Python 线程执行前，都必须先获得锁，然后每执行 100 条字节码，解释器就制动释放锁，所以，实际上是把所有的线程的执行代码都上锁，只能交替执行，无法发挥多核的优势

- 同一进程中假如有多个线程运行，一个线程在运行 Python 程序的时候会霸占 Python 解释器（加了一把锁即 GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个 Python 解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大
