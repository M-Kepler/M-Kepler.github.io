- [★ 面向对象](#-面向对象)
  - [类](#类)
    - [类变量和实例变量的区别](#类变量和实例变量的区别)
    - [静态方法和类方法的区别](#静态方法和类方法的区别)
    - [魔法方法](#魔法方法)
    - [成员属性](#成员属性)
    - [类装饰器](#类装饰器)
      - [`@classmethod` 和 `@staticmethod`](#classmethod-和-staticmethod)
      - [XXX `@abstractmethod、@abstractproperty` 定义抽象方法](#xxx-abstractmethodabstractproperty-定义抽象方法)
  - [继承](#继承)
  - [多态](#多态)
    - [XXX 重写（覆盖） super](#xxx-重写覆盖-super)
    - [重载](#重载)
  - [MixIn](#mixin)
  - [元类](#元类)
    - [`type` 函数](#type-函数)
- [其他](#其他)

# ★ 面向对象

## 类

- 判断是否是其子类 `issubclass`

- `getattr、hasattr、setattr`

  ```py
  class Foo(object):
    def __init__(self, name):
      self.name = name

  a = Foo('huangjinjie')
  # 判断对象是否拥有特定的属性
  print(hasattr(a, 'name'))

  # 获取对象的属性，如果不存在则返回默认值，不加第三个参数会抛异常
  print(getattr(a, 'name2', 'default_value'))

  setattr(a, 'name', 'suanleba')
  print(getattr(a, 'name'))
  ```

- XXX [属性和方法相同，属性会覆盖方法](https://blog.csdn.net/qq_38599635/article/details/81269336)

  ```py
  class Test(object):
      def __init__(self):
          self.do_get = '1'

      def do_get(self):
          print('a')

  t = Tets()
  t.do_get()  # 报错: TypeError: 'str' object is not callable
  ```

- [设置只读属性](https://www.jianshu.com/p/09349af840d8)

### 类变量和实例变量的区别

- 类变量
  可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）

- 实例变量
  实例化之后，每个实例单独拥有的变量

  ```py
  class Test(object):
      class_var = dict()
      def __init__(self, obj_var):
          self.obj_var = obj_var
  # class_var 和 obj_var 的区别
  a = Test()
  b = Test()
  c = Test
  a.token = {'a': 1}
  b.token = {'b': 2}
  c.token = {'c': 3}

  Tets.token = {'t': 9}
  d = Test()
  e = Test()
  d.token # 输出位 {'t': 9}
  e.token # 输出位 {'t': 9}
  ```

### 静态方法和类方法的区别

- 静态方法可以理解为就是 `普通的独立于这个类的一个函数，只不过放在了这个类的命名空间下`，如果全部都丢全局，代码会很不好理解，结构不清晰

- 类方法虽然也不需要实例化，也是可以直接通过类来调用，好像和静态方法没什么区别，但是 `类方法可以使用类的全局变量`

  ```py
  b = 10
  class a:
    b = 20
    @staticmethod
    def c():
        print(b)
    @classmethod
    def d(cls):
        print(cls.b)

  a.b # 输出 10
  a.c # 输出 20
  a.d # 输出 10
  ```

- XXX 静态方法怎么调用另外一个静态方法，类方法怎么调用静态方法

  ```py
  def b():
    print('global func b')


  class a:

    @staticmethod
    def b():
        print('b')

    @staticmethod
    def c():
        b() # 调用全局的b函数（如果没有全局的b函数，会报：'list' object is not callable）

    @staticmethod
    def d():
        a.b()  # 调用类a命名空间下的b函数

  # 主要还是命名空间的理解
  a.b() # 输出 b
  a.c() # 输出 global func b
  a.d() # 输出 b
  ```

- 有些类的初始化成员要通过函数运算得到

  ```py
  def get_images():
    pass

  class a:
    def __init__(self):
        # 初始化时，通过调用外部方法来获取数据，之所以这样是因为类初始化会先调用__init__，所以把获取数据的函数定义在类外面了；可以用 静态方法来解决
        self.images = get_images()
        # 初始化时通过调用类静态方法来获取数据
        self.images2 = self._get_images_in_a()
    @staticmethod
    def _get_images_in_a():
        pass
  ```

### 魔法方法

[Python 魔法方法指南](https://pyzh.readthedocs.io/en/latest/Python-magic-methods-guide.html)

| 内置成员      | 作用                       |
| :------------ | :------------------------- |
| `__init__`    | 构造函数，在生成对象时调用 |
| `__del__`     | 析构函数，释放对象时使用   |
| `__repr__`    | 打印，转换                 |
| `__setitem__` | 按照索引赋值               |
| `__getitem__` | 按照索引获取值             |
| `__len__`     | 获得长度                   |
| `__cmp__`     | 比较运算                   |
| `__call__`    | 调用                       |
| `__add__`     | 加运算                     |
| `__sub__`     | 减运算                     |
| `__mul__`     | 乘运算                     |
| `__div__`     | 除运算                     |
| `__mod__`     | 求余运算                   |
| `__pow__`     | 幂                         |

- [`__repr__ 和 __str__`](https://blog.csdn.net/FanMLei/article/details/81735884)

  定义类的这两个特殊方法，可以用来改变类的输出

  ```py
  >>> test = CTest()
  >>> test
  >>> # 定义了 __repr__ 则输出该函数，否则输出内存地址
  >>> <__main__.Student object at 0x109afb310>
  >>> print(test)
  >>> # 输出的是 __str__ 方法定义的字符串
  ```

- [遍历类的所有属性](https://blog.csdn.net/weixin_43632687/article/details/124694407)

  ```python
  for attr, value in XcAuth.__dict__.items():
      print(attr, value)
  ```

- `__iter__`

  如果一个类想被用于 `for ... in` 循环，类似 list 或 tuple 那样，就必须实现一个**iter**()方法，该方法返回一个**迭代**对象，然后， Python 的 for 循环就会不断调用该迭代对象的**next**()方法拿到循环的下一个值，直到遇到 `StopIteration` 错误时退出循环

- `__getitem__`

  像 list 那样按照下标取出元素，需要实现 `__getitem__()` 方法

- `__setitem__`

- XXX 类属性魔法方法: `__getattr__`、`__setattr__`、`__delattr__`、`__getattribute__`

  [Python 魔法方法之属性访问](https://www.cnblogs.com/Jimmy1988/p/6804095.html)

  ```py
  class Test:
    def __getattr__(self, key):
        '''访问不存在的属性时调用'''
        print('in __getattr__')
        return self[key]

    def __setattr__(self, key, value):
        '''设置实例对象的一个新属性时调用'''
        print('in __setter__')
        self[key] = value

    def __getattribute__(self, key):
        '''访问类属性前先访问该方法，如果不存在则调用 __getattr__'''
        print('in __getattribute__')
        super().__getattribute__(key)

    def __delattr__(self, key):
        '''删除实例对象的属性时调用'''
        print('in __delattr__')

  t = Test()
  print(t.x)

  '''
  1. 首先访问 __getattribute__() 魔法方法（隐含默认调用，无论何种情况，均会调用此方法）
  2. 去实例对象t中查找是否具备该属性： t.__dict__ 中查找，每个类和实例对象都有一个 __dict__ 的属性
  3. 若在 t.__dict__ 中找不到对应的属性， 则去该实例的类中寻找，即 t.__class__.__dict__
  4. 若在实例的类中也招不到该属性，则去父类中寻找，即 t.__class__.__bases__.__dict__中寻找，如果重载了 __getattribute__又找不到属性，则需要自己执行第4步，否则无法执行 __getattr__
  5. 若以上均无法找到，则会调用 __getattr__ 方法，执行内部的命令（若未重载 __getattr__ 方法，则直接报错：AttributeError)
  '''
  ```

- `__call__`

  一般来说都要先实例化再调用对象的成员函数， 用上`__call__()`之后就可以把实例名当成函数来调用了, 给类创建一个对象，直接通过对象来执行，就会自动去执行类中的 `__call__` 函数

  - 实际上是将一个类重载了 `()`，也就是让一个类也可以像一个函数一样可以拿来调用了

    ```py
    class Test(object):
      def __init__(self):
        print('do something init')

      def __call__(self, *args, **kwargs):
        '''类的实例像函数那样被调用时会调用该函数'''
        print('do something with class')

      def do_something():
        print('do something')

    test = Test() # 把类当成函数直接执行
    test.do_something()  # 一般是这样通过实例来调用成员函数
    test()  # 直接调用实例，执行的就是__call__() 函数
    ```

- `__new__`

  ```py
  class A:
    pass

  class B(A):
    # __new__ 传入类(cls)，__init__方法传入类的实例化对象(self)
    # __new__方法【返回值】就是一个实例化对象
    def __new__(cls):
      '''
      创建一个对象，实例化对象是谁取决于__new__方法,__new__返回什么就是什么
      '''
      print("__new__方法被执行")
      return super().__new__(cls)

    def __init__(self):
      ''' __new__ 方法获取到一个对象后，调用 __init__ 进行初始化'''
      print("__init__方法被执行")

  b = B()
  ```

- `__new__` 方法主要是当你继承一些不可变的 class 时(比如 int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径（元类了解一下）

  ```py
  class MyStr(str):
    def __new__(cls, str_val):
      str_val = str_val.upper()
      return super().__new__(cls, str_val)

    def __init__(self):
      print('__init__')

  >>> a = MyStr("huangjinjie")
  >>> HUANGJINJIE
  ```

- 写一个单例

  ```py
  class Singleton(object)
      """
      实现一个单例类
      """
      __instance = None

      def __new__(cls, val):
          if not cls.__instance:
              cls.__instance = object.__new__(cls)
          return cls.__instance

  a = Singleton('test1')
  b = Singleton('test2')

  # 两个实例的 ID 是一样的
  print(id(a))
  print(id(b))

  a.val = 19
  print(b.val)

  ```

- `callable()函数`

  ```py
  # 可以判断一个对象是否是可调用对象
  >>> callable(Student())
  True

  >>> callable([1, 2, 3])
  False
  ```

### 成员属性

- 绑定属性

  - 动态语言可以在创建类的实例后，给该实例绑定任何的属性和方法

  - 一个实例绑定的方法，对另一个实例是不起作用的，不过可以给类绑定，这样所有实例就都有该属性了

  ```py
  class Test(object):
    pass

  def testfunc():
    pass

  t = Test()
  # 给实例绑定属性
  t.score = 99
  # 给实例绑定方法
  from types import MethodType
  t.testfunc = MethodType(testfunc, s)

  # 给类绑定属性
  Test.age = 24
  ```

- XXX `__all__`列表
  作用是导出`__all__`列表里的类、函数、变量等成员, 否则将导出`modualA`中所有不以下划线开头（下划线开头为私有，默认不导入）的成员，在模块中使用`__all__`属性的好处，是可避免在相互引用时的命名冲突

  ```py
  # a.py
  # __all__ = ['func_in_a']
  def test():
    print('test function in a')

  def func_in_a():
    print('function in func_in_a')

  # b.py
  # __all__ ['func_in_b']
  def test():
    print('test function in b')

  def func_in_b():
    print('function in func_in_b')

  # c.py
  from a import *
  from b import *
  test()  # 此时由于先从a导入，后从b导入，所以最终执行的是b中的test方法
  # 如果在b中定义 __all__ 指明只导出func_in_b 方法，那就不会污染这个名字空间了

  # __all__ 感觉就是个规范，因为不需要导出的成员应该用下划线开始命名，如果遵守这个规定，就没__all__什么事了
  ```

- XXX `__slots__` 限制实例允许添加的属性，一个类不能什么属性都让程序去绑定

  ```py
  # __slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的

  class Student(object):
    # 必须继承object
    __slots__ = (
      'name', 'age'
    ) # 用 tuple 定义允许绑定的属性名称

  class GraduateStudent(Student):
    pass

  g = GraduateStudent()
  g.score = 99 # ok

  s = Student()  # 需要实例化
  s.name = 'huangjinjie'  # ok
  s.other = 4 # 尝试给类绑定不在__slot__中的属性时报错了
  ```

- `@property`

  > [python 中的 property 属性](https://www.cnblogs.com/yunxiaofei/p/11216883.html)

  - `@property`把一个 `getter` 方法变成属性

  - 对于 score 属性，property 创建一个`@score.setter`装饰器，负责把一个 `setter` 方法变成属性赋值

  - 很明显，如果不设置 setter 方法，那这个属性就是只读的了（Python 好像没有对属性访问权限做太多的限制）

  - 绑定属性时，直接把属性暴露出去，没有对属性进行限制，不安全，所以要增加对属性值的检查

  ```py
  class Student(object):
    def get_score(self):
      return self._score

    def set_score(self, value):
      if not isinstance(value, int):
        raise ValueError('score must be an integer!')
      if value < 0 or value > 100:
        raise ValueError('score must between 0 ~ 100!')
      self._score = value

  # 但是有点不好的是设值得的时候需要调用方法，没只直接赋值好
  # 有点像c++语言中私有变量，也是设置和获取通过类函数完成，而不是直接调用
  s = Student()
  s.set_score(99)
  s.get_score()

  # 更Pythonic的做法，使用 @property
  class Student(object):
    def __init__(self):
      self._score = None

    @property
    def score(self):
      return self._score

    @score.setter
    def score(self, value):
      if not isinstance(value, int):
        raise ValueError('score must be an integer!')
      if value < 0 or value > 100:
        raise ValueError('score must between 0 ~ 100!')
      self._score = value
  s = Student()
  s.score = 60 # 实际转化为 s.set_score(60)
  s.score # 实际转化为 s.get_score()
  ```

- `property 函数`

  可以接收 4 个参数，第一个参数对应获取，第二个参数对应设置，第三个参数对应删除，第四个参数对应注释

  ```py
  class Student(object):
    def __init__(self, score=0):
        self._score = score

    def get_score(self):
        print("getting score")
        return self._score

    def set_score(self, value):
        print("setting score")
        if not isinstance(value, int):
            raise ValueError("score must be an integer!")
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value

    def del_score(self):
        print("delete score")
        del self._score

    score = property(get_score, set_score, del_score)

  s = Student(60)
  print(s.score)
  print("=====================")
  s.score = 88
  print(s.score)
  print("=====================")
  del s.score
  ```

### 类装饰器

#### `@classmethod` 和 `@staticmethod`

> - 从作用域角度去考虑就行了
> - [Python 中@classmethod @staticmethod 区别](https://www.cnblogs.com/wangyongsong/p/6750454.html)

- 实例化对象就是说要执行 `__init__` 方法，类方法或静态方法则不需要；通常用 self 来传递当前类对象的实例，cls 传递当前类对象

- [`从self、cls看Python的实例化`](https://www.jianshu.com/p/55f1c8f07b66)
  - 实例方法的第一个参数是 self，类方法的第一个参数是 cls, 和 staticmethod 一样，可以直接用类名调用，不需要实例化
  - self 表示一个具体的实例本身。如果用了 staticmethod，那么就可以无视这个 self，将这个方法当成一个普通的函数使用

```py
class Test(object):
    # 类静态变量，类变量
    name = 'huangjinjie'
    def __init__(self):
        pass

    def method(self):   # 普通方法，第一个参数shell表示实例本身
        print(self.name)
        print(self.sttic_method())    # 普通方法也可以调用类里的静态方法

    @staticmethod
    def static_method1():    # 静态方法，作用于只在这个类里面，外部需要通过 类名.函数名 来调用
        obj = Test()    # 静态方法调用普通方法，需要先创建一个实例
        print(Test.class_method())    # 静态方法调用类方法，需要传入类本身
        print(obj.name)
        print(obj.method())
        print(Test.static_method2())    # 调用其他静态方法，加上类名是因为这个静态方法在该类的作用域下

    @staticmethod
    def static_method2():
        pass

    @classmethod
    def class_method1(cls):    # 类方法，第一个参数是类本身，外部需要通过 类名.函数名 来调用
        obj = Test()
        print(obj.method())
        print(cls.name)    # 类方法调用类成员
        print(static_method())
        print(cls.class_method2())    # 类方法调用其他类方法

    @classmethod
    def class_method2(cls):
        pass

class SubTest(Test):
    def __init__(self):
        SubTest.class_method1()    # 子类可以直接调用，可以认为是子类继承了父类的这些方法
```

#### XXX `@abstractmethod、@abstractproperty` 定义抽象方法

- [Python 强制子类重新实现父类方法](https://blog.csdn.net/weixin_33726318/article/details/92444450)

- [Python：父类指定子类继承后一定要实现的方法](https://blog.csdn.net/caoxinjian423/article/details/83268457)

- [在 Python 中定义和使用抽象类的方法](https://www.jb51.net/article/87710.htm)

- 这是 Python 标准库 abc 中的一个强制机制,在 abc 模块中.这个强制触发异常不是在调用那个方法时，而是子类实例化时

  - 不过这种有两个要求 `__metaclass__` 必须为 ABCMeta

  - 方法必须加 `abstractmethod` 修饰

```py

from abc import ABCMeta, abstractmethod, abstractproperty


class SixPy(metaclass=ABCMeta):  # Python3 才支持这种写法
    __meta_class__ = ABCMeta     # pytho2 和 Python3 都支持的一种写法
    pass


class Tester(metaclass=ABCMeta):
    """ 抽象类
    本类只能被继承，不能实例化；
    """
    def __init__(self,name,rank,salary):
        self.name = name
        self.rank = rank
        self.salary =salary

    def __str__(self):
        return "('{name}','{rank}',{salary})".format(**vars(self))

    @abstractmethod
    def test(self):
        """ 定义子类必须实现的抽象方法
        """
        pass

    @abstractproperty
    def value(self):
        """ 定义子类必须拥有的抽象属性
        """
        pass

class Test():
    def test(self):
        print('必须重写抽象方法')

    @property
    def value(self):
        print('必须重写抽象属性')
```

## 继承

- `object`类
  - 在 Python3 中继不继承没啥区别
  - 在 Python2 中，继承的是新式类，未继承的是经典类；继承后会多很多内置的方法可使用，比如 `__dict__`
  - [Python 的 class(类) 中继承 object 与不继承的区别](https://blog.csdn.net/qq_27828675/article/details/79358893)
  - [Python 为什么要继承 object 类？](https://www.runoob.com/note/28629)

## 多态

### XXX 重写（覆盖） super

- [Python 类继承的重写和 super](https://www.cnblogs.com/anovana/p/8142686.html)

- [你不知道的 `super`](https://segmentfault.com/a/1190000007426467)

- `super()`

  ```py
  class Base(object):
    def __init__(self, name):
      self.name = name

  class Child(Base):
    def __init__(self, name, age):
      # 父类构造函数初始化
      # Python2 写法 https://www.runoob.com/Python/Python-func-super.html
      super(Child, self).__init__(name=name)
      # Python3 写法
      # super().__init__(name=name)
  ```

- `mro` 列表

  ```py
  class Base(object):
      def __init__(self):
          print("enter Base")
          print("leave Base")

  class A(Base):
      def __init__(self):
          print("enter A")
          super().__init__()
          print("leave A")

  class B(Base):
      def __init__(self):
          print("enter B")
          super().__init__()
          print("leave B")

  class C(A, B):
      def __init__(self):
          print("enter C")
          super().__init__()
          print("leave C")

  c = C()

  # Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序
  C.mro()
  # [__main__.C, __main__.A, __main__.B, __main__.Base, object]
  # 子类永远在父类前面，有多个父类，就按照列表中的顺序检查，优先选择第一个父类

  """
  继承关系：
       Base
        /  \
       /    \
      A      B
       \    /
        \  /
         C

  输出结果是：
  enter C
  enter A
  enter B    # 如果说 super 是调用父类的方法，那么这里应该进入的是 Base
             # 实际上 super 和继承没啥关系，，，他就记录一下方法调用顺序
             # 单继承的时候恰巧取到父类方法而已
  enter Base
  leave Base
  leave B
  leave A
  leave C
  """
  ```

### 重载

- [Python 中的重载](https://blog.csdn.net/qq_37049781/article/details/83959365)

- 回顾下重载，即函数名相同，但是参数不一样

  - 在一些静态语言中，大都存在有一个重载的概念。这是在 OOP（面对对象编程）中一个必不可少的一个行为。
  - 所谓重载，就是多个相同函数名的函数，根据传入的参数个数，参数类型而执行不同的功能。所以函数重载实质上是为了解决编程中参数可变不统一的问题。

- Python 是一门动态语言，不需要声明变量类型，函数中可以接受任何类型的参数也就无法根据参数类型来支持重载

- `Python 没有必要去考虑参数的类型问题`，这些都可以在函数内部判断处理，并无必要去在写一个函数。Python 有多种传参方式，默认参数 / 可变参数 / 可变关键字参数可以处理函数参数中参数可变的问题

## MixIn

> 在学习之前，先了解一下 鸭子类型

## 元类

- [Python 元类理解](https://www.cnblogs.com/DragonFire/p/6764125.html)

- [深入理解 Python 中的元类(metaclass)](https://www.cnblogs.com/JetpropelledSnake/p/9094103.html)

- [廖雪峰 - 元类](https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072)

- 元类可以用来定义类创建时的一些操作

- 元类也是继承自类的鼻祖 `type`

- 照这么不必要用元类，类继承也可以自己创建一个类，然后添加自己需要的属性， -- 不是这样的，元类是实例化类用的，元类不应该包含自身的属性

- 不同版本使用元类的差异

  ```py
  # Python2.7 使用元类
  class Foo(object):
    __metaclass__ = Singleton

  # Python3 使用元类
  class Foo(metaclass=Sington):
    pass
  ```

- 例子

  ```py
  class MetaClass(type):
      '''
      :desc 元类必须继承自 type
      '''
      def __new__(cls, name, bases, attrs):
          '''
          :desc 创建类实例
          :param cls   即将创建出来的类
          :param bases 即将创建的类所继承继承的父类集合
          :param attrs 即将创建的类的属性
          '''
          if name == 'Model':
              '''
              # 因为Model类是基类，所以排除掉，如果你print(name)的话，会依次打印出Model,User,Blog，即
              # 所有的Model子类，因为这些子类通过Model间接继承元类
              '''
              return type.__new__(cls, name, bases, attrs)

          print('creating module: %s' % name)

          mappings = dict()  # 用来存储即将创建的类的字段和映射
          fields = list()    # 用来存储即将创建的类的字段
  ```

### `type` 函数

- [Python 中的 type 和 object 详解](https://www.cnblogs.com/busui/p/7283137.html)

- XXX 一个类没有声明自己的元类，默认他的元类就是 `type`，除了使用元类 `type`，`用户也可以通过继承 type 来自定义元类`

- type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过 type()函数创建出 Hello 类，而无需通过 class Hello(object)...的定义

  ```py
  class test():
    pass

  a = test()
  print(type(a))
  # >>> <class '__main__.test'>
  print(type(test))
  # >>> <class 'type'>
  ```

# 其他
