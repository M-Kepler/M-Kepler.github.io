- [参考资料](#参考资料)
- [★ 迭代器](#-迭代器)
  - [自定义一个迭代器](#自定义一个迭代器)
- [其他](#其他)

# 参考资料

# ★ 迭代器

- 可以被 `next()` 函数调用并不断返回下一个值的对象就叫做 `可迭代对象`，生成器也可以用 `next` 去迭代，所以其实生成器也是个迭代器。

- 含有 `yield` 的是生成器， `生成器只能读一遍就空了`， 下次读时会报错

- 迭代器 ==必须实现 `__iter__` 和 `__next__`== 两个方法；包含 `__next__` 的可迭代对象就是迭代器，可用来进行迭代（普通讲迭代就是遍历...）

- 可迭代对象，迭代器，生成器的区别

  ![alt](https://img-blog.csdn.net/20170516000644044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamluaXhpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

  - 可迭代对象包含迭代器

  - 如果一个对象拥有 `__iter__` 方法，其是可迭代对象

  - 如果一个对象拥有 `next()` 方法，其是迭代器

  - 定义可迭代对象，必须实现 `__iter__` 方法；定义迭代器，必须实现 `__iter__和 next()` 方法

**`next` 函数**

函数接收一个`迭代器 Iterator 作为参数`，每次调用则获取生成器的下一个值，那就奇怪了，定义 `__next__` 跟 `next()` 函数调用有什么关系？（python2 是 `next` 方法，python3 是 `__next__` 方法）

```py
class test(object):
    def __aaa__(self):
        print('in')

def aaa(obj):
    obj.__aaa__()

t = test()
# 执行了 __aaa__ 函数
# 了解鸭子类型就不会奇怪了
# aaa 函数规定，必须实现 __aaa__ 方法，只要你实现了，我就认你
aaa(t)
```

**`可迭代对象`**

可以直接作用于 for 循环的对象统称为可迭代对象 `Iterable`，可迭代对象并非就是迭代器，比如 list、dict、str 等，不过可以通过 `Iter(list)` 来转换。所以用 **`for`** 来遍历其实也可以用 `next` 来实现遍历

- `Iterator` 的计算是惰性的，只有在需要返回下一个数据时它才会计算，和列表、字典、字符串这些的值都是确定好的不同

## 自定义一个迭代器

按照迭代器协议必须实现两个关键的方法 `__iter__` 和 `__next__`

```py
class TestRange():
  def __init__(self, start, end):
      self.value = start
      self.end = end

  def __iter__(self):
      """
      作用就是返回自身
      """
      return self

  def __next__(self):
      """
      作用是返回下一个迭代应该得到的值
      """
      if self.value >= self.end:
          # for 循环会破获这个异常，然后退出循环
          raise StopIteration
      cur = self.value
      self.value += 1
      return cur

if __name__ == "__main__":
    test = TestRange(5, 12)
    for item in test:
        print(item)
    next(test) # raise error
```

# 其他
