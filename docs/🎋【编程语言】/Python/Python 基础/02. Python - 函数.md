- [函数](#函数)
  - [尾调用优化](#尾调用优化)
  - [函数参数](#函数参数)
  - [参数传递是值传递还是引用传递](#参数传递是值传递还是引用传递)
  - [★ 高阶函数](#-高阶函数)
    - [`lambda`](#lambda)
    - [`map`](#map)
    - [`reduce`](#reduce)
    - [`filter`](#filter)
    - [`zip`](#zip)
  - [偏函数 `partial`](#偏函数-partial)
  - [`any / all`](#any--all)
- [其他](#其他)

# 函数

## 尾调用优化

> 在函数最后一步调用另一个函数（最后一行并不等于最后一步）

## 函数参数

[函数参数](https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888)

> checklist: 尽量使用命名关键字参数，使用位置参数会出现位置错位的情况

- 这样都行，还是别吧

  ```py
  def a(arg1, arg2=None):
      print(arg1, arg2)

  a(1)
  # 1, None
  a(1,)
  # 1 None
  a(1, 2)
  # 1, 2
  ```

- 函数参数是值传递还是引用传递

  ```py
  # 不可变参数，比如字符串，整型等是值传递
  # 可变的参数，比如list等是引用传递
  ```

- [默认参数](https://zhuanlan.zhihu.com/p/45745496)

  - 函数默认参数被检测到 `Dangerous default value [] as argument (dangerous-default-value)`

    列表默认值最好用 None，在判断若为 None, 再赋值空列表 `[]`

  - [Python 进阶 - 函数默认参数，特别是参数传递为空列表](https://blog.csdn.net/xun527/article/details/80658773)

    ```py
    # def test(arg=[]):  # ERROR
    # def test(arg=list()):  # ERROR
    def test(arg=None):
        for i in arg or []:
            print(i)
    ```

  - 列表`默认参数不能用[]`，默认参数必须指向不变对象

    参数默认值是在函数编译阶段确定的，而不是在运行阶段。之后所有的函数调用时，如果参数不显式赋值，那么所谓的参数默认值不过是一个指向那个在 compile 阶段就已经存在的对象的指针,函数修改了对象，默认值就被修改。

  - 当该函数被定义时，一次性生成一个 list 作为默认参数，后面每次成功调用都是使用的第一次生成的那个 list。

  - Python 的`默认参数只在函数被定义时生成一次，而非每次调用时生成`。这就意味着如果你使用可变默认参数并改变它，所有调用该函数的结果都是这个可变对象

  ```py
  def test(data=[]):
      data.append(1)
      return data

  print(test())
  # >>> [1]

  print(test())
  # >>> [1, 1]

  print(test())
  # >>> [1, 1, 1]

  # 正确做法
  def test2(data=None):
      if data is None:
          data = []
      data.append(1)
      return data
  print(test2())
  print(test2())
  ```

- 位置参数

  参数要按照定义时的位置入参

- 变长参数 `*args`

  可以用列表，`args 是一个tuple`，只是定义的时候加`*`星号，实际使用和普通列表没差别

  ```py
  def test_var_args(f_arg, *args):

    print("first normal arg:", f_arg)

    for arg in args:
        print("another arg through *args:",arg)

  test_var_args('yasoob','python','eggs','test')

  def test1(arg1):
      print(arg1)

  def test2(arg1, arg2, arg3):
      print("arg1: %s, arg2: %s, arg3: %s" % (arg1, arg2, arg3))

  arg1 = 1
  arg2 = 2
  arg3 = 3

  func = test1
  arg = [arg1]
  func(*arg)

  func = test2
  arg = [arg1, arg2, arg3]
  func(*arg)

  ```

- 关键字参数 `**kwargs`

  - 可以指明参数赋给那个入参 `test(a=1, b=2)` 此时 a 和 b 的位置不需要和定义时一样

  - 关键字参数实际是字典， `def test(**kwargs)` 可以接受 `{a=1, b=2, c=3}` 这样的字典入参

- XXX 命名关键字参数

  - 和普通参数直接拿用星号分开，如果前面有了变长参数，也可以不加这个星号，`def test(a, b, *, c, d)` 指定只能传特定 `key` 参数

  - 和 `def test(a,b,c,d)` 的区别是 c 和 d 入参必须是 k-v 形式。 即 `test(10, 20, c=11, d=21)` 当然也可以指定 a、b 的参数 `test(b=10,a=20,c=11,d=21)`

- [参数注释和返回值注释 `:str`](https://www.cnblogs.com/Stitchez/p/10006519.html)
  并没有指定类型 只是写函数的人`提醒用函数的人最好传什么类型的参数`，否则可能在函数处理过程中会抛出异常

  ```py
  # 后面eggs: str = 'eggs' 意思是提示传入字符串，默认值是 'eggs'
  def f(ham: str, eggs: str = 'eggs') -> str :
    """
    刚开始我也以为是指定参数类型和返回值类型（这有点像c++11）
    但是Python是弱类型，变量没有固定类型的
    """
    # __annotations__ 是函数的参数注释和返回值注释
    print("Annotations:", f.__annotations__)
    print("Arguments:", ham, eggs)
    return ham + ' and ' + eggs

  print(f("test","abc"))
  ```

## 参数传递是值传递还是引用传递

> 引用传递

- 都是引用，对于不可改变的数据类型来说，不能改变，如果修改了，事实上是新建一个对象来对待。或者说 Python 中有可变对象（比如列表 List）和不可变对象（比如字符串）

- 在参数传递时分为两种情况：

  - 对于不可变对象作为函数参数，相当于 C 系语言的值传递

  - 对于可变对象作为函数参数，相当于 C 系语言的引用传递

- 传值方式等价于 Python 赋值号(=)，但不应该说是浅拷贝

  以 list 为例，浅拷贝可变对象时(如 list)，会创建一个新的 list 对象，并让新对象内部的每一个元素指向原对象每个元素指向的元素；而赋值号将不会创建新对象，而是直接创建一个引用连接到原对象。函数传值是后者，可以写一个函数，在函数里面打印传入参数的 id()，与原值的 id()是一样的，因此是直接赋值而不是浅拷贝。

## ★ 高阶函数

- 别老搞混这几个高阶函数会不会改变原变量了

  ```py
  # sorted 不改变原序列
  test = {1: 3, 2: 2, 3: 1}
  test2 = sorted(test.items(), key=itemgetter(1))
  aa = [-1, 3, 0, 2]
  aa.sort()  # 对 **原列表** 进行排序，会改变原列表顺序

  # lambda
  lambda_test = lambda x, y: x + y
  lambda_test(1, 2)

  # map 不改变原序列
  map_test = [1, 2, 3]
  map_test_new = map(str, map_test)
  # 像这种添加进去的
  aa = []
  map(lambda x: aa.append(x), map_test)
  # aa = [1, 2, 3]

  # reduce 不改变原序列
  reduce_test = [1, 2, 3, 4, 5]
  reduce_test_sum = reduce(lambda x, y: x + y, reduce_test)

  # filter 不改变原序列
  filter_test = [-1, 0, " ", 1, 2]
  filter_test_new = filter(None, filter_test)
  ```

### `lambda`

- 好像不支持两个参数, 没这样的限制

  ```Python
  a = {"a": 1, "b": 2}
  b = {}
  # map(lambda x, y: b.update({x: y}), a.items())  # ERROR
  map(lambda x: b.update({x[0]: x[1]}), a.items())  # OK

  multi = lambda x, y: x * y
  multi(3, 2)
  ```

- `lambda` 匿名函数

  冒号前面的 x 表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果

  ```py
  print(list(map(lambda x: x*x, [1, 2, 3, 4,])))
  ```

- 匿名函数里不能修改外部变量

  ```py
  a = list(range(3))
  ret = {}
  # map(lambda x: ret[x] = str(x), a)
  # 报错: lambda 表达是中不允许赋值 SyntaxError: lambda cannot contain assignment

  # 可以换成这样
  # Python2 这里的ret就更新成 {0: '0', 1: '1', 2: '2'}
  map(lambda x: ret.update({x: str(x)}), a)

  # Python3 返回的是一个生成器
  c = map(lambda x: ret.update({x: str(x)}), a)
  list(c)
  # 这时候 ret 才会更新成 {0: '0', 1: '1', 2: '2'}
  ```

### `map`

- 就像一个加工厂，第二个参数（列表）里的所有成员都被送进第一个参数（函数）进行计算，每个被改造过的元素有组装回一个列表

  ```py
  test_list = [1,2,3]
  # 如果是转换类型的话，第一个参数直接用类型名就行了，不用lambda
  # map(lambda x: str(x), test_list)
  map(str, test_list)
  # ['1', '2', '3']

  def my_print(param):
      print(param)
  map(my_print, test_list)
  """
  # 对于Python2，会把test_list每一个元素过一下my_print函数
  1
  2
  3
  [None, None, None]
  """
  # 返回值
  a = map(func, list)
  # 其实在Python2中是可以正常运行的，不过在py3中改为返回迭代器了，所以语法检测会报错
  a[0] # 会报 Value 'a' is unsubscriptable
  # 对于Python3，返回的是个迭代器，需要做一下转换 list(map(my_print, test_list))
  ```

### `reduce`

- 就像把展开的链条滚起来，第二个参数（列表）里`一次取两个元素`放到第一个参数（函数）里进行操作，计算结果再和下一个元素进行操作，最终就像滚链条一样得到一个数

  ```py
  # Python3后需要从functools导入
  from functools import reduce

  # func不仅仅是计算，就看这个函数怎么做的了
  ret = reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数
  ```

- 坑：如果只有一个元素的话，不会进入到函数中处理

  ```py
  from functools import reduce
  test = ['1']
  print(reduce(lambda x, y: int(x) + int(y), test))

  # reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为0，计算：
  print(reduce(lambda x, y: int(x) + int(y), test, 0))
  sum(test) # 不就解决了。。。。
  ```

- 想把元素为字典的列表按某个元素值进行计算

  ```py
  ret = 0
  test = [
    {'traffic': 11111, 'other': 'a'},
    {'traffic': 22222, 'other': 'b'},
    {'traffic': 33333, 'other': 'c'},
  ]
  # ret += reduce(lambda x, y: int(x['traffic']) + int(y['traffic']), test, 0)
  # ERROR 报错，因为ret是整形，reduce是把第一次计算后的结果作为第一个参数继续参与计算

  # 第一次计算后ret为整形，第二次计算的时候，x其实是ret，对整形做取值操作，直接报错了
  # 可以看出需要reduce的返回值和参数是一个类型才行，要不然操作就会有问题
  # 如果列表元素只有是 [{k: v}, ...] 这种只有一个键值对的好说，因为 x.values()就得到列表了

  """只能遍历两次了"""
  ret = 0
  traffics = [x['traffic'] for x in test]
  print(reduce(lambda x, y: int(x) + int(y), traffice, 0))
  ```

### `filter`

- 当 `filter` 第一个参数为 `None` 时

  ```py
  def compact(_list):
      # 如果第一个参数为None的话，则默认会去除序列中所有值为假的元素
      # return list(filter(None, _list))
      # Python2 返回的是列表
      return list(filter(bool, _list))
  compact([{}, [], 0, 1, False, 2, '', 'a', None])
  [1, 2, 'a']
  ```

- 和 `map()`类似，也接收一个函数和一个序列。不同的是，`filter 根据返回值是否是True来决定是否保留该元素`

  ```py
  filter(is_primes, [1,2,3])
  test =[
    {
      'id': 1,
      'start_ip': '192.168.10.0',
      'latest_subnet': '192.168.10.224-192.168.10.239',
      'mask': 24,
      'org_id': 1,
      'status': 0
    },
    {
      'id': 2,
      'start_ip': '128.10.0.0',
      'latest_subnet': '128.10.0.0-128.10.0.15',
      'mask': 16,
      'org_id': 1,
      'status': 2
    },
    {
      'id': 3,
      'start_ip': '18.11.0.0',
      'latest_subnet': '0.0.0.0-0.0.0.0',
      'mask': 16,
      'org_id': 1,
      'status': 1
    }
  ]

  # 过滤掉列表中状态为2的
  filted_test = filter(lambda x: x.get('status') != 2, test)

  # 也可以按两个字段过滤
  filted_test = filter(lambda x: x.get('status') != 2 and x.get('id') not in test_pools, test)
  ```

### `zip`

> 把可迭代对象打包成一个元祖，然后返回由这些元祖组成的对象

- 把列表/字典解开

  ```py
  a = [1, 2, 3]
  b = ['a', 'b', 'c']
  c = [*a, *b]  # 只在 Python3 有效
  # [1, 2, 3, 'a', 'b', 'c']

  aa = {'a': 1, 'b': 2}
  bb = {'aa': 11, 'bb': 22}
  cc = {**aa, **bb}   # 只在 Python3 有效
  # {'a': 1, 'b': 2, 'aa': 11, 'bb': 22}
  ```

- 把列表合并，并创建一个元组对的列表

  ```py
  array = [['a', 'b'], ['c', 'd'], ['e', 'f']]
  transposed = zip(*array)
  # [('a', 'c', 'e'), ('b', 'd', 'f')]
  ```

- 当传入参数的长度不同时，能自动`以最短序列长度为准`进行截取

  ```py
  >>> l1 = [1, 2, 3]
  >>> l2 = ['a', 'b', 'c']
  >>> zipped = zip(l1, l2)
  >>> zipped # 压缩
  >>> [(1, 'a'), (2, 'b'), (3, 'c'))]
  >>> zip(*zipped) # 解压缩
  >>> [(1, 2, 3), ('a', 'b', 'c')]
  >>> # 字典和元祖列表互转
  ```

## 偏函数 `partial`

> - 改变原有默认值参数的默认值
> - 给原来没有默认值的参数增加默认值
> - 如果我们使用一个方法`总是需要默认几个参数的话`，可以先封装，不用每次都设置相同的参数，通过设定参数的默认值，可以降低函数调用的难度

- 之前看代码总看到有的函数啥也不做，就仅仅去返回另一个函数

  ```py
  def test2():
      return test1(def_arg=2)
  ```

- 偏函数的作用等价于上面的这种写法

  ```py
  from functools import partial

  def test(arg1, arg2):
      print(arg1, arg2)

  test2 = partial(test, arg2=33)  # 相当于定义
  test2(1) # 调用
  # 输出 1 33
  ```

## `any / all`

- `any(x)` x 中任何一个元素不为`0、''、False、None`，则返回`True`

- `all(x)` x 中的所有元素都不为 `0、''、False、None` 则返回`True`

  其实这里的都为/都不为和 `if` 的判断一样的

  只能用来判断列表或者元祖，如果是字典就不行，不过用 `dict_test.values()` 不就得到列表了？没啥区别

```py
# Not Pythonic
test = [12.12, 12.23123, 23.12]
for v in test:
if 0.0 == v:
    return False
return True

# Pythonic
return all(test)
```

# 其他

- 链式调用

  ```Python
  class WordCloud:
    pass

  def myWord(a: int = 1) -> WordCloud:
      # 链式调用外部需要加 ()
      c = (
          WordCloud()
          .add("",words,word_size_range=[20,100])
          .set_global_opts(title_opts=opts.TitleOpts(title="标题"))
      )
      return c
  ```

![68个内置函数](https://mmbiz.qpic.cn/mmbiz_png/qX7rSBgoEp0VlGI5VaKnmibMpb5UHibbu0xbl39aNebbG9ubZBawxAPFLAwj2p0w1Wd5sackApA3yAcVF5oDlc2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
