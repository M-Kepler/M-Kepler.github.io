- [参考资料](#参考资料)
- [数据类型](#数据类型)
  - [动态类型](#动态类型)
  - [鸭子类型](#鸭子类型)
  - [深浅拷贝](#深浅拷贝)
  - [浮点数](#浮点数)
  - [字符串](#字符串)
- [列表、字典、集合、元组](#列表字典集合元组)
  - [列表](#列表)
    - [基本操作](#基本操作)
    - [使用记录](#使用记录)
  - [元组](#元组)
  - [字典](#字典)
    - [基本操作](#基本操作-1)
    - [使用记录](#使用记录-1)
  - [集合](#集合)
- [类型转换](#类型转换)

# 参考资料

# 数据类型

- 可重用整数（小整数）

  `id()` 函数额可以查看对象所在内存地址，借此来判断两个变量是否应用的是同一个地址的值

  ```py
  >>> 1 + 1 is 2
  True
  >>> id(1 + 1)
  140736545899904

  >>> id(2)
  140736545899904

  # 可以看到下面的id是不一样的，但是上面 1+1 和 2 却一样
  # 对于这种行为的解释就是Python当中有一个小整数集合，代表了最开始的几百个整数，并且会重利用这些整数以节省内存和对象创建。更加令人疑惑的就是，不同的Python版本对于 小整数 的定义是不一样的

  >>> 999 + 1 is 1000
  False
  >>> id(999 + 1)
  140736546273064

  >>> id(1000)
  140736546273184
  ```

- 通用函数

  ```py
  cmp(obj1, obj2) # 元素比较
  len(obj) # 求元素个数
  max(obj) # 求最大值 dict 则取key最大值
  min(obj) # 求最小值
  ```

## 动态类型

`Python` 的变量不用声明，赋值之后就可以直接使用，`类型是在运行过程中自动确定的`，这就是动态类型模型, `Python` 是动态类型语言

## 鸭子类型

- 对于 `Python` 来说，只要你的类型提供了我需要的接口，那么就可以完成我提供的功能，这就是所谓的 `鸭子类型`，"长得像鸭子，走路像鸭子，那就当它是鸭子"

- `Python` 中只要元素类型包含 `__cmp__` 方法，并且目标序列可迭代，即包含 `__iter__` ，那就满足了 `可排序` 的要求，可以直接通过 `sorted` 来进行排序；`sorted` 内部在排序过程回去调用 `__cmp__` 方法，并通过迭代器协议的接口来完成遍历

## 深浅拷贝

- `Python` 存储变量的方法跟其他 OOP 语言不同。它与其说是把值赋给变量，不如说是`给变量建立了一个到具体值的 reference`；Python 中 `a = something 应该理解为给 something 贴上了一个标签 a`。当再赋值给 a 的时候，就好象把 a 这个标签从原来的 something 上拿下来，贴到其他对象上，建立新的引用；（或者也可以理解为只是个指针指向）

- 对于非容器类型（比如数字、字符串等原子类型的对象）没有被拷贝的说法，比如元组变量只包含原子类型对象，则不能深拷贝

- 只会拷贝一层数据，不会跟踪进去拷贝深层的数据

```py
import copy

# XXX 不可变对象不需要进行深拷贝
a = (1, 2, 3)
b = copy.deepcopy(a)
print(id(a) == id(b))  # True

# 可变对象，发生了深拷贝
aa = [1, 2, 3]
bb = copy.deepcopy(aa)
print(id(aa) == id(bb))  # False

# 容器包含可变对象，会发生深拷贝
aaa = (1, [2, 3])
bbb = copy.deepcopy(aaa)
print(id(aaa) == id(bbb))  # False

# 非容器类型也不需要进行深拷贝，即使它可以这样写
aaaa = "xxxxxxx"
bbbb = copy.deepcopy(aaaa)
# bbbb = aaaa
print(id(aaaa) == id(bbbb))  # True
```

## 浮点数

只有 `float` 没有 `double`

```py
# 保留两位小数

## 方式一：格式化字符串
a = "%.3f" % 2.3232321

## 方式二：round
b = round(float(a), 1)
```

## 字符串

[`Python` 常用字符串大全](https://blog.csdn.net/qq_40678222/article/details/83032178)

- 字符串比较大小

  实际应用在比较两个版本大小，有个 `distutils` 模块可以使用

  ```py
  >>> a = '4.0.5'
  >>> b = '4.0.6'
  >>> c = '4.0.10'
  >>> a < b
  >>> True
  >>> a < c
  >>> #坑
  >>> False
  # a 和 c的字符数不一样，如果是 a = 4.0.05 就没问题
  # 还要考虑包含字母的情况，正常来说应该都按照ascii来进行对比
  ```

- 不推荐使用 `+` 来连接多个字符串的原因

  - `string 对象是定长对象`，一旦创建，长度就不可变化

  - 若是使用加号连接两个字符串，则会新开辟一段长度总和长度的内存，再将两个字符串`memcpy`进去

  - 如果要连接 N 个 String 对象，则要进行 N-1 次内存申请和拷贝

- 前缀

  - `r'xxxx'` 表示字符串中的字符不转义

  - `u'xxxx'` 表示是 `unicode` 编码，re 模块通过 unicode 达到匹配中文的目的的时候要用 u

  - `b'xxxx'` 表示这是字节编码 `bytes` 对象

- 超长字符串换行显示

  ```py
  # 字符串太长换行显示 \ 反斜杠连接多行
  url = "https://www.cnblogs.com/" \
        "dinghanhua" \
        "/p/9900700.html"
  if item.conn_status != IS_DEVICE_CONNECT and \
      item.delete_flag != DEVICE_INFO_DELETED and \
      item.dhcp_source != DHCP_GENE_BY_IMPORT:
    pass
  print(url)
  ```

- 超长逻辑判断拼接

  ```py
  if (
    not test
    and not test2
    and not test3
    and test4
  ):
    do_something()
  ```

# 列表、字典、集合、元组

|          | 列表 | 元组 | 字典   | 集合   |
| :------- | :--- | :--- | :----- | :----- |
| 可否修改 | √    | ×    | √      | √      |
| 可否重复 | √    | √    | √      | ×      |
| 是否有序 | √    | √    | ×      | ×      |
| 存储方式 | 值   | 值   | 键值对 | 键值对 |

## 列表

![alt](https://img-blog.csdn.net/20180506091003497?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FiY18xMjM2Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 列表实际上是数组还是链表

  - 列表实际上是一个顺序表...并不是链表，所以 `list`的 `insert` 操作是挺慢的

  - 想用链表可以使用 `collections.deque`

- 各种操作的时间复杂度

  | `Operation`        | `Big-O Efficiency` |
  | ------------------ | ------------------ |
  | `index []`         | `O(1)`             |
  | `index assignment` | `O(1)`             |
  | `append`           | `O(1)`             |
  | `pop()`            | `O(1)`             |
  | `pop(i)`           | `O(n)`             |
  | `insert(i,item)`   | `O(n)`             |
  | `del operator`     | `O(n)`             |
  | `iteration`        | `O(n)`             |
  | `contains (in)`    | `O(n)`             |
  | `get slice [x:y]`  | `O(k)`             |
  | `del slice`        | `O(n)`             |
  | `set slice`        | `O(n+k)`           |
  | `reverse`          | `O(n)`             |
  | `concatenate`      | `O(k)`             |
  | `sort`             | `O(n log n)`       |
  | `multiply`         | `O(nk)`            |

- 深拷贝

  ```py
  # Python深拷贝只能拷贝一层
  name = ['test1', 'test2']
  print("before: %s" % name)
  # >>> before: ['test1', 'test2']

  name2 = name  # 浅拷贝
  name3 = name.copy()  # 深拷贝

  name[1] = 'xxxxxx'
  print("after: 原: %s, 浅: %s, 深: %s" %(name, name2, name3))
  # >>> after: 原: ['test1', 'xxxxxx'], 浅: ['test1', 'xxxxxx'], 深: ['test1', 'test2']


  print("xx.copy() 只能拷贝一层：")
  new_name = [1, [1, 2], 3]
  new_name2 = new_name.copy()
  print("before: 原: %s, 深copy: %s" %(new_name, new_name2))
  # >>> before: 原: [1, [1, 2], 3], 深copy: [1, [1, 2], 3]
  new_name[1][1] = "a"
  print("before: 原: %s, 深copy: %s" %(new_name, new_name2))
  # >>> new_name2 的值也跟着改变了，before: 原: [1, ['a', 2], 3], 深copy: [1, ['a', 2], 3]

  print("真正的深拷贝：")
  from copy import deepcopy
  new_name3 = deepcopy(new_name)
  new_name[2] = "yyyy"  # 修改 new_name 不会对new_name3产生影响
  print("origin: %s, deepcopy: %s" % (new_name, new_name3))
  # >>> origin: ['a', 'A', 'yyyy', [3, 4]], deepcopy: ['a', 'A', 'xxxx', [3, 4]]
  ```

### 基本操作

```py
#-*-coding:utf-8-*-
names = [1, 2, 3, 4, 5, 6]
print(names)

test = [None]
print(str("元素重复n遍"))
print(test * 3)

obj = ['a', 'b', 'c']
print("在列表末尾添加新的元素，可以直接把一个列表作为元素添加进去")
names.append(obj)
print(names)

print("统计某个元素在列表中出现的次数")
names.count(obj)
print(names)

print("在列表末尾一次性追加另一个序列中的多个值(【新列表拼接到原列表后】)")
names.extend(obj)
print(names)

print("作用和 extend 一样，追加列表，不过这种方式是【产生新的列表】")
new_list = names + ['A', 'B']
print(new_list)

print("从列表中找出某个值第一个匹配项的索引位置，索引从0开始")
names.index(obj)
print(names)

print("将对象插入到列表index处")
names.insert(3, obj)
print(names)

print("删除列表中的一个元素(默认最后一个元素)，并且返回该元素的值，参数为索引值")
print(names.pop(-1))
print(names)

print("删除列表中某个值的第一个匹配项")
names.remove(obj)
print(names)

print("使用 del 根据索引删除，可以指定删除范围")
del names[-2]
print(names)

print("翻转列表中元素")
names.reverse()
print(names)

print("清空列表")
names.clear()
print(names)
```

### 使用记录

- extend

  ```py
  a = []
  b = set([1, 2, 3, 1])

  # 以下写法都是可以的
  a.extend(b)

  a.extend((b))

  a.extend([x for x in range(10)])

  a.extend((x for x in range(10)))

  a.extend(x for x in range(10))
  ```

- XXX 把列表分块

  ```py
  from math import ceil
  def chunk(_list, size):
      # 按照指定大小，把列表切割成多段
      return list(
          map(
              lambda x: _list[x*size: x*size + size],
              list(range(0, ceil(len(_list) / size)))
          )
      )

  chunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 2)
  # [[1, 2], [3, 4], [5, 6], [7, 8], [9]]
  ```

- 把一个列表平均分割

  ```py
  # Python 中把一个列表（list）平均分成n块

  # 生成器
  # listTemp 为列表 平分后每份列表的的个数n
  def func(listTemp, n):
      for i in range(0, len(listTemp), n):
          yield listTemp[i: i + n]

  # 这种做法的好处是代码简洁点，要不然就要这样了
  """
  infos = range(100)
  index = 0
  for i in range(4):
      info = infos[index: index+4]
  """

  if __name__ == '__main__':
      listTemp = [1,2,3,4,5,6,7,8,9]
      # func(listTemp, 3)
      # 返回的temp为评分后的每份可迭代对象
      temp = func(listTemp, 4)
      for i in temp:
          print(i)

  '''
  [1, 2, 3, 4]
  [5, 6, 7, 8]
  [9]
  '''
  # 一次性输出
  # import pprint
  # pprint.pprint(list(func(range(10, 75), 10)))
  ```

- [列表元素是字典，根据字典键值去重](https://blog.csdn.net/weixin_37994148/article/details/99731818)

  ```py
  # 注意链接中的第三种方法，一定不要用列表来装已存在的元素，要用集合
  [dict(t) for t in set([tuple(d.items()) for d in li])]
  # 解释
  li 是原始列表
  d  是列表中的一个字典
  t  是从字典中创建的元组之一


  l = [{'a': 123, 'b': 1234},
       {'a': 3222, 'b': 1234},
       {'a': 123, 'b': 1234}]

  seen = set()
  new_l = []
  for d in l:
      t = tuple(d.items())
      if t not in seen:
          seen.add(t)
          new_l.append(d)

  print new_l
  ```

- 列表推导式

  ```py
  import timeit

  # 用列表推导式，比用普通的循环追加元素要快很多
  # 元祖是没有推导式的

  print(timeit.timeit(stmt="[i for i in range(1000)]", number = 100000))
  # 3.480182599974796

  print(timeit.timeit(stmt=foo, number = 100000))
  # 8.93708649999462
  ```

- 判断列表 A 是否是列表 B 的子列表，[求出两个列表的相同元素和不同元素](https://blog.csdn.net/yehuaner33/article/details/81477217)

  ```py
  a = [1, 2, 3]
  b = [2, 4, 6]
  c = [_ for _ in a if _ in b]
  >>> [2]
  ```

- 重复 `n` 次

  ```py
  >>> a = [1, 2]
  >>> a * 3
  [1, 2, 1, 2, 1, 2]

  # 字符串也可以
  >>> b = "x"
  >>> b * 3
  "xxx"
  ```

- XXX [循环遍历进行删除时的坑](https://www.cnblogs.com/bananaplan/p/remove-listitem-while-iterating.html)

  ```py
  a = list(range(20))
  for item in a:
      if item > 10:
          a.remove(item)

  # 会发现并没有完全把大于10的给删掉，因为删除一个元素后，后面的元素会挪到前面，下个循环过来的时候顺序已经变了
  # C++ 中的 vector 迭代器失效?

  # 删完后 a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18]

  # 解决方法是倒序删除
  for item in a[::-1]:
      if item > 10:
          a.remove(item)
  # 删完后 a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  ```

- 怎么拼接出 `"--exclude=a --exclude=b --exclude=c"`

  ```py
  # join 一定要确保里面的列表都是字符串，不能是int

  tmp_cmd = "--exclude ".join(["a", "b", "c"])
  cmd = '"--exclude"=%s' % tmp_cmd
  ```

- 字符串 `"[1, 2, 3, 5]"` 怎么变成列表 `[1, 2, 3, 5]`

  ```py
  import json
  a = "[1, 2, 3, 5]"
  json.loads(a)
  ```

- 列表 `[1, 2, 3, 5]` 怎么变成字符串 `"1, 2, 3, 5"`

  ```py
  src = [1, 2, 3, 5]
  ', '.join(map(str, src))
  >>> '1, 2, 3, 5'
  ```

- 列表 `[1, 2, 3, 5]` 怎么变成多个整数 `1, 2, 3, 5`

  ```py
  src = [1, 2, 3, 5]
  a, b, c, d = tuple(src)
  # 忘记了吗，这不就是个 tuple 吗
  ```

- `join` 坑

  ```py
  a = ''
  a = a.join('b')
  # 输出 'b'

  a = 'b'
  a = a.join('c')
  # 输出'c'

  ######## join 单个字符时，并没有输出'bc' ########
  a = a.join('ed')
  # 输出 ecd 这是正常的，也是 join 的本身作用：用 xxx 作为间隔

  a = ""
  a.join(['b', 'c'])
  # 输出 bc
  ```

- XXX 把列表合并/展开成一个

  ```py
  def spread(arg):
      ret = []
      for item in arg:
          if isinstance(item, list):
              ret.extend(item)
          else:
              ret.append(i)

  def deep_flattern(alist):
      # 把嵌套的列表解开
      result = []
      result.extend(
          spread(
              list(
                  map(lambda x : deep_flattern(x) if type(x) == list else x, alist)
              )
          )
      )

  deep_flattern([1, [2], [[3], 4], 5])
  # [1, 2, 3, 4, 5]
  ```

- 列表元素是一个个字典，根据字典的几个 key 值做合并

  ```py
  data = [
    {'time': 11, 'link_id': '1-1', 'name': 'huangjinjie'},
    {'time': 22, 'link_id': '1-1', 'name': 'huangjinjie'},
    {'time': 33, 'link_id': '1-2', 'name': 'huangjinjin'}
  ]
  # 合并列表，依照相同的 link_id 和 name 的记录中只取 time 最大的那一条
  merge_result = dict()
  # 方式一：做法跟defaultdict差不多，只不过要自己手动去控制是否添加，defaultdict是默认添加
  for item in data:
    merge_key = (item['link_id'], item['name'])
    if (
      merge_key in merge_ret
      and item['time'] > merge_ret[merge_key]['time']
    ):
      merge_ret[merge_key] = item
    elif merge_key not in merge_ret:
      merge_ret[merge_key] = item
  ```

- `split`的时候去除空格；取出列表元素两端的空格

  ```py
  dns = "  8.8.8.8     ;114.114.114.114    "
  #### 并不是 trim，写 c 的时候，经常用 trim 表示去除两端空格
  print([x.strip() for x in dns.split(";")])
  >>>['8.8.8.8', '114.114.114.114']
  ```

- 翻转列表

  ```py
  # reverse
  a = [1, 2, 4, 8]
  a.reverse()  # 改变原列表
  print(a)
  a[::-1]  # 改变原列表
  print(a)

  # [8, 4, 2, 1]
  b = reversed(a)
  # 得到的是一个<listreverseiterator object at 0x7f3b94782b10>迭代器
  print(list(b))
  print(a)  # 不改变原列表
  # [1, 2, 4, 8]
  ```

- 怎么判断两个列表是否相同

  ```py
  a = [1, 2, 3]
  b = [3, 2, 1]
  set(a) == set(b)
  ```

- [枚举](https://www.cnblogs.com/-beyond/p/9777329.html)

  ```py
  # 可以这样
  TYPE1 = 1
  TYPE2 = 2
  TYPE3 = 3

  # 也可以这样
  (TYPE1, TYPE2, TYPE3) = range(3)

  # 但还是有点不好，不如C的枚举，可以把这些成员归到一个枚举类型中，通过点来取值
  # 虽然可以把这些成员归档到一个类中，但是不好的是这些成语可以被修改
  # 在Python3中可以这样
  from enum import Enum
  class type_cfg(Enum):
      (TYPE1, TYPE2, TYPE3) = range(3)
  print(type_cfg.TYPE1)

  # 由于Python2中没有enum库，可以采取这种方法来曲线实现
  # 目的是为了把这几个选择项归到一个类别下
  # DotDict 是自己实现的类，方便通过点来访问成员

  class MyConfig:
    event_type = DotDict(dict(zip(
      [
        "EVENT1",
        "EVENT2",
        "EVENT3"
      ], range(3)))
    )

  print(MyConfig.event_type.EVENT1)

  # Python3 使用枚举类
  from enum import Enum, unique

  class color(Enum):
      '''
      1. 枚举类不能用来实例化对象
      2. 访问枚举类中的某一项，直接使用类名访问加上要访问的项即可，比如 color.YELLOW
      3. 枚举类里面定义的 Key = Value，在类外部不能修改 Value值
      4. 枚举项可以用来比较，使用 ==，或者 is
      5. 导入Enum之后，一个枚举类中的Key和Value，Key不能相同，Value可以相同
         但是Value相同的各项Key都会当做别名
      6. 如果要枚举类中的Value只能是整型数字，那么，可以导入IntEnum，然后继承IntEnum即可，注意，此时，如果value为字符串的数字，也不会报错： from enum import IntEnum
      7.如果要枚举类中的key也不能相同，那么在导入Enum的同时，需要导入unique函数 from enum import unique
      '''
      YELLOW = 1
      RED    = 2
      RED2   = 2  # 可以定义相同值的枚举项，相当于别名

  @unique
  class A(Enum):
      AA = 1
      BB = 2
      CC = 2
  # 报错 ValueError: duplicate values found in <enum 'A'>: CC -> BB
  ```

- 列表怎么做模糊搜索

  ```py
  a = ['时间1', '时间2', '时间3', 'ab','asds']
  dd = [i for i, x in enumerate(a) if x.find('s')!=-1]
  print(dd)  # 输出匹配元素的下标
  ```

- 怎么按照列表元素的某个值进行 `排序 sorted（和 reversed 一样，不会改变原列表顺序），返回值为排序后的列表`

  - [排序](https://www.cnblogs.com/whaben/p/6495702.html)

  - `xxx.sort([func])` 对 **原列表** 进行排序，会改变原列表顺序

  ```py
  from operator import itemgetter
  ip_pools = [
      {
          "id": 1,  # ID
          "start_ip": "192.168.10.0",  # IP池的网络地址
          "latest_subnet": "0.0.0.0-0.0.0.0",  # 最近被分配出去的子网
          "mask": 24,  # IP池的掩码
          "org_id": 1,  # IP池所属组织id
          "status": 2   # 该IP池分配状态
      },
      {
          "id": 2,
          "start_ip": "128.10.0.0",
          "latest_subnet": "128.10.0.0-128.10.0.15",
          "mask": 16,
          "org_id": 0,
          "status": 1
      }
  ]
  # 按照status字段对列表元素进行排序
  # print(sorted(ip_pools, key=lambda x: x.get('status', None)))
  print(sorted(ip_pools, key=itemgetter('status')))

  # XXX 有时是 test = {1: 3, 2: 2, 3: 1} 这种按值排序
  print(sorted(test.items(), key=itemgetter(1)))

  # 如果需要倒序，除了 reversed(list) 和 list.reverse() 之外
  # 还可以 sorted(list, key=xxx, reverse=True)

  # 按多个字段排序
  # print(sorted(ip_pools, key=lambda x: (x.get('id', None), x.get('status', None))))
  print(sorted(ip_pools, key=itemgetter('id', 'status')))
  ```

- 用 `sorted` 对字典元素进行排序

  ```py
  data = {"a": 14, "b": 43, "c": 8, "d":6}
  sorted(data.items(), key=lambda x:x[1])
  # sorted(data.items(), key=itemgetter(1))
  >>> [('d', 6), ('c', 8), ('a', 14), ('b', 43)]

  >>> sorted(data.values())
  [6, 8, 14, 43]
  ```

- [字符串怎么和列表进行匹配](https://cloud.tencent.com/developer/ask/189707)

  ```py
  a = 'SDSD4.0.0'
  b = 'SDSD-v4.0.0'
  c = 'SSL'
  DEV_ALLOW = ['SDSD', 'ADAD', 'AAP']
  for item in ' '.join(DEV_ALLOW):
      if item in b:
        print 'ok'
  ```

- 还可以这样遍历

  ```py
  data = [(1,2), (3,4)] # 换成 [[1,2],[3,4]]也一样
  # 列表元素都有两个值才能这样子遍历
  for _min, _max in data:
      print(_min, _max)
  >>> 1 2
  >>> 3 4
  ```

- 遍历列表根据条件过滤

  ```py
  # 用 for 循环太繁琐，不优雅
  all_cfg = set()
  for item in device_list:
    if item.cfg:
      all_cfg.add(item.cfg)

  # 列表生成式
  all_cfg = [
    _.cfg for _ in device_list if _.cfg
  ]
  ```

- 切片

  > `[a, b)` 左闭右开, 下标从 0 开始

  ```py
  L = range(1, 20)
  XXX L[111:]  # 虽然超过了L的长度，但是并不会产生越界错误，【切片越界不会报错】
  L[19:4000000]   # 返回[19]

  T = range(1, 10, 2)
  # 得到 [1, 3, 5, 7, 9] 等同于 a=range(1,10); a[::2]

  # L[begin:end:step]  开始, 结束, 步长
  # start不写则默认为0，end不写则默认为len(list)
  # 步长,可以缺省但不可为0, 为负则从右到左取
  # 从start开始取 [下标为step的整数倍] 的值
  # 所以如果start不写的话下标为0的元素肯定会被选上

  R = L[:]   # 复制一份
  L[:10]     # 前面10个元素
  L[-10:]    # 最后10个元素

  L[::2]
  L[2::3]    # 取3的倍数，取n的倍数：L[n-1::n]
  L[::-1]    # 翻转列表

  # 取出切片，对切片赋值就可以改变list中的元素了
  L[5:8] = [11111, 22222, 3333]
  ```

- 怎么把自己给切出来

  ```py
  # 因为一个函数用切片来做分页，而且必须传入 start 和 limit，怎么才能拿到原始的数据呢？不做分页
  >>> a = list(range(10))
  >>> a
  [0,1,2,3,4,5,6,7,8,9]
  >>> b = a[:]  # 但是又必须传入参数，那只能判断一下了
  >>> return a if not start and not limit else a[start: limit]
  ```

- 同时遍历两个列表

  ```py
  list1 =[1,2,3,4]
  list2 = ['a','b','c','d']
  for item1, item2 in zip(list1, list2):
      print item1, item2
  ```

- 两个列表怎么组合成一个 dict

  ```py
  # 设备清单id列表 a = [1,2,4,5,6] 和 dhcp 配置列表 b = ['xxx','yyy']
  >>> dict(zip(a, b))
  >>> {1: 'xxx', 2: 'yyy'}
  ```

- 下标遍历

  ```py
  l = [1, 2, 4, 45]
  XXX # enumerate
  for index, value in enumerate(l):
      print(index, value)
      print(index, l[index+1])
  ```

- 把`a = [[1,2,3], [4,5,6]]` 变为一个列表

  ```py
  a = list()
  [a.extend(x) for x in a]
  ```

- 怎么用两个列表组合成字典,相同 `key` 的 `vlue` 值组成列表

  > https://zhidao.baidu.com/question/942978557655294532.html

  ```py
  dict(zip(("begin", "end"), ("0", "33")))
  >>>{'begin': '0', 'end': '33'}


  lista=['a','b','c','a','b','c','d']
  listb=['1','2','3','4','5','6','7']
  dict={}
  for i,j in zip(lista,listb):
      if i not in dict.keys():
          dict[i]=j
      else:
          dict[i]=[dict[i]]
          dict[i].append(j)
  print(dict)
  ```

- 通过 `sqlalchemy` 左连接查询得到的 `protobuf` 数据结构是下面这样的:

  ```py
  dhcp_cfg {
    dhcp_pools {
      id: 10
      start_ip: "192.168.10.0"
      mask: 24
      status: 2
      curr_subnet: "192.168.10.192-192.168.10.255"
      org_id: 1
    }
    org_dhcp_cfg {
      cfg_id: 5
      org_id: 1
      main_dns: "8.8.8.8"
      backup_dns: "114.114.114.114"
      exclude: "{\"exclude_ip\": [\"192.1.1.1\"], \"exclude_range\": [\"192.168.10.3-192.168.10.32\"], \"exclude_subnet\": [\"192.168.10.16/28\"]}"
      enable: true
    }
  }
  dhcp_cfg {
    dhcp_pools {
      id: 11
      start_ip: "10.118.0.0"
      mask: 16
      status: 1
      curr_subnet: "10.118.1.64-10.118.1.127"
      org_id: 1
    }
    org_dhcp_cfg {
      cfg_id: 5
      org_id: 1
      main_dns: "8.8.8.8"
      backup_dns: "114.114.114.114"
      exclude: "{\"exclude_ip\": [\"192.1.1.1\"], \"exclude_range\": [\"192.168.10.3-192.168.10.32\"], \"exclude_subnet\": [\"192.168.10.16/28\"]}"
      enable: true
    }
  }
  dhcp_cfg {
    org_dhcp_cfg {
      cfg_id: 6
      main_dns: "1.1.1.1"
      backup_dns: "2.2.2.2"
      exclude: "{\"exclude_ip\": [\"192.168.10.0\"], \"exclude_range\": [\"192.168.10.3-192.168.10.32\"], \"exclude_subnet\": [\"192.168.10.16/28\"]}"
    }
  }

  """ sqlalchemy 查询出来的数据向上面这样的，左连接查询，
  table1.id   table1.main_dns   table1.backup_dns   table1.exclude    table2.id   table2.start_ip
  table1.id   table1.main_dns   table1.backup_dns   table1.exclude    table2.id2  table2.start_ip3

  table1.id2   table1.main_dns2   table1.backup_dns2   table1.exclude2    None       None
  左连接查询，左表相同的数据会出现多次，期望是这样的结构
  {
    table1: {
      table1.id
      table1.main_dns
      ...
    }
    table2: [
      table2_1 {
        table2_1.id
        table2_1.start_ip
        ...
      }
      table2_2 {
        table2_2.id
        table2_2.start_ip
        ...
      }
    ]
  }
  """
  # 处理方法
  def get_dhcp_conf(self, org_id=None)
      dhcp_cfg = {}
      rep = EdeployDhcpPool().get_dhcp_cfg(org_id=org_id)
      for item in rep.dhcp_cfg:
          # 先这样判断是否已有key在字典里，没有再添加，有的话就只添加ip_pools
          if item.org_dhcp_cfg.org_id not in dhcp_cfg.keys():
              cfg_detail = dict()
              ip_pools = list()
              cfg_detail['branch_mask'] = item.org_dhcp_cfg.branch_mask
              cfg_detail['main_dns'] = item.org_dhcp_cfg.main_dns
              cfg_detail['backup_dns'] = item.org_dhcp_cfg.backup_dns
              cfg_detail['exlcude'] = json.loads(item.org_dhcp_cfg.exclude)
              cfg_detail['dhcp_enable'] = item.org_dhcp_cfg.enable
              if item.dhcp_pools:
                  ip_pools.append(pb2dict(item.dhcp_pools))
              cfg_detail['ip_pools'] = ip_pools
              dhcp_cfg[item.org_dhcp_cfg.org_id] = cfg_detail
          else:
              dhcp_cfg[item.org_dhcp_cfg.org_id]['ip_pools'].append(
                  pb2dict(item.dhcp_pools))
      return dhcp_cfg

  # 没那么麻烦，用 defaultdict 就行了
  from collections import defaultdict
  def get_dhcp_conf(self, org_id):
      dhcp_cfg = defaultdict(list)
      rep = EdeployDhcpPool().get_dhcp_cfg(org_id=org_id)
      for item in rep.dhcp_cfg:
          dhcp_cfg[org_id] = pb2dict(item.org_dhcp_cfg)
          dhcp_cfg['ip_pools'].append(item.dhcp_pools)
      return dhcp_cfg
  ```

## 元组

> tuple 初始化之后就不允许改变的结构

- 也并非不可变

  ```py
  >>> s = (['1', '2', '3'], 22, 33)
  >>> s[0][1] = '11111'
  >>> s
  >>> (['1', '11111', '3'], 22, 33)
  ```

- https://www.cnblogs.com/weihu/p/7979505.html

- XXX 在任意类型后面加个逗号，都会变成 tuple

  ```py
  b = (1,)  # 加了逗号才变成 tuple，元组只有一个元素时，别忘了末尾的逗号
  b = (1)  # 没加逗号的话，它只是个整型
  ```

- 添加元素到元祖

## 字典

dict 是关联的序列：有 key 和 values，其中 `key是不可重复, dict是无序的`

### 基本操作

```py
# 初始化一个dict结构
ret = dict(
  test='test',
  test2='test2'
)

ret2 = {
  'test': 'test',
  'test2': 'test2'
}

mydict.clear()  # 清空字典
mydict.copy()   # 返回一个字典的浅复制

# 创建一个新字典，以序列 seq 中元素做字典的键，val为字典所有键对应的初始值
test = {}
test.fromkeys(['1', '2', '3'], '10')
>>>{ '1': '10', '2': '10', '3': '10'}

# key是否存在keys中，该方法即将被遗弃，用 in 替代
mydict.has_key(key)
>>> mydict = {'key1': 2}
>>> 'key1' in mydict
>>> True
>>> mydict.has_key('key1')
>>> True

mydict.values()  # 以列表返回字典中的所有值

mydict.keys()   # 以列表返回一个字典所有的键
mydict.items()   # 以列表返回可遍历的(键, 值) 元组/列表数组，元组无序
mydict.iteritems()
# 和range 一样 Python2 以迭代器的形式返回，比直接返回元组/列表效率要高
# Python3 中已用 items() 替代了

# 返回指定键的值, 如果值不在字典中 [返回] default值
mydict.get(key, default=None)

mydict.update(dict2)
# 把dict2的值【追加】到dict中
# 但是注意字典的key是不能重复的，所以如果dict2和dict有相同的key则dict的key对应的value会更新为dict2中的值

>>> args = {'a': 1, "b": 2}
>>> 'a' in args
>>> True

# del 语句和 pop() 函数作用相同，pop() 函数有返回值
>>> dic = {'runoob': '菜鸟教程', 'google': 'Google 搜索', 'taobao': '淘宝', 'tmall': None}
>>> del dic['tmall']
>>> dic
{'runoob': '菜鸟教程', 'google': 'Google 搜索', 'taobao': '淘宝'}
>>> dic.setdefault('tmall', '天猫')
'天猫'
>>> dic
{'runoob': '菜鸟教程', 'google': 'Google 搜索', 'taobao': '淘宝', 'tmall': '天猫'}
# default: 如果没有 key，返回 default 值
>>> dic.pop('tmall', "default_string")
'天猫'
>>> dic
{'runoob': '菜鸟教程', 'google': 'Google 搜索', 'taobao': '淘宝'}
>>>
```

- `values() 和 intervalues()`

  ```py
  # values() 方法实际上把一个 dict 转换成了包含 value 的list
  # itervalues() 方法不会转换，它是一个生成器，它会在迭代过程中依次从 dict 中取出 value
  在Python3.6中已经把 d.itervalues()方法移除了，d.values()的类型也变成了 dict_values
  ```

### 使用记录

- [修改字典的键](https://www.jb51.net/article/166961.htm)

  ```py
  # 没办法
  info = {"x":1.5 ,"y":2}
  info.update({"z":info.pop("x")})
  >>> info =  {"z": 1.5, "y": 2}
  ```

- 嵌套类转 dict

  ```py
  import json
  class A(dict):
    def __init__(self):
      self.a = 1
      self.b = 2
    def __repr__(self):
      return "%s" % self.__dict__

  class B(dict):
    def __init__(self):
      self.c = 3
      self.d = 4
      self.e = A()

  b = B()
  c = b.__dict__
  d = json.dumps(c)  # 这里输出 '{"c": 3, "d": 4, "e": {}}'   e内容不见了

  e = json.dumps(str(c))  #'"{\'c\': 3, \'d\': 4, \'e\': {\'a\': 1, \'b\': 2}}"'
  # 还原
  f = json.loads(e)  # "{'c': 3, 'd': 4, 'e': {'a': 1, 'b': 2}}"
  import ast
  f1 = ast.literal_eval(f)  # {'c': 3, 'd': 4, 'e': {'a': 1, 'b': 2}}
  ```

- [按 value 进行排序](https://blog.csdn.net/laobai1015/article/details/85114570)

  ```py
  from operator import itemgetter
  test = {1: 3, 2: 2, 3: 2}
  test2 = sorted(test.items(), key=itemgetter(1))
  # 或者挫一点 test2 = sorted(test.items(), key=lambda x: x[1])
  ```

- 用字典来初始化一个类

  ```py
  class Filed:
      def __init__(self, name)
          self.name = name

  class A(dict):
      name = Filed('name')
      age = Filed('age')

  a = A(**{'name':'huangjinjie', 'age':25})
  print(a.name)
  print(a['name'])
  ```

- [怎么替换掉 dict 的 key](https://blog.csdn.net/jt674106399/article/details/76516186)

  ```py
  a = {'a': 1} ### ----> a = {'b' :1}
  a['b'] = a.pop('a')
  ```

- [怎么翻转字典键值对](https://blog.csdn.net/ITYTI/article/details/85098699)

  ```py
  dict_list = {"a": 1, "b": 2, "c": 3}
  mydict_new = dict(zip(dict_list.values(), dict_list.keys()))
  {1: 'a', 2: 'b', 3: 'c'}
  ```

- 怎么用一个 `dict` 替换 `value`

  ```py
  test_data = [
      {'policy_id': 1, 'strategy': 'test'},
      {'policy_id': 1, 'strategy': 'test1'},
      {'policy_id': 2, 'strategy': '3333'}
  ]
  # 期望替换 1 --->  "policy_1"
  # 期望替换 2 --->  "policy_2"
  tpl = {
    1: "policy_1",
    2: "policy_2"
  }
  # 没啥骚操作
  for item in test_data:
    test_data['policy_id'] = tpl[test_data['policy_id']]
  ```

- `update` 的坑

  ```py
  import random
  a = {"occur_time": 0}
  b = list()
  for i in range(10):
    # 随机生成10条数据
    rand_int = random.randint(0, 1000)
    a.update({"occur_time": rand_int})
    print(rand_int)
    b.append(a)
  # 最终发现这 10 条数据的 occur_time 全部都一样，而且都是最后的那个 rand_int
  print(b)
  """
  根据现象可猜得到是深浅拷贝的问题
  b = [a1, a2, a3, a4 ...] 其中的每一个a都是指向最原始的a的地址，所以一直在更新a的值，而不是得到最新的a
  正确做法如下
  """
  for i in range(10):
    # 随机生成10条数据
    rand_int = random.randint(0, 1000)
    tmp_item = deepcopy(a)
    tmp_item.update({"occur_time": rand_int})
    b.append(tmp_item)
  ```

- 怎么用一个列表作为字典的键值

  ```py
  # 字典的键值要求是不可变对象，直接使用列表肯定是不行的， 不过可以使用元组来代替
  ```

- 给出一个列表，怎么把这个列表转成字典，并用下标作为键值

  ```py
  # 但凡你懂点zip，也不会问出这样的问题
  dns = "  8.8.8.8     ;114.114.114.114    "
  dns_list = [x.strip() for x in dns.split(";")]
  dns_list
  # ["8.8.8.8", "114.114.114.114"]
  keys = ["DNS" + str(x) for x in range(len(dns_list))]
  # ["DNS0", "DNS1"]
  dict(zip(keys, dns_list))
  # {"DNS1": "8.8.8.8", "DNS2": "114.114.114.114"}

  # 如果只是需要用下标做key值的话，用 enumerate 就行了
  dict(list(enumerate(dns_list, start=1)))
  # {1: '8.8.8.8', 2: '114.114.114.114'}
  ```

- 判断键值是否在字典中

  ```py
  >>> a = {'a'：1， 'b': 2}
  >>> 'a' in a
  True
  ```

- 使用点来访问字典

  ```py
  # json-sempai 模块也可，看看它是怎么实现的
  class DotDict(dict):
      def __init__(self, *args, **kwargs):
          dict.__init__(self, *args, **kwargs)
          self.__dict__ = self

  if __name__ == '__main__':
      a = {
          'a': 1,
          'b': 2
      }
      # 键值为字符串
      d_a = DotDict(a)
      print(d_a.a)
  ```

- 相同 key 值的 values 不要替换，而是添加

  目的是为了往字典里塞值的时候，希望已经存在相同的 key 值时，则不要替换，而是往后添加

  [Python 技巧（setdefault 与 defaultdict）](https://blog.csdn.net/wsh_only/article/details/83243112)

  ```py
  # 传统做法
  ret = dict()
  ret['a'] = list()
  for i in [1, 2]]:
    ret['a'].append(i)

  # setdefault
  ret = dict()
  for i in [1, 2]:
    ret.setdefault('a', list()).append()

  # 和 defaultdict 一起对比一下，好像和 defaultdict 一个意思了，也都是为了把相同key值的values归并起来
  ```

- [字典比对](https://www.cnblogs.com/xyztank/articles/14008511.html)

  ```py
  a = {'a': 1, 'b': 2}
  set(a)  # 输出为 {'a', 'b'}
  b = {'b': 1, 'a': 2}
  ```

- 怎么把字典转化成元祖列表

  ```py
  >>> p = {'a':1, 'b':22, 'c':3}
  >>> zip(p.keys(), p.values)
  >>> [('a', 1), ('c', 3), ('b', 22)] # Python2 输出结果，Python3 为迭代器
  ```

- 怎么把元祖列表转化为字典

  ```py
  ls = [('a', 1), ('c', 3), ('b', 22)]
  dict(ls)   #  {'a':1, 'b':22, 'c':3}
  ```

- [判断一个字典是否包含于另一个字典](https://www.cnblogs.com/dflblog/p/11944980.html)

  ```py
  a = {"a":1, "b":2}
  b = {"a":1, "b":2, "c":3}

  # 用set来实现
  aa = set(a.items())     #{('a', 1), ('b', 2)}
  bb = set(b.items())     #{('a', 1), ('c', 3), ('b', 2)}
  print(aa.issubset(b.items()))      # true
  print(aa.issubset(bb))             # true
  ```

- 判断相同 key 值不同 values 是否存在字典中

  ```py
  # 判断 {1: 2} 是否存在 [{1: 3}, {2:4}] 相同的 key
  ```

## 集合

> `set` 无序，不包含重复元素

[Python 之 set 集合及深浅拷贝](https://www.cnblogs.com/baijinshuo/p/9427554.html)

- 初始化

  ```py
  a = {1, 2, 3}
  b = {13}
  c = set()
  ```

- CURD 操作

  ```py
  # 增
  >>>set1.add(11)
  # 删
  >>>c.pop() # 删除第一个元素，并且返回该元素的值
  >>>c.remove(11)
  # 查

  # 改
  # 有update方法就不用每次都先定义list然后转set了
  >>> c.update([2,3,4]) # 无则追加，有则跳过
  >>> c.update(set([2,3,4])) # 俺也一样

  >>> cc=set()
  >>> a = [set(['1-2', '2-3']), set(['1-2', '3-4'])]
  >>> map(lambda x: cc.update(x), a.values()) # map
  >>> [cc.update(x) for x in a.values()] # 列表生成式，和用map同样效果
  ```

- 集合操作

  ```py
  >>> a = [1,2,3,4,5,6,7,8,9]
  >>> b = [2,4,5,1,12,43,12]
  >>> set1 = set(a)
  >>> set2 = set(b)
  # 交集
  >>> set1.intersection(set2) 或 set1 & set2
  >>> set([1,2,4,5])  # 输出
  # 差集
  >>> set1.difference(set2) 或 set1 - set2
  >>> set([8,9,3,6,7])  # 输出
  # 并集
  >>> set1 | set2
  >>> set([1, 2, 3, 4, 5, 6, 7, 8, 9, 43, 12]) # 输出

  # 判断set2是否包含set1的元素
  >>> set1.isdisjoint(set2)

  # 方法用于移除指定的集合元素。
  # 该方法不同于 remove() 方法，因为 remove() 方法在移除一个不存在的元素时会发生错误，而 discard() 方法不会
  >>> set1.discard("value1")
  ```

# 类型转换

```py
int()  # 将任何数据类型转换为整数类型

float()  # 将任何数据类型转换为 float 类型

ord()  # 将字符转换为整数

hex()  # 将整数转换为十六进制

oct()  # 将整数转换为八进制

tuple()  # 此函数用于转换为元组。

set()  # 此函数在转换为 set 后返回类型。

list()  # 此函数用于将任何数据类型转换为列表类型。

dict()  # 此函数用于将顺序元组（键，值）转换为字典。

str()  # 用于将整数转换为字符串。

complex(real, imag)  # 此函数将实数转换为复数（实数，图像）数。
```

- 进制转换

- `str` 转 `int`

  ```py
  a = "1.1"
  int(a)  # 报错
  float(a)

  b = "1"
  int(b)

  c = 1.1
  int(c)  # 编程整形了
  float(c)
  ```

- tuple 转字符串

  ```py
  a = ('1', '2', '3')
  # 期望得到 '1 2 3'
  cnt = len(a)
  print(' %s ' * cnt % a)
  # ' 1 2 3 '
  ```

- 字符串和 `Bytes` 互相转换

  ```py
  >>> '南北'.encode()
  >>> b'\xe5\x8d\x97\xe5\x8c\x97'
  >>> b'\xe5\x8d\x97\xe5\x8c\x97'.decode()
  >>> '南北'
  ```

- `Python3` 字符串转字节

  ```py
  >>> bytes([1,2,3,4,5,6,7,8,9])
  b'\x01\x02\x03\x04\x05\x06\x07\x08\t'

  >>> bytes("Python", 'ascii') # 字符串，编码
  b'Python'
  ```

- 字符串 转 dict

  ```py
  >>> a = "{'user': 'huangjinjie中文'}"
  >>> a
  "{'user': 'huagnjinjie\xe6\x83\xb3'}" #Python2
  "{'user': 'huangjinjie中文'}" # Python3

  >>> a = eval(a) # eval和 literal_eval 中文都会变成utf-8编码
  >>> a
  {'user': 'huagnjinjie\xe6\x83\xb3'} # Python2
  {'user': 'huangjinjie中文'} # Python3
  >>> b = json.loads(a) # 会报错，改为 a = '{"user": "huangjinjie中文"}' 里面必须为双引号才可以

  >>> a2 = '{"user撒": "huangjinjie中文"}'
  '{"user\xe6\x92\x92": "huangjinjie\xe4\xb8\xad\xe6\x96\x87"}' # Python2
  '{"user撒": "huangjinjie中文"}' # Python3
  >>> b = json.loads(a2)
  >>> b
  {u'user\u6492': u'huangjinjie\u7684'} # Python2
  {'user撒': 'huangjinjie中文'} # Python3
  # 本来很烦 json_lsprof.Profiler 解析字符串变为unicode的，但是刚好proto查询的结果返回也是unicode
  ```

  - 注意以上测试代码 Python2 和 Python3 的区别，Python3 不区分 unicode 和 utf-8（str）了

  - 使用`dict()`的时候要注意 `a.get('xxx')` get 的值是否存在 dict 中，有可能因为编码问题导致 get 不到

  - [eval](https://www.cnblogs.com/sui776265233/p/9900709.html) 要注意风险，因为 eval 实际上是解释执行 Python 代码，如果输入来源于外部....

  - [json.loads() 有坑，json 语法规定 数组或对象之中的字符串必须使用双引号，不能使用单引号](https://www.jb51.net/article/164896.htm)，建议使用 `ast.literal_eval(xxx)` 消除安全风险

    ```py
    import ast

    # eval功能可谓非常强大，即可以做string与list,tuple,dict之间的类型转换，还可以做计算器使用！更有甚者，可以对她能解析的字符串都做处理
    print(eval('1+1'))  # 2

    # literal_eval()函数：则会判断需要计算的内容计算后是不是合法的Python类型，如果是则进行运算，否则就不进行运算
    print(ast.literal_eval('1+1'))  # Error

    print(eval('{\'a\': 1}'))
    print(ast.literal_eval('{\'a\': 1}'))
    ```

- `unicode` 转 中文

  ```py
  >>> x = u'哈哈'
  >>> x
  u'\u54c8\u54c8'

  >>> x = x.encode('utf-8') # unicode -> str
  >>> kx
  >>> '\xe4\xb8\xad\xe6\x96\x87'
  ```

- 十六进制 转 字符串

  ```py
  # 十六进制 转 字符串
  binascii.a2b_hex(msg)
  # 字符串 转 十六进制
  binascii.b2a_hex(hex_str)
  ```

- `base64` 转 十六进制

  ```py
  Python3.x 里 base64 解码，对于对几个16进制数字编码成的密文该用base64哪个方法解码才能输出成16进制数呢？
  hex()
  ```

- 类型注解

  ```python
  def test(a [:参数a的数据类型 = 1]) [-> 返回值的数据类型]:
    # 形参后面加冒号： 用于指定该形参的数据类型
    # 函数定义后面加 -> ：用于指定函数的返回值的数据类型
    函数体

  URLTypes = Union["URL", str]

  class Test:
    def __init__(
        self,
        http1: bool = True,
        http2: bool = False,
        base_url: URLTypes = "",
        default_encoding: str = "utf-8",
    ):
      pass
  ```
