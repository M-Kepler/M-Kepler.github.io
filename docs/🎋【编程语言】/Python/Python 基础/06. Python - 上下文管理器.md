- [参考资料](#参考资料)
- [上下文管理器](#上下文管理器)
  - [`with`](#with)
  - [`@contextmanager`](#contextmanager)
  - [`closing`](#closing)

# 参考资料

- [`with 和 @contextmanager`](https://www.jianshu.com/p/72a2755bf694)

# 上下文管理器

## `with`

- [`with as` 的用法](https://www.jianshu.com/p/1a02a5b63c88)

- [`with` 里面有 `return` 还会执行 `__exit__` 吗](https://www.jianshu.com/p/e0a82b8802fa)

  会执行，且是在 return 语句执行之后

- [`with` 语句中的变量没有作用域](https://www.cnblogs.com/zjutzz/p/9314255.html)

  ```py
  with xxxx as yy:
      a = asdfasdfas

  # 可以在 with 外访问
  print(a)
  ```

- with 语句就像自动执行了构造函数和析构函数，做一下`事前准备事后清理`的工作

  ```py
  with open('/path/to/testfile.txt') as f:
      do_something()
  ```

- [如果要打开两个文件可以这样](https://www.cnblogs.com/dancesir/p/7804989.html)

  ```Python
  with open("/tmp/test1") as f1, open("/tmp/test2") as f2:
      print(f1.readline())
      print(f2.readline())
  ```

- [自定义一个这样的函数](https://www.cnblogs.com/DragonFire/p/6764066.html)

  ```py
  class WithTest(object):
    def __init__(self):
      pass

    def __enter__(self)
      # 开始运行的时候触发此方法的运行
      # 那是__enter__先运行还是__init__先运行？
      # __enter__可以调用类成员函数，__init__就不可以
      # __enter__应该是在初始化之后，使用 with 的时候运行
      # 好吧。。。__enter__是在 with 的时候调用的，__init__实在实例化的时候
      print('before test')

    def __exit__(self, exc_type, exc_val, exc_tb):
      #当with运行结束之后触发此方法的运行
      # exc_type   如果抛出异常, 这里获取异常 类型
      # exc_val    如果抛出异常, 这里获取异常 内容
      # exc_tb     如果抛出异常, 这里获取异常 位置
      if exc_type:
        print('test raise exception')
      else:
        print('after test')

    def test(self):
        print('in with')

  with WithTest() as t:
      t.test()
  ```

## `@contextmanager`

> `@contextmanager` + `yield`

- 前面使用`with`语句的话要去实现 ==`__enter__ 和 __exit__`==，现在有更方便的做法，直接使用装饰器即可

- `@contextmanager` 这个装饰器，装饰一个生成器 ==（包含 yield）==

  ```py

  from contextlib import contextmanager

  @contextmanager
  def session_scope():
      session = DBSession()
      try:
          # xxx do something with session
          # yield 表示 with 语句下的代码
          # yield 为分界，上面的相当与 __enter__, 后面的相当于 __exit__
          yield session  # 返回一个 session，可以在 with 语句块中使用
          session.commit()
      except:
          session.rollback()
          raise
      finally:
          session.close()

  # with 语句首先执行 yield 之前的语句
  # yield 调用会执行 with 语句内部的所有语句
  # 最后执行 yield 之后的语句
  with session_scope() as session:
      MysqlDeviceApi(session).update(**kwargs)


  @contextmanager
  def test():
      a = 10
      print('before')
      yield a
      print('after')

  with test() as t:
      print(t)
      print('in')
  ```

## `closing`

```py
from contextlib import closing
with closing(urlopen('http://www.baidu.com')) as page:
    for line in page:
        print(line)
```

- 有些类，`并没有 __enter__、__exit__` 这两个方法，==但是有 `close()`==，能不能在不加代码的情况下，使用 `with` 呢？

  ```py
  from contextlib import closing

  class Test:
      def open(self):
          print('open')

      def close(self):
          print('close')

  with closing(Test()) as t:
      print('in')
      door.open()
  ```

- 作用就是把任意对象变为上下文对象，并支持 `with` 语句。有些函数比如 `urlopen` 没有实现上下文，可以用 `closing()` 把它变成上下文对象；`closing` 也是一个经过`@contextmanager` 装饰的迭代器

  ```py
  @contextmanager
  def closing(task):
      try:
          yield task
      finally:
          task.close()
  ```
