- [生成器](#生成器)
  - [推导式](#推导式)
  - [`yield`](#yield)
  - [`send`](#send)
  - [`yield from`](#yield-from)
  - [协程](#协程)
  - [生成器和协程的区别联系](#生成器和协程的区别联系)
  - [优缺点](#优缺点)
- [其他](#其他)
- [参考资料](#参考资料)

# 生成器

- 生成器的标志就是代码实现中 **包含 `yield`**，生成器保存的是一个计算方法，然后 `yield` 的作用是运行到这里就直接返回，下次再从这里继续

- 协程就是利用这样的特性来控制程序的运行，而不需要利用系统 CPU 的中断来切到子程序

## 推导式

```py
a = [x for x in range(10)]

# 推导式和生成式不一样，推导式其实是保存了结果的，而生成式保存的是方法，要迭代或 next(t) 来取下一个值

# XXX 推导式把中括号变成小括号，就变成生成器了
# 可能会问，小括号不是元祖推导式吗？。。。元祖是没有推导式的
b = (x for x in range(10))
# 所以，不能用 in 来判断是否存在某元素
>>> 1 in a
>>> True
>>> 1 in b
>>> False

next(b)

aa = []
# 都可以
aa.extend((x for x in range(10)))
aa.extend([x for x in range(10)])

```

- `generator` 保存的是算法，每次调用 `next(g)`，就`可以根据前一个元素推导出下一个元素的值`，直到计算到最后一个元素，没有更多的元素时，抛出 `StopIteration` 异常

  ```py
  # 和上面的生成式相比，感觉像是tuple生成式
  # 实际上得到的是个生成器
  g = (x*x for x in range(10))

  next(g) # 得到下一个值
  next(g) # 得到下一个值
  ...
  # 访问到最后一个元素还继续next的话就会抛出异常
  StopIteration
  # 可以捕获这个异常然后退出
  ```

- 生成器`只能迭代一次`，再次迭代时会发现已经被擦除

## `yield`

> `yield` 英文意思是：产出、产量；让步、提供

- `yield` 的特点就是`运行到 yield 就返回，再次调用则从上次停下来的地方接着开始`

  结合上面说的`推导`可知生成器就是用了 `yield` 来实现的，所以一个普通函数，如果使用到了 `yield` 那他就成为一个生成器了

  ```py
  def test():
    print('step 1')
    yield 1   # 程序执行到 yield 会停下来
    print('step 2')
    yield(2)
    print('step 3')
    yield(3)
  >>> type(test()) # 类型是生成器 <type 'generator'>
  >>> type(test)   # 类型是函数 <type 'function'>

  a = test()
  next(a)
  # 输出 1
  next(a)
  # 输出 2
  next(a)
  # 输出 3
  next(a)
  # 抛 StopIteration 异常
  ```

- ★ `yield` 在等号右边作为表达式，则可以通过 `send` 来给他赋值，即接收发送者传过来的参数

  ```py
  def coro(a):
      print('->Started: a=', a)
      # 再次运行的时候再从这里开始，才把a赋值给到b
      b = yield a  # 接受外部调用 send 传过来的值保存到 a，再赋值给 b

      """
      b = yield a 可以分拆成两个语句： yield a; b = a
      所以，yield a 可以认为是 return a，程序在这里就返回去了，而且返回值是a的值
      然后停下来，【等待】 next() 或者 send() 函数到来就继续往下执行，最后再执行赋值语句
      """
      print('->Received: b=', b)

      c = yield a + b

      """
      c = yield a + b 相当于：c = (yield a) + b，【先接受 send 过来的值保存在 a，然后把 a + b 的值赋值给 c】
      生成器调用 send(data) 的话会把 data 先赋值给 a，然后执行
      所以，不是a + b赋值给c，而是获取 send(x) 发过来的数值 x 赋值给 c
      """
      print('->Received: c=', c)

  if __name__ == "__main__":
      # coro 已经不是一个普通函数，不会直接被调用；而是返回一个生成器对象
      c = coro(14)
      next(c)

      """
      - 启动生成器，程序运行到第一个 yield 处返回，即 yield a，注意，还没运行到 b = 这个赋值语句

      - c.send(None) 也可以这样启动生成器，因为现在还没执行到 yield，send 一个具体的值还没有 yield 来接收

      - 如果没启动生成器就直接send，会报错:  TypeError: can't send non-None value to a just-started generator

      - 如果我再执行一下 next(c) 也会报错 unsupported operand type(s) for +: 'int' and 'NoneType'；所以其实 next(c) 和 c.send(None) 是等价的，会 send 一个 None 值给 a，所以用 None + int 就报错了

      会不会疑惑？我用for来迭代生成器，也没见用到这些东西啊 TODO
      ------
      在学习生成器的时候，g = (x*x for x in range(10))，也是用 next(g) 来获取下一个值，这么一起看就都懂了
      """

      # >>> '->Started: a=14'
      # >>> 14    # next 返回值

      c.send(28)
      """
      发送数据，即发送 28 给 a
      继续从上一次停下来的yield处继续执行，即执行 b = a 这个赋值语句
      所以 yield a + b = 赋值运算得到的b + 这里发送过去的a = 14 + 28 = 42，
      返回的这个 42 就是【即将】赋值给 c 的值
      """
      # >>> '->Received: b=28'
      # >>> 42

      c.send(99)  # 发送数据，即，发送99 给c
      # >>> '->Received: c=99'
      # >>> raise StopIteration  # 因为没有 yield 了，所以直接抛出异常
  ```

- `next(g) 和 g.send(None)` 是等价的，都是发送一个 None 给 yield 修饰的变量

- 协程装饰器

  ```py
  from functools import wraps

  def coroutine(func):
    """
    装饰器：向前执行到第一个yield，预激 func
    """
    @wraps(func)
    def primer(*args, **kwargs):
      gen = func(*args, **kwargs)
      next(gen)
      return gen
    return primer
  ```

- 协程与 `yield` 或者说 生成器 有什么关系

  `yield` 的能力是是运行到 `yield` 的时候就返回，下次调用 `next 或者 send` 过来或者调用生成器的时候再回到**上次停下来的地方继续执行**，所以可以通过程序自己来控制子程序的执行顺序，而不需要程序的频繁入栈出栈

## `send`

- `yield` 是一个表达式，通过 `send(msg)` 语句让它执行，并一直运行到下一个 `yield` 表达式处，再次调用会继续这样的流程，就好像 `send` 是驱动它执行一样（这和直接调用 `next(生成器)` 有什么差别？ `next(g) 和 g.send(None)`作用一样）

- `send(msg)` 传递 `msg`给 `yield` 表达式并返回下一个 `yield` 表达式的参数，当 `msg==None` 时，`yield` 不执行，仅仅是启动 `generator`，此时直接返回，也就是只执行到了 `yield` 的上一句，等待下一次 `send()` 调用

- `yield + send` 控制程序执行，通过生产者消费者来感受下这个过程

  传统使用多线程，但是存在占用内存高、死锁等问题。如果改用协程，生产者生产消息后，直接通过 yield 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高

  ```Python
  def consumer():
      r = ''
      while True:
          n = yield r  # 如果消费者发现还没数据，yield 会在这里等待
                       # 收到生产完成的消息，开始消费传过来的值
          if not n:
              return
          print('[CONSUMER]Consuming %s...' % n)
          r = '200 OK'

  def produce(c):
      c.send(None)  # 启动生成器，消费者开始消费
      n = 0
      while n < 5:
          n = n + 1
          print('[PRODUCER]Producing %s...' % n)
          r = c.send(n)  # 生产者生产完成，通知消费者进行消费
          print('[PRODUCER]Consumer return: %s' % r)
      c.close()

  c = consumer()
  produce(c)

  # 整个过程很有顺序，生产一个，消费一个
  ```

## `yield from`

`Python 3.3+` 才支持

- `yield from` 语法可以让我们方便地调用另一个 `generator`

- `yield from` 的作用还体现可以像一个管道一样将 `send` 信息传递给内层协程，并且处理好了各种异常情况

  ```py
  def fab(max):
    """ 非递归实现的斐波那契数列
    """
    n, a, b = 0, 0, 1
    while n < max:
      yield b  # 有yield，是个生成器
      a, b = b, a + b
      n = n + 1

  f = fab(5)

  def f_wrapper(fun_iterable):
    """ 套个装饰器来演示一下 yield from
    """
    print('start')
    # 相当于 yield from iterable 必须是一个可生成对象，刚好上面就写了个生成器（有 yield）
    for item in func_iteable:
      yield item
    print('end')

  wrap = f_wrapper(fab(5))
  for i in wrap:
      print(i)
  ```

## 协程

- `yield / yield from` 实现了控制子程序运行，`send` 实现了子程序之间通信的功能，所以完全可以有程序自己来进行子程序的调度，而不需要 CPU 参与（会频繁地终端、出入栈），协程也就有了。

- `yield from` 在 `asyncio` 模块中得以发扬光大。之前都是我们手工切换协程，现在`当声明函数为协程后，我们通过事件循环来调度协程`

## 生成器和协程的区别联系

- 含有 `yield` 的是生成器

- 生成器只能读一遍就空了， 下次读时会报错

## 优缺点

我们可以直接创建一个数据非常多的列表，但是受到内存限制，列表容量肯定是有限的；所以，如果列表元素可以按照某种算法推算出来，生成器可以**在循环的过程中不断推算出后续的元素呢**，这样就不必创建完整的 list，从而节省大量的空间

# 其他

# 参考资料

- [理解 Python 协程: 从 yield/send 到 yield from 再到 async/await](https://blog.csdn.net/soonfly/article/details/78361819)

- [生成器会比 `for` 循环快吗](https://www.cnblogs.com/tlz888/p/9365997.html)
