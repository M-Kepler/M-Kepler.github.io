- [参考资料](#参考资料)
- [★ 闭包](#-闭包)
  - [闭包理解](#闭包理解)
  - [全局变量 `global`、`nonlocal`](#全局变量-globalnonlocal)
  - [跨模块共享全局变量 `g`](#跨模块共享全局变量-g)
- [★ 装饰器](#-装饰器)
  - [什么是装饰器](#什么是装饰器)
  - [装饰器的执行顺序](#装饰器的执行顺序)
  - [不带参数的装饰器](#不带参数的装饰器)
  - [带参数的装饰器](#带参数的装饰器)
  - [用类作为装饰器](#用类作为装饰器)
  - [装饰类的装饰器](#装饰类的装饰器)
  - [类静态成员函数作为装饰器](#类静态成员函数作为装饰器)
  - [装饰类成员函数的装饰器](#装饰类成员函数的装饰器)
  - [`memoization` 装饰器缓存结果](#memoization-装饰器缓存结果)
- [其他](#其他)

# 参考资料

- [12 步轻松搞定 Python 装饰器](https://www.jianshu.com/p/d68c6da1587a)

- [Python 闭包与 nonlocal](https://www.jianshu.com/p/703ad1289a00)

# ★ 闭包

## 闭包理解

```py
def outer():
    x = 1
    def inner():
        # 解释器会尝试查找变量x
        # 当然在函数的本地作用域里面是找不到的
        # 所以接着会去上层的作用域里面去查找
        print(x)
    return inner()
outer()


def outer():
    x = 1
    print(x)  # 输出 1
    def inner():
        x = 11
        print(x) # 输出 11
    inner()
    # 输出 1 # XXX 闭包只可以访问不能修改？
    print(x)
```

- 嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间

- 根据闭包的特性，使用变量时，解释器在函数作用域内查找该变量，如果在本地作用域找不到，则接着往上层的作用域去查找

- 你也可以把它当做一个类似于面向对象的技术：`outer` 像是给 `inner` 服务的构造器

- `global`

  ```py
  a = 111
  def test4():
    a = 100
    def b():
      global a  # 在函数A内的函数B，可以直接修改函数A作用域下的内容，闭包
      a = 2     # 指明了 a 是全局变量，这里如果不做操作，直接print会报错 name 'a' is not defined
      print(a)  # 输出111，全局变量会从内往外找
                # 如果没有test4外部的那个 a = 111 的定义，则输出是 2
    b()

  test4()
  print(a)      # 输出是 2
  ```

## 全局变量 `global`、`nonlocal`

- 当需要定义一个变量，让模块内所有的代码都可以访问到的时候，可以使用 `global` 关键字来声明

- 全局变量的作用域是模块级别的，如果你想让本文件内的变量可以方便地被其他文件中被访问，可以定义为全局变量

- [`global` 和 `nonlocal` 的区别](https://blog.csdn.net/xcyansun/article/details/79672634)

  - `global` 关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量

  - `nonlocal` 关键字修饰变量后标识该变量是`上一级函数中的局部变量`，如果上一级函数中不存在该局部变量，nonlocal 位置会报错（最上层的函数使用 nonlocal 修饰变量必定会报错）。

- 内置的函数 `globals` 返回一个包含所有 `Python` 解释器知道的变量名称的字典

  ```py
  >>> globals()
  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}

  >>> global a
  >>> a = 100
  >>> globals()
  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'a': 100}
  >>>
  ```

- 解析器发现函数中某个变量被 `global` 关键字声明，就会去函数的 `__globals__` 字典中寻找；同时一个模块中每个函数的 `__globals__` 字典变量都是模块 `__dict__` 字典变量的应用，二者完全相同

- 如果想要在函数内修改函数外的值，那这个变量必须是用 `global` 修饰的

  ```py
  a = 10  # 全局变量
  def test():
      a = 111  # 局部变量
  print(a)  # 没有改变还是10

  aa = 10
  def test2():
      aa = 20
      # 告诉编译器，这个aa是一个全局变量，应该去 test2().__globals__中去查找，而不是本函数内的这个 aa 变量
      global aa
      # global aa = 100 global知识告诉编译器，不能这样用啊
      aa = 100
  print(b)  # 输出100

  def test3():
    aa = 20  # 局部变量
    test2()
    pritn(aa) # 仍然是20
  ```

- `nonlocal` 声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。

  ```py
  aa = 0
  def outer():
    aa = 111
    print(aa) # 111
    def inner():
      # nonlocal aa # 表示外部嵌套函数的变量，而不是全局的那个aa
      aa = 22
      print(aa) # 22
    inner()
    print(aa) # 111，加上 nonlocal 后，被 函数 inner 修改了，所以输出为22
  ```

- Python2 中没有 `nonlocal` 关键字，可以通过定义可变变量（比如列表）来实现在嵌套函数内修改外部函数的变量

  ```py
  def outer():
    aa = [True]
    def inner():
      aa[0] = False
    print(aa)
  ```

## 跨模块共享全局变量 `g`

- 创建一个特殊模块。在应用程序的所有模块中导入配置模块。该模块将作为跨模块的全局变量提供。

- 为了解决一些对象相互访问，防止循环 import 而引入的一个根对象，有需要被访问的对象，在主函数中注册到 g 上，这样所有相关模块访问 g 就行了

  ```py
  # -*-coding:utf-8-*-


  class GlobalVarManager(object):
      """
      全局配置，可通过g.xxx来绑定属性
      """
      moa_token = dict()


  g = GlobalVarManager()

  ```

# ★ 装饰器

- 把函数 A 包裹在函数 B 中，函数 B 内部可以在调用函数 A 前后做一些处理

- 在函数内部定义一个函数，装饰器其实就是返回值一个函数

- 可以把函数作为参数传入的语言，都可以实现装饰器（比如 C++ 的函数指针作为参数）

## 什么是装饰器

- [Python 各种类型装饰器详解说明](https://blog.csdn.net/five3/article/details/83447467)

- 定义

  - 本质上是一个`可调用的对象` (callable)，所以装饰器一般可以由函数、类来实现

  - 装饰器本身需要`接受一个被装饰的对象作为参数`，该参数通常为函数、方法、类等对象。

  - 装饰器需要`返回一个对象`，该对象可以是 经过处理的原参数对象、一个包装且类似原参数的对象；或者返回一个不相干内容 (通常不建议使用)。

- 既然说需要是一个`可调用的对象` (callable)，所以装饰器一般可以由函数（函数本身就是可调用的）、类（类的实例无法直接调用，但是如果实现了 `__call__` 也是可以直接调用的，鸭子类型嘛）来实现

- 所以最简单的装饰器可以定义为

  ```py
  def deco(obj):
      return obj

  # 只不过，一般会多套一层
  def deco(func):
      def deco_1(func):
          # do_something
      return deco_1
  ```

## 装饰器的执行顺序

- 多个装饰器叠加时，装饰器执行顺序是由内到外的，也好理解，就一层层套嘛

  ```py
  from functools import wraps

  def log1(func):
    @wraps(func)
    def wrapper(*args, **kw):
        print('in log1, call %s()' % func.__name__)
        func(**args, **kw)
    return wrapper

  #log2 实现和 log1 一样

  @log1
  @log2
  def t():
      pass
  t()
  # 输出：
  # in log2, call t()
  # in log1, call t()
  ```

## 不带参数的装饰器

- 在函数调用前后自动打印日志，但又不希望修改函数的定义，其实就是在调用函数前后先执行别的代码，再调用这个函数。那么问题来了，装饰器名称又不是函数的名称，调用函数的时候还是用旧的函数名啊，而且参数怎么传

  ```py
  def log(func):
    # 装饰器的工作就是返回一个函数
    def wrapper(*args, **kw):
        # 根据闭包的特性，内部函数可以访问外部的变量 func
        # func 不用作为参数传进来
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper

  @log  # 相当于 test = log(test)
  def test(a, b):
      pass

  def test2(a, b):
      pass
  # 也可以把装饰器装饰后的函数独立成一个函数去用 wrapper = log(test)
  wrapper = log(test2)
  wrapper()

  print(test.__name__)
  # 加装饰器前返回 test
  # 加装饰器后 wrapper
  ```

- 函数是怎么传入到装饰器函数里的？要知道这是个语法糖，还是要从他本质执行的语句出发

- 调用`test`的时候实际上调用的是 `test = log(test)`，同名的函数 `test` 变量指向了`log`返回的`wrapper`这个新函数，即 `log(test)`，语法糖 `@` 就是做了上面这个过程

- 为什么要多定义一个 `wrapper` 函数包在 `log` 里？

  ```py
  # 为了封装吧，装饰器返回的是一个函数，而不是直接处理
  # 所以装饰器可以作为普通函数那样去调用

  def log(func, *args, **kwargs):
      print('call %s()' % func.__name__)
      return func(*args, **kwargs)

  @log
  def t():
      pass
  ```

- `@wraps(func)`

  经过装饰的函数其实是另一个函数了，即被装饰函数 func 的上层函数的函数名 `wrapper`，所以被装饰函数 func 的 `__name__` 属性就不再是原来的那个名字了。需要把名字改回原来的即：`wrapper.__name__ = func.__name__`。装饰器 `@wrapper` 的作用就是这个

  加载装饰器就是将原函数名与装饰器内部的 wrapper 函数进行偷梁换柱，执行装饰器实际上就是执行装饰器内部的 wrapper 函数。

  `@wraps` 套在最内层那个函数上面，即调用 func 的那个函数

  ```py
  from functools import wraps
  def log(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('call %s()' % func.__name__)
        return func(*args, **kwargs)
    return wrapper

  @log
  def t():
      pass

  print(t.__name__)
  # 加装饰器前返回 test
  # 加装饰器后也是 test
  ```

- 也可以不用装饰器，因为其实装饰器也是个函数，直接调用也是可以的

  ```py
  from functools import wraps


  def _result_format(func, catch_exception=True):
      @wraps(func)
      def result_format_wrapper(*args, **kwargs):
          try:
            print('do something ...')
          except Exception as ex:
            if not catch_exception:
                raise
      return result_format_wrapper


  def make_request_handler_wrapper(func, catch_exception):
      f = func
      f = _result_format(f, catch_exception)

      # func 为原始的那个函数，f 为装饰后的函数
      f = wraps(func)(f)
      return f


  if __name__ == "__main__":
      def test():
          print('in test func')

      wrapper_func = make_request_handler_wrapper(test, True)
      wrapper_func()
  ```

## 带参数的装饰器

知道了装饰器其实就是返回一个函数，在这个函数里先调用其他代码才调用实际的函数

```py
# 因为装饰器需要参数，所以再包装一层
def log(dec_arg):
    def deco(func):
        def wrapper(*args, **kw):
            print('got arg:%s, call %s():' % (dec_arg, func.__name__))
            return func(*args, **kw)
        return wrapper
    return deco

# 相当于 test = log('hello')(test); test(1, 1)
@log('hello')
def test(a, b):
    pass

# 首先执行 log('hello')，返回的是 deco 函数(这个就像不带参数的装饰器)
# 再调用返回的这个函数，参数是 test 函数，返回值最终是 wrapper 函数。
```

## 用类作为装饰器

[用类作为装饰器装饰函数!](https://blog.51cto.com/853056088/2159162)

```Python
class A(object):
    def __init__(self,func):
        print('定义初始化函数')
        print('func name is %s'%func.__name__)
        self.__func = func

    def __call__(self):
        print('call 方法作为装饰器中的功能')
        self.__func()
        print('增加的功能2')

# @A
def B():
    print('这个B是原函数')

# A(B)

# 如果不看装饰器的作用的话, 这里的 A(B)和上面的 @A相等作用相同,但是这里的作用就不是装饰器了, 就只是简单的函数调用了, 所以就不会调用call方法了
```

## 装饰类的装饰器

```Python

def log_getattribute(cls):
    """ 覆盖类的某个方法
    """
    orig_getattribute = cls.__getattribute__

    def new_getattribute(self, name):
        print('getting %s in decorator' % name)
        return orig_getattribute(self, name)

    # 修改类的 __getattribute__ 为装饰后的方法
    cls.__getattribute__ = new_getattribute
    print("in decorator")
    return cls

@log_getattribute  # 这里定义类的时候就调用装饰器了，而不是实例化的时候
class Test:
    def __init__(self, age):
        self.age = age
        print("module's __init__")

if __name__ == "__main__":
    m = Test(25)
    m.age
```

- `@unique`

## 类静态成员函数作为装饰器

和装饰类成员函数的装饰器一样，可以把装饰器放到类下面

```py
from functools import wraps

class Test(object):
    # 和函数装饰器一样，只是作用域放在了类里面
    @staticmethod
    def deco_1(arg1, arg2):
        print("decorator got args: %s, %s" % (arg1, arg2))
        def deco_2(func):
            @wraps(func)
            def deco_func(*args, **kwargs):
                return func(*args, **kwargs)
            return deco_func
        return deco_2


@Test.deco_1(1, 2)
def test():
    print("in test")

print(test.func_name)
test()

```

## 装饰类成员函数的装饰器

> 比如 `@staticmethod`

在类里面定义一个装饰器套在其他类成员上面

```py
# 这个装饰器也是可以放到类里面的
def catch_exception(origin_func):
  # 如果在发生异常的时候，需要调用类里面的另一个方法来处理异常，多加一个 `self` 参数
  def wrapper(self, *args, **kwargs):
      try:
          u = origin_func(self, *args, **kwargs)
          return u
      except Exception:
          self.revive() # 不用顾虑，直接调用原来的类的方法
          return 'an Exception raised.'
  return wrapper

class Test(object):
    def __init__(self):
        pass
    def revive(self):
        print('revive from exception.')
        # do something to restore
    @catch_exception
    def read_value(self):
        print('here I will do something.')
        # do something.
```

## `memoization` 装饰器缓存结果

> 递归优化里面不就有这个吗，记忆化搜索

- [Python 函数记忆化](https://www.jianshu.com/p/c0e6cf0109ab)

  一种利用缓存来加速函数调用的技术手段，将消耗较大的调用结果存储起来，当再次遇到相同调用时就从缓存读取结果而无需重新计算，这种方法叫做 `LRU（Least Recently Used）`缓存算法

- `@` 符号是 Python 的装饰语法。它不只用于追查，锁或日志。你可以装饰一个 Python 函数，记住调用结果供后续使用。这种技术被称为 `memoization`

- 关键思想是：后一次的计算**依赖前一次的计算结果**，所以我们可以把前面的结果缓存起来，下一次计算的时候直接从缓存内取

- 递归中可以考虑是否适用，下面的代码以递归最典型的斐波那契数列为例

```py
# from functools import lru_cache  # 自带的一个缓存装饰器
from functools import wraps

def memo(func):
    cache = {}
    @wraps(func)
    def wrap(*arg):
        if arg not in cache:
            cache[arg] = func(*arg)
            return cache[arg]
    return wrap

#lrc_cache(maxsize=1000)
@memo
def fib(input):
    """ 斐波那契数列
    可以尝试下去掉加装饰器前后的计算速度对比
    """
    if input < 2:
        return 1
    return fib(input-1) + fib(input-2)

from datetime import datetime
for n in range(40):
    start = datetime.now()
    # fib当前项与前一项的商
    print(n, ":", fib(n)/fib(n-1))
    end = datetime.now()
    print("delta time for %s: %s\n" % (n, (end - start)))
```

# 其他
