- [参考资料](#参考资料)
- [★ 内存管理、垃圾回收](#-内存管理垃圾回收)
  - [如何在 Python 中管理内存](#如何在-python-中管理内存)
  - [引用计数机制](#引用计数机制)
  - [分代回收策略](#分代回收策略)
  - [★ `weakref`](#-weakref)
- [其他](#其他)
  - [当 Python 退出时，为什么不清除所有分配的内存](#当-python-退出时为什么不清除所有分配的内存)

# 参考资料

# ★ 内存管理、垃圾回收

- [Python 是如何处理垃圾的](https://mp.weixin.qq.com/s/FjR0K5LGKoLHi4JsRqj02A)

- [什么是 Python 的内存管理机制](https://blog.csdn.net/fengdu78/article/details/108332789)

`Python` 中的变量无需事先申明，变量无需指定类型，程序员无需关心内存管理，`Python` 解释器给你自动回收。开发人员不用过多的关心内存管理机制，这一切全部由内存管理器承担了复杂的内存管理工作

## 如何在 Python 中管理内存

Python 中的`内存管理由 Python 私有堆空间管理`。所有 Python 对象和数据结构都位于私有堆中。程序员无权访问此私有堆。python 解释器负责处理这个问题。

Python 对象的堆空间分配由 Python 的内存管理器完成。核心 API 提供了一些程序员编写代码的工具。

Python 还有一个内置的垃圾收集器，它可以回收所有未使用的内存，并使其可用于堆空间。

## 引用计数机制

> 主要以 `引用计数` 为主，`标记清除` 和 `分代清除` 为辅的机制

- 当有一个变量保存了对象的引用时，此对象的引用计数就会加一；但是用 `del` 删除变量指向的对象时，如果对象的引用计数不为一，此时会将计数减一；如果已经是一了，再 `del`，那就会真的把对象删除

- 强制回收

  ```py
  import gc
  gc.collect()
  ```

- 查看对象的引用计数

  ```Python
  import sys
  a = [1, 3]
  sys.getrefcount(a)
  # 参数传递给 getrefcount() 时，创建了一个临时的引用, 因此输出结果为 2
  ```

- 垃圾回收时，Python 不能进行其它的任务。`频繁的垃圾回收将大大降低 Python 的工作效率`。如果内存中的对象不多，就没有必要总启动垃圾回收。

  `只会在特定条件下，自动启动垃圾回收`。当 Python 运行时，会记录其中分配对象和取消分配对象的次数。当两者的**差值高于某个阈值时，垃圾回收才会启动**

  ```py
  import gc

  # 查看 gc 阈值
  >>> print(gc.get_threshold())

  # (700, 10, 10)  700 即是垃圾回收启动的阈值
  # (700, 10, 10) 两个 10 是指 每 10 次 0 代垃圾回收，会配合 1 次 1 代的垃圾回收；而每 10 次 1 代的垃圾回收，才会有 1 次的 2 代垃圾回收
  # sys.set_threshold(1, 2, 1) 可以自行设置阈值
  ```

## 分代回收策略

> 这一策略的基本假设是，**存活时间越久的对象，越不可能在后面的程序中变成垃圾**，程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些 “长寿” 对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率

- 将内存`根据对象的存活时间划分为不同的集合，每个集合称为一个代`。所有的新建对象都是 0 代对象

- **当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象**

- 垃圾回收启动时，一定会扫描所有的 0 代对象。`如果 0 代经过一定次数垃圾回收`，那么就启动对 0 代和 1 代的扫描清理。`当 1 代也经历了一定次数的垃圾回收后`，那么会启动对 0，1，2，即对所有对象进行扫描。

## ★ `weakref`

- [Python 中的弱引用](https://blog.csdn.net/fang_chuan/article/details/88889391)

- 内置的 `weakref` 库，允许开发者创建一个对象的弱引用，即对象如果有一个弱引用，还是会被删除

- 在树形结构中父子`节点之间相互存在引用关系`, 所以造成死锁, 不会真的删除对象实例

  ```py
  # 为了防止这种因为相互应用而导致无法垃圾回收
  import weakref
  a = Node()
  # 创建弱应用
  a_weakref = weakref.ref(a)

  # 为了访问弱应用的对象，可以先函数一样调用即可
  # 如果那个对象还存在，就会返回，否则返回None
  print(a_weakref())
  ```

- 弱引用消除了循环导入的这个问题，本质来讲，弱引用就是一个对象指针，它不会增加它的引用计数

# 其他

## 当 Python 退出时，为什么不清除所有分配的内存

当 Python 退出时，尤其是那些对其他对象具有循环引用的 Python 模块或者从全局名称空间引用的对象并没有被解除分配或释放。

无法解除分配 C 库保留的那些内存部分。

退出时，由于拥有自己的高效清理机制，Python 会尝试取消分配 / 销毁其他所有对象。
