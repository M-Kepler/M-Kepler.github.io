- [单元测试](#单元测试)
  - [`test_client` 后台测试](#test_client-后台测试)
  - [界面自动化测试](#界面自动化测试)

# 单元测试

- [Flask 中三种测试方法](https://blog.csdn.net/hyman_c/article/details/54632664)

## `test_client` 后台测试

- unittest

  ```py
  #coding:utf-8
  import unittest
  from flask import url_for, create_app

  class Test(unittest.TestCase):
      def setup(self):
          self.app = create_app("test")
          self.client = self.app.test_client()
          self.app_ctx = self.app.app_context()
          self.app_ctx.push()

      def tearDown(self):
          self.app_ctx.pop()

      def test_view_func(self):
          # 测试 view function
          resp = self.client.get(url_for("main.index"))
          self.assertEqual(rep.status_code,200)

  if __name__ == "__main__":
      unittest.main()
  ```

- 单独测试

  ```py
  def test():
      test_app = Flask('self_test_name')
      test_app.testing = True

  class TestResource(Resource):
      def do_get(self):
        pass

  def is_ret_ok():
      """
      校验返回格式
      {
          'success': 1,
          'data': {
              xxx
          }
      }
      """
      pass

  with test_app.test_request_context():
      # test_request_context 创建一个 HTTP 请求环境，要不然不能直接调用 http 处理的代码
      url = "/reg/test_data/?abc=123"
      with test_app.test_client() as client:
        test(client.get, is_ret_ok)(url)
  ```

- `POST` 请求

  ```py
  client.post(url)
  # 如果有数据的话
  client.post(url, data=data)
  # 如果要得到返回结果
  client.post(url, data=data).data
  ```

- `GET` 请求

  ```py
  client.get(url)
  # 如果有数据的话
  client.get(url, query_string=payload)
  # 如果要得到返回结果的话
  client.get(url, query_string=payload).data
  ```

## 界面自动化测试

```py
import unittest
import threading
import re
from selenium import webdriver
from app import create_app

class SseleniumTest(unittest.TestCase):
  @classmethod
  def setUpClass(cls):
    try:
        cls.client = webdriver.FireFox()
    except expression as Exception:
        pass
    if cls.client:
        cls.app = create_app("testing")
        cls.app_ctx = cls.app.app_context()
        cls.app_ctx.push()
        threading.Thread(target=cls.app.run).start()

  @classmethod
  def tearDownClass(cls):
      # 增加shutdown的view funciton，当访问这个地址时就abort中断
      cls.clint.get("http://localhost/shutdown")
      cls.client.close()
      cls.app_ctx.pop()

  def test_login(self):
    pass

  # view.py
  @app.route("/shutdown")
  def shutdown():
      if not current_app.testing:
          abort(404)
      shudown = request.environ.get('werkzeug.server.shutdown')
      if not shutdown:
          abort(505)
      shutdown()
      return "closing flask server"
```
