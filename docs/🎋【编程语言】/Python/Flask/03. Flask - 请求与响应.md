- [`Request` 请求](#request-请求)
  - [`ImmutableMultiDict`](#immutablemultidict)
  - [`request` 请求上下文](#request-请求上下文)
  - [属性](#属性)
  - [请求钩子](#请求钩子)
  - [请求参数](#请求参数)
- [`Response` 响应](#response-响应)
  - [返回响应](#返回响应)
  - [Response 对象](#response-对象)
  - [cookies](#cookies)
  - [headers](#headers)
  - [重定向](#重定向)
    - [重定向如何携带数据](#重定向如何携带数据)
  - [异常中断](#异常中断)
  - [返回 josn 数据](#返回-josn-数据)
- [其他](#其他)
- [参考资料](#参考资料)

# `Request` 请求

Flask 处理请求的流程

```sh
接收请求 --> 创建请求上下文 --> 请求上下文入栈 -->
创建该请求的应用上下文 --> 应用上下文入栈 --> 处理逻辑 -->
请求上下文出栈 --> 应用上下文出栈
```

## `ImmutableMultiDict`

[怎么将 flask 里面的 request.args 这个 ImmutableMultiDict 变成 MutiDict 类型](https://segmentfault.com/q/1010000002802028)

## `request` 请求上下文

request 请求对象 封装了所有与请求相关的信息 如：请求消息头 请求数据 请求路径

## 属性

[通过 Flask 的 request 对象获取 url](https://blog.csdn.net/Lin_Hv/article/details/106661594)

| 方法                  | 说明                                | 类型              |
| :-------------------- | :---------------------------------- | :---------------- |
| `request.headers`     | 获取请求消息头的信息                | `EnvironHheaders` |
| `request.method`      | 获取本次请求的请求方式              | `GET/POST/...`    |
| `request.args`        | 获取使用 GET 请求方式提交的数据     | `MultiDict`       |
| `request.form`        | 获取使用 POST 请求的方式提交的数据  | `MultiDict`       |
| `request.values`      | 获取 GET 和 POST 请求方式提交的数据 |                   |
| `request.cookies`     | 获取 cookies 中的信息               | `Dict`            |
| `request.path`        | 获取请求头的 **url 地址**           |                   |
| `request.files`       | 获取用户上传的文件                  |                   |
| `request.full_path`   | 获取请求的完整路径                  |                   |
| `request.url`         | 获取 url 的**完整路径**             |                   |
| `request.remote_addr` | 获取客户端 IP                       |                   |

```py
from flask import request
@main.route('/main/index', methods=['GET', 'POST'])
def index():
    host_url = request.host_url

http://127.0.0.1:5000/main/index?page=10

# request.path:           /main/index
# request.host:           127.0.0.1:5000
# request.host_url:       http://127.0.0.1:5000/
# request.full_path:      /main/index?page=10
# request.script_root:
# request.url:            http://127.0.0.1:5000/main/index?page=10
# request.base_url:       http://127.0.0.1:5000/main/index
# request.url_root:       http://127.0.0.1:5000/
```

## 请求钩子

[flask 基础之请求钩子（十二）](https://www.cnblogs.com/cwp-bg/p/10094912.html)

- `Flask` 把这些被装饰器装饰的函数添加到列表中，比如 `before_request` 钩子函数则添加到 `app.before_request_funcs` 列表中，请求钩子的执行顺序按 `加载顺序` 执行；像上下文管理器一样，在进入/退出请求前后做一些处理

  | 装饰器                      | 说明                                                                             |
  | :-------------------------- | :------------------------------------------------------------------------------- |
  | `@app.before_first_request` | 在处理第一个请求之前运行                                                         |
  | `@app.before_request`       | 在每次请求到来之前（即进入到 app.route 注册的处理函数之前）运行                  |
  | `@app.after_request`        | 在每次请求正常完成（没有异常退出）（即已经完成请求处理，形成 response 了）才运行 |
  | `@app.teardown_request`     | 装饰的函数无论有没有异常都执行                                                   |

  ```py
  @app.before_request
  def func_before_every_request():
      # 每次请求来的时候都会进来，可以做一些认证工作
      print("do something before every request")
  ```

- 在蓝图的请求钩子

  蓝图是为了在大型应用中对众多的业务模块的 api 分层次管理，所以即使在主 app 下定义的路由规则，其默认是在 None 为名字的蓝图下面的，所以蓝图也有自己的请求钩子，只在该蓝图下的 api 其作用。

  ```py
  # 在Flask中如果使用蓝图的话，可以针对蓝图做请求钩子
  from flask import Blueprint
  auth = Blueprint("auth", __name__)

  @auth.before_request
  def auth_before_req_func():
      print("auth module")

  # 蓝图也可以为主app添加请求钩子
  # before_app_first_request装饰会在app的before_first_request_funcs列表中，以None为键；
  # XXX 还是没理解这里。。。我看 app.before_request_funcs 也没有啊
  @auth.before_app_request
  def auth_before_app_req():
      pass
  ```

- 可以针对某些特定的 url 加钩子吗

  这个不需要依赖请求钩子吧。自己写个装饰器得了

  ```py
  def admin_request(func):
    @wraps(func)
    def decorator(*args, **kwargs):
      if current_user.is_administrator():
        return func(*args, **kwargs)
      else:
        abort(403)
    return decorator
  ```

## 请求参数

**GET 请求**

```py
arg1 = request.args.get("arg1")
arg2 = request.args.get("arg2")

```

**POST 请求**

# `Response` 响应

## 返回响应

[Flask 基础 - 关于响应 Response 的浅析](https://cloud.tencent.com/developer/article/1441949)

- `Response` 对象在调用视图函数处理逻辑后就被创建，但是对客户端的响应在应用上下文出栈后执行

- HTTP 请求完成后，向前端返回 `Response` 对象

  ```py
  @app.route('/about/')
  def about():
    resp = Response(response="about page",
                    status=200,
                    content_type="text/html;charset=utf-8")
    return resp
  ```

- 返回元组

  ```py
  @app.route("/about/")
  def about():
    # 页面报404错误，并把信息展示在界面上
    return "not found", 404
  ```

- 返回字符串

  ```py
  @app.route("/about/")
  def about():
    # 界面会直接显示字符串，即http状态码为200
    return "hello world"
  ```

- 返回模板

  ```py
  @app.route("/about/")
  def about():
    # /templates/about.html
    return render_template("about.html")
  ```

- 重定向

  ```py
  from flask import redirect
  @app.route('/')
  def index():
    return redirect('http://www.baidu.com')
  ```

- 继承响应类，进行自定义

  `Response` 在 `Flask` 框架中是一个类，当 `application` 的 `view` 方法处理完成，返回结果的时候，会判断结果的类型，如果是 `string`，则返回 `text/html`, 如果是 `tuple`也一样，如果是一个 `response`对象，则直接返回，否则会调用 `force_type` 方法。

  如果只是单单返回 `json` 格式，用 `jsonity` 就可以了，但是为了规范化，我们需要对返回格式做格式话，`success` 表示请求是否成功， `data`表示请求返回的数据

  ```py
  from flask import jsonity, app
  from werkzeug.wrappers import Response


  class JSONResponse(Response):
      """
      继承 Response，并重写 force_type 方法
      default_mimetype="application/json"
      """

      @classmethod
      def force_type(cls, data, environ=None):
          if isinstance(data, dict):
              info = {
                  "success": 1,
                  "data": data
              }
              response = jsonity(info)
          return super(JSONResponse, cls).force_type(data, environ)

  app = Flask(__name__)
  # 指定app的响应处理类为自定义的响应类
  app.response_class = JSONResponse

  @app.about("/about/"):
  def abou():
      return {"message": "about page"}
  ```

## Response 对象

- 把响应内容封装到一个对象中，可以完成更多的响应行为，比如 `cookies`

- 属性

  | 属性                       | 说明                                                      |
  | -------------------------- | --------------------------------------------------------- |
  | `response.data`            | 获取二进制的响应 body 数据                                |
  | `response.charset`         | 响应对象的编码                                            |
  | `response.headers`         | 获取响应对象的头部信息                                    |
  | `response.status`          | 获取字符串格式的响应状态码                                |
  | `response.status_code`     | 获取整形格式的响应状态码                                  |
  | `response.set_cookie()`    | 设置 `cookie`, 浏览器后续的请求会带上我们设置的 `cookies` |
  | `response.max_cookie_size` | 允许的默认 cookie 最大字节数                              |
  | `response.delete_cookie()` | 删除 `cookie`                                             |

- `make_response(string, status_code, headers)` 返回的也是一个 Response 对象

- [`response` 中不能包含中文的问题](https://blog.csdn.net/xiongzaiabc/article/details/107128226)

  用户名会限制不允许使用中文，因为在 `set_ticket_cookie` 时，需要把 ticket 设置到 cookie 里，ticket `AuthCookie=Login:管理员admin:61123834::` 中会包含用户名，而 Flask 的 response 对象如果包含汉字，会报错：

  ```py
  # 报错信息
  filters.py:346 unexpected error:  Traceback (most recent call last):   File "/usr/lib/python2.7/site-packages/bbc/lib/cgilib/filters.py", line 344, in log_if_exception_wrapper     result = func(*args, **kw)   File "/dc/var/www/bbc/entry.py", line 382, in index     set_ticket_cookie(response, user_info['ticket'].encode('latin1')) UnicodeEncodeError: 'latin-1' codec can't encode characters in position 6-8: ordinal not in range(256)

  # 解决方法
  '你的字符串'.encode("utf-8").decode("latin1")

  # 此时通过浏览器查看，cookie 中的中文是乱码：
  # BBCAuthCookie=Login:æ¸©å¾·æ£®:61206DA0::D
  ```

- [cookies 中文乱码](https://blog.csdn.net/weixin_30682127/article/details/102239841)

  太麻烦了，cookie 中记录的用户不用用户名了，用唯一标识，`AuthCookie=Login:wends001:xxxxx`

## cookies

在上面 Response 属性可以看到 `cookies` 只不过是响应头的一部分，其实就是把 cookies 放到响应中返回给浏览器

所以也可以通过 `response.headers.add` 添加到请求头，设置上 cookie

```py
corpcode_cookie = '%s=%s; Secure; HttpOnly; Path=/' % ("Corpcode", "12345678")
response.headers.add('Set-Cookie', corpcode_cookie)
```

`set_cookie` 方法会在生成的响应报文首部中创建一个 `Set-Cookie` 字段，即 `"Set-Cookie: name=xxx;Path=/"`，效果一样

```py
from flask import make_response
@app.route('/')
def index():
    response = make_response('<h1>test</h1>')
    # 响应返回之后设置一个 cookies，在访问页面后，可以看到网站中多了这个cookie

    """
    1、max_age：距离现在多少秒后过期，在 IE8 以下不支持
    2、expires：datatime 类型，使用此参数，需参照格林尼治时间，即北京时间 - 8 个小时
    3、如果 max_age 和 expires 都设置了，则以 max_age 为参准
    4、若没有设置过期时间，则默认为浏览会话结束，即关闭浏览器（是关闭浏览器，不是关闭页面）时过期
    """

    response.set_cookie('until_close', 'cookie_value')
    response.set_cookie('after_60s', 'cookie_value', max_age=60)
    response.set_cookie('expires_at', 'cookie_value', expires=3600)

    # 获取cookies
    cookie_answer = response.cookies.get("answer")

    # 删除cookies，为什么不是真正删除，而是把过期时间设置为0，即无效
    response.delete_cookie('answer')
    # response.headers['X-Something'] = 'A value'
    return response
```

## headers

## 重定向

### 重定向如何携带数据

[Flask 设置 cookie 重定向](https://blog.csdn.net/Shen1105/article/details/97894269)

需求是 `a.com` 需要单点登录到 `b.com`；

`a.com` 向 `b.com/token_login` 发 HTTP 请求，获取登录凭证； `token_login` 接口会在响应体中设置 cookie，在返回的数据中包含一个 `CSRFPreventionToken` csrf token，这个 token 在后续的所有业务请求中都会带上；

本来想的是需要一个中转页来做跳转，这样才能把 cookie 设置到浏览器下，而且让前端把 CSRFPreventionToken 保存到浏览器，但是这样会有跨域的问题， cookie 都设置在 `a.com` 域下了；

由于 `a.com` 到 `b.com` 中间还有一个代理服务器，所以想到用 Nginx 的 `proxy_cookie_domain a.com b.com;` 在代理的时候把 cookie 设置到 b.com 域下；

这样解决了跨域的问题，但是要 `a.com` 还是要提供一个中转页面来接受 cookie；

之所以执着于加中转页面，是因为要接受这个响应报文，报文里有设置 cookie，而且前端还要把响应中的 `CSRFPreventionToken` 保存到浏览器，后续所有请求的请求头里都会带上；

但实际上直接由 `b.com` 做重定向就可以了，可以在重定向的时候，设置 cookie

```py
# 重定向的响应
response = make_response(redirect("./index", "302"))

##### 设置请求头，这就不通过返回数据的方式给前端了，直接自行设置上去
response.headers['CSRFPreventionToken'] = login_info['csrf_token']

# 设置 cookie
corpcode_cookie = '%s=%s; Secure; HttpOnly; Path=/' % ("Corpcode", "12345678")
response.headers.add('Set-Cookie', corpcode_cookie)

response.set_cookie("Corpcode", "12345678", max_age=)

return response
```

## 异常中断

如果需要中断 `request`，可以使用 `abort(500)` 或者直接 `raise Exception`，当然我们还需要返回一个出错信息给前端

- `abort(http_status_code, description)` 入参状态码和描述信息，默认把 http 常见的状态码都包含进去了，定义在 `werkzeug库/http.py/HTTP_STATUS_CODES`，如果传入的状态码非 http 状态码，会报错

  ```py
  from flask import abort
  @auth.route('/index')
  def func():
      """
      默认返回404错误页面
      """

      abort(404)
  ```

- 自定义状态码对应的中断处理

  ```py
  @auth.errorhandler(404)
  def page_not_found(error):
      """
      注册蓝图中的错误处理器，即捕捉auth蓝图下的所有的404中断
      """
      return render_template('404.html'), 404

  @auth.app_error_handler(404)
  def g_page_not_found(error):
      """
      注册全局的404状态码中断处理函数，无论哪个试图，都由这个函数做处理
      """
      pass
  ```

## 返回 josn 数据

- `jsonify`

  ```py
  from flask import jsonity

  @app.route("/")
  def test():
    tasks = [{
      'id': 1,
      'name': 'huangjinjie'
    }]

    return jsonity(dict(tasks=tasks))
  ```

- [`jsonity` 和 `json.dumps` 有什么区别](https://www.jianshu.com/p/a25357f2d930)

  - `json.dumps()` 会在键值的冒号后面加一个空格，逗号后面也有空格，而 `jsonity`则没有，相对来说数据量较小

    ```py
    ret = {"name": "huangjinjie", "age": 25}
    return json.dumps(ret)
    # {"name": "huangjinjie", "age": 25}

    return jsonity(ret)
    # {"name":"huangjinjie","age":25}
    ```

  - 返回的时候 `jsonity` 会指定响应的 `Content-Type`为 `application/json`，而 `json.dumps()` 则还是默认的 `text/html; charset=utf-8`

    ```py
    # 当然也可以自己使用json.dumps，然后指定content-type
    def my_make_response(data):
        json_str = json.dumps(data, ensure_ascii=False)
        response = make_response(json_str)
        response.headers['Content-Type'] = 'application/json; charset=utf-8'
        return response
    ```

# 其他

# 参考资料

[Flask Request 中 form、data、files、json、values 属性](https://mp.weixin.qq.com/s?__biz=MjM5MzgyODQxMQ==&mid=2650378756&idx=1&sn=7ca7884a02d3d08a7caa5701c93c96a1&chksm=be9c295089eba046b3130e02bc03f9e73eabe9357c3c4f091d766946e31dafe9fade5e512ff1&scene=90&subscene=93&sessionid=1660040198&clicktime=1660040201&enterid=1660040201&ascene=56&realreporttime=1660040201856&forceh5=1&devicetype=android-31&version=28001951&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&session_us=gh_c744c4d09c36&exportkey=AzIIiOU2zp24%2B%2BUdTFGMMHw%3D&pass_ticket=rIWFHcxTSq3I76M5Sv5gB%2Fr143XuLMdpeId8vIiIxM4%2FudB24BGhI%2BOwkZqnGi6s&wx_header=3)
