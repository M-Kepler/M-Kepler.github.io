- [参考资料](#参考资料)
- [Web 安全](#web-安全)
  - [密码安全](#密码安全)
  - [`XSS` 防范](#xss-防范)
    - [重现](#重现)
    - [防护](#防护)
  - [`SSRF`](#ssrf)
    - [重现](#重现-1)
    - [防护](#防护-1)
  - [`SSTI` 模板注入](#ssti-模板注入)
    - [重现](#重现-2)
    - [防护](#防护-2)
  - [命令注入](#命令注入)
    - [复现](#复现)
    - [防范](#防范)
  - [SQL 注入](#sql-注入)
    - [复现](#复现-1)
    - [防范](#防范-1)
  - [`CSRF` 跨域请求保护](#csrf-跨域请求保护)
    - [前后端不分离](#前后端不分离)
    - [对于前后端分离的项目](#对于前后端分离的项目)
  - [`XXE XML` 外部实体注入](#xxe-xml-外部实体注入)
    - [重现](#重现-3)
    - [防范](#防范-2)
  - [`CRLF`](#crlf)
    - [重现](#重现-4)
    - [防护](#防护-3)
  - [目录穿越](#目录穿越)
    - [重现](#重现-5)
    - [防护](#防护-4)
  - [文件上传漏洞](#文件上传漏洞)
    - [重现](#重现-6)
    - [防护](#防护-5)
- [其他](#其他)

# 参考资料

- [★ Web 安全大全](https://websec.readthedocs.io/zh/latest)

# Web 安全

> `Werkzeng` 库

- [`web` 安全学习笔记](https://websec.readthedocs.io/zh/latest/index.html)

## 密码安全

- 密码散列

  一般都不直接保存用户的密码，而是计算一个散列值，校验的时候就比对保存的散列值，和传入的密码计算得到的散列值
  当然也可以自己去做密码散列和校验 j

  ```py
  from werkzeug.security import generate_password_hash, check_password_hash
  # 计算密码散列，每次计算的散列值都不一样 generate_password_hash(passoword, method=pbkdf2:sha1, salt_length=8)
  # 校验密码散列 check_password_hash(hash, password)
  passwd = "123456"
  ret = generate_password_hash(passwd)
  print(ret)
  print(check_password_hash(ret, passwd))
  ```

## `XSS` 防范

- 防范 XSS 攻击

  - 前端，服务端，同时需要字符串输入的长度限制

  - 前端，服务端，同时需要对 HTML 转义处理。将其中的 `<` 和 `>` 等特殊字符进行转义编码

  - 防 XSS 的核心是必须对输入的数据做过滤处理

### 重现

```py
@app.route('/xss', methods=['GET', 'POST'])
def test_xss():
    """
    测试xss攻击
    运行APP后，在输入框中输入一段js代码：<script>alert('xss')</script>
    点击提交后发现这段 js 代码被执行了
    """
    get_page = """<html>
    <body>
        <form action="" method="post">
            <input type="text" name="input">
            <input type="submit">
        </form>
    </body>
    </html >
    """
    if request.method == "GET":
        return get_page
    elif request.method == "POST":
        _input = request.form['input']
        return _input
```

### 防护

```py
from html.parser import HTMLParser
class StripTagsHTMLParser(HTMLParser):
    data = ""

    def handle_data(self, data):
        self.data += data

    def getData(self):
        return self.data

# 利用学爬虫都会用到的 `HTMLParser` 来对发送上来的数据做html格式过滤
parser = StripTagsHTMLParser()
# 这里传入的是字符串，但是一般前后端交互都是通过json来交互的
# 所以可以先用 json.dumps(form) 处理成字符串，然后传进去
parser.feed(request.form['input'])
web_input = parser.getData()
# 处理前
"""
{'name': '自定义应用_32432423', 'type_crc': '3207434678', 'rule_type': 0, 'priority': 1, 'flow_type': 0, 'type_name': '自定义类别_test1', 'user_rule_list': [{'rule_name': "<script>alert('xss')</script>", 'dir': '0', 'proto': '6', 'ip': '', 'port': '0', 'id': 1, 'allowEdit': True, 'selectAble': True, 'selected': False}, {'rule_name': '34633745', 'dir': '0', 'proto': '6', 'ip': '', 'port': '0', 'id': 2, 'allowEdit': True, 'selectAble': True, 'selected': False}]}
"""
# 处理后
# 经过parser处理后会把 js代码去掉，替换成真实数据
"""
{"name": "\u81ea\u5b9a\u4e49\u5e94\u7528_32432423", "type_crc": "3207434678", "rule_type": 0, "priority": 1, "flow_type": 0, "type_name": "\u81ea\u5b9a\u4e49\u7c7b\u522b_test1", "user_rule_list": [{"rule_name": "alert('xss')", "dir": "0", "proto": "6", "ip": "", "port": "0", "id": 1, "allowEdit": true, "selectAble": true, "selected": false}, {"rule_name": "34633745", "dir": "0", "proto": "6", "ip": "", "port": "0", "id": 2, "allowEdit": true, "selectAble": true, "selected": false}]}
"""
```

## `SSRF`

- [SSRF 详解](https://blog.csdn.net/qq_30135181/article/details/52734225)

### 重现

### 防护

## `SSTI` 模板注入

> [SSTI 模板注入](https://blog.csdn.net/u011377996/article/details/86776181)

- [关于 Flask SSTI，解锁你不知道的新姿势](https://www.secpulse.com/archives/140019.html)

### 重现

### 防护

## 命令注入

### 复现

- `python 的 subprocess` 库

  ```py
  import pipes
  import subprocess
  cmd = "whoami;ls"
  # cmd = "whoami && ls"
  # 会执行 whoami ls 两个命令
  subprocess.Popen(cmd, shell=True)
  ###### cmd 可以为字符串，也可以为列表类型，如果是列表类型，则cmd[0]后面的都作为cmd[0]的参数
  cmd = ['ls', '-la', '; whoami']
  subprocess.Popen(cmd, shell=False)
  # ls: cannot access ';whoami': No such file or directory
  # ; whoami 被当成 ls 的参数
  ```

### 防范

- 用正则对输入做判断，一般都会建议过滤 **\n$&;|'"()`** 等 shell 元字符过滤掉

- 在字符串最外层加上单引号使字符串只能做为一个单一体出现，**当参数有特殊字符时，在参数两边加上一对 `''`**

- 是将字符串内的单引号用双引号引起来`使其失去可能的闭合`功能

- `pipes` 过滤掉敏感字符

  ```py
  >>> import pipes
  >>> cmd = "whoami;ls"
  >>> cmd = pipes.quote(cmd)
  >>> "'whoami;ls'"
  # 把整个命令当成一个字符串
  # 但是还是有风险，因为cmd里面也可以有引号，来把字符串闭合
  >>> cmd = "whoami';ls'"
  >>> cmd = pipes.quote(cmd)
  >>> '\'whoami\'"\'"\';ls\'"\'"\'\''
  ```

## SQL 注入

### 复现

- 向原始 `sql` 中传入参数

  ```sql
  -- select name, password from user where name = %s and password = %s
  -- 传入参数 name = '"huangjinjie "--'
  select name, password from user where name = "huangjinjie" -- and password = %s
  ```

### 防范

- 不要自己去拼 `sql` 字符串语句

- 不要什么都用 `%s` 来做格式化，严格控制格式化参数

- `sqlalchemy` 本身已支持 `sql注入` 防范，而且用这个 `orm` 框架，都不需要我们自己拼 `sql`，所有的操作都是通过框架提供的函数来完成的

- 即使可以用 `session.execute(sql)` 来直接执行 `sql` 语句，可以防范

  ```py
  # 有命令注入的危险
  sql_str = "select * from user where username = '%s' and password ='%s'" % (username, password)
  session.execute(sql_str)
  # 使用 sqlalchemy 提供的 %s 函数来消除危险
  sql_str = "select * from user where username = %s and password = %s" % (username, password)
  session.execute(sql_str)
  # 字符串拼接要加 '%s'  ,系统提供的函数 %s  没有使用引号
  ```

## `CSRF` 跨域请求保护

对于每个请求，后端都会返回一个 `token` 给前端，前端提交数据到后台的时候携带上该 `token` ，后台校验该数据的正确性

### 前后端不分离

- [对于前后端不分离的项目](https://www.jianshu.com/p/bab9b45b46f6)，在 `jinja2` 渲染的时候直接使用 `flask-wtf` 提供的防护功能带上 `csrf_token`

- 页面代码

  ```html
  <!-- 都依赖于 jinja2 模板渲染引擎 -->
  <form method="post", action="">
      <!-- 表单，直接使用 flask-wtf 提供的 form.csrf_tokn -->
      {{form.csrf_token}}
      <!-- 或者 {{form.hidden_tab}} -->
      <!-- 非表单，把 token 放到隐藏字段值，使用 csrf_token() 函数 -->
      <input type="hidden", name="csrf_token", value="{{ csrf_token() }} />
  </form>
  ```

- 后台代码

  ```py
  # 开启 csrf 防护

  from flask_wtf.csrf import CSRFProtect
  app.config.from_object(Config)

  # 如果是表单post请求,csrf值通过隐藏的input标签传递;如果是Ajax post请求,csrf值需要设置到请求头"X-CSRFToken"中
  # 在进入视图前(hook钩子函数中),会自动进行csrf值的比较验证。
  CSRFProtect(app)

  #像任何其它的 Flask 扩展一样，你可以惰性加载它:
  from flask_wtf.csrf import CsrfProtect

  csrf = CsrfProtect()

  def create_app():
      app = Flask(__name__)
      # 盐
      app.secret_key = "436fs3424123+=)%$$#l54,5"
      csrf.init_app(app)
  ```

### 对于前后端分离的项目

- 前后端分离的话，后台把 `token` 添加到 `cookie` 中返回给前端；上面讲过 `请求钩子`，在这里正好用上，给每一个请求带上

- 由于浏览器自带的 `同源策略`，黑客是无法拿到另一个网站上的 `token` 的

- 后台代码

  ```py
  from flask_wtf.csrf import generate_csrf
  @app.after_request
  def after_request(response):
      # 生成 csrf token
      csrf_token = generate_csrf()
      # 设置 cookie 传给前端
      response.set_cookie('X-CSRFToken', csrf_token)
      return response
  ```

## `XXE XML` 外部实体注入

### 重现

### 防范

## `CRLF`

- [CRLF 注入漏洞](https://blog.csdn.net/weixin_37968613/article/details/107470182)

### 重现

### 防护

## 目录穿越

### 重现

### 防护

- `from werkzeug.utils import secure_filename`

  根据文件名中的空字符，包括空格、换行 (\n)、制表符(\t) 等，把文件名分割成列表，然后使用下划线 `_` 进行连接，再过滤掉正则之外的字符，最后去掉字符串两头的 “.\_” 字符，最终生成新的文件名

- 用 `from werkzeug.utils import secure_filename` 来做目录穿越的防护，该函数会把特殊字符过滤掉，如果传入的是 `../te.txt` 经过该函数后变成 `te.txt`

  ```py
  >>> from werkzeug.utils import secure_filename
  >>> secure_filename("../testdir/test.txt")
  # 但是 secure_filename 会去掉空格
  # secure_filename("中文路径 d.txt") 得到 d.txt
  # secure_filename("中文路径.txt") 得到 txt
  >>> testdir_test.txt
  >>> secure_filename("...txt")
  >>> txt
  ```

- [python flask 使用 secure_filename（）获取中文文件名问题](https://blog.csdn.net/qq_36390239/article/details/98847888)

- [Flask 使用 secure_filename 获取文件名不完整问题](https://blog.csdn.net/apollo_miracle/article/details/107162584)

## 文件上传漏洞

### 重现

### 防护

# 其他

[Flask 配置 Cors 跨域](https://www.cnblogs.com/anxminise/p/9814326.html)

[X-Forwarded-For 伪造客户端 IP 漏洞成因及防范](https://www.cnblogs.com/olivexiao/p/15194467.html)
