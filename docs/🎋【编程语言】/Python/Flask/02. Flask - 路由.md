- [`app.route` 路由](#approute-路由)
- [其他](#其他)
- [参考资料](#参考资料)

# `app.route` 路由

- 完整的一个路由过程

  ```sh
  web --> wsgi服务器(uwsgi或gunicorn等) --> flask(遵守WSGI协议接口的APP) -->

  解析 environ 得到url --> 查找注册的路由self.url_map -->

  self.view_functions --> 调用对应的处理函数

  ```

- `app.route('/url_path')` 注册 url 与处理该 url 的函数的关系

  ```py
  from flask import Flask
  # 创建了一个中间件，核心作用是做请求转发
  app = Flask(__name__)

  # 注册一个路由，指定请求的方法
  @app.route('/login', methods=['GET'])
  def login():
      pass

  """
  # app.route('/login')
  # 其实就是向 Flask 注册一个 url 和处理方法的对应关系，请求来的时候由 Flask 做转发，类似如下
  url_map =
  {
      url: func_name,
      url2: func_name2
  }

  def handle_request(url):
      return url_map.get(url)
  """

  # 实际上调用的是 app.add_url_rule(url, endpoint, view_func)，和 endpoint 有关

  app.run()
  ```

- 同一个视图函数也可以绑定多个 url

  ```py
  @app.route('/')
  @app.route('/index')
  @app.route('/home')
  def test():
    pass
  ```

- `url_map` 查看已注册的路由

  ```py
  # app.py
  >>> from flask import Flask
  >>> app = Flask(__name__)
  >>> @app.route('/test/')
  ... def test():
  ...    pass
  ...
  >>> app.url_map
  Map([
    <Rule '/test/' (OPTIONS, GET, HEAD) -> test>,
    <Rule '/static/<filename>' (OPTIONS, GET, HEAD) -> static>
  ])
  # /static/<filename> 路由是Flask自带的特殊路由，用来访问静态文件的
  # /test/ 是我们自己注册的路由
  # OPTIONS
  # GET 请求方法
  # HEAD
  # -> test 该路由指定的处理方法
  ```

- [关于 python:带有尾随斜杠的 Flask POST](https://www.codenong.com/42661277/)

  ```py
  # strict_slashes 可以同时处理非尾随斜杠和尾随斜杠
  app = Flask(__name__)
  app.url_map.strict_slashes = False

  或者
  @app.route("/foo", methods=["POST"], strict_slashes=False)
  def foo():
      pass
  ```

- `endpoint`

  其实 `@app.route('/index')` 中创建了 `Rule(url, endpoint, method) 和 {endpoint: function}`两组映射关系

  很多时候在一个 `API` 中，资源可以通过多个 `URL` 访问，也可以指定 `endpoint`

  ```sh
  # 前面说过，注册路由的时候，其实是添加一个 url 和处理函数之间的关系
  # endpoint 默认为处理函数的名字
  # url --> endpoint --> function
  # 一个URL对应一个endpoint，一个endpoint对应一个func
  url_map =
  {
      url: endpoint
  }

  # endpoint就是一个中介，可以先通过url找到endpoint，再通过endpoint找到function
  view_funcitons =
  {
      endpoint: function
  }
  ```

- `url_for(endpoint)` 根据 `endpoint` 或者 函数名（注意不是 url）找到对应的 url

  ```py
  @app.route('/post/<int:id>', method=['GET', 'POST'])
  def funcname(parameter_list):
      """
      前面已经知道了，endpoint是介于url和view_func之间的桥梁
      比如在这里做重定向，需要有一个view函数转到另一个view函数做处理的时候, 使用url_for即可
      url_for的参数就是另一个view函数的endpoint，这样是为了防止硬编码，如果没有endpoint
      那么根据{url: view_func}的映射关系，这里就要硬编码传入url
      所以用endpoint来做个媒介，只要endpoint不变，url和view_func怎么变都没关系

      # 有点金证的中转LBM的意思
      # 即A --> MID --> B，MID是中间件，A维护A到MID的映射，B维护MID到B的映射
      # A不管B接口怎么变化（比如换个处理接口），反正始终按照映射关系往MID对应的编号发消息就行
      """

      # 重定向到auth蓝图的signin处理函数中
      return redirect(url_for('auth.signin'))

      # 如果入参是endpoint，而且是当前视图，则要在前面加上一个点 url_for(".user")
      # 如果需要跳转到其他视图，则是： url_for("auth.signin")
  ```

- 至此一个简单的，包含路由的框架就搭好了

  ```py
  class Flask(object):
    def __init__(self):
      # 定义了url和处理函数的映射关系
      self.url_map = {}

    def __call__(self, environ, start_response):
      '''根据WSGI协议，app必须是一个可调用对象'''
      # Flask的核心功能，请求分发
      self.dispatch_request()
      # 根据 WSGI协议，使用application来处理
      return application(environ, start_respones)

    def route(self, rule):
      '''Flask使用装饰器来注册路由'''
      def decorator(func):
        self.url_map[rule] = func
        return func
      return decorator

    def dispatch_request(self):
      # 解析environ获取到url，并执行对瘾的处理函数
      url = get_url_from_environ()
      return self.url_map[url]()
  ```

- 动态 url 规则

  ```py
  # 尖括号括起来的冒号左侧叫做转换器，右侧为变量参数
  # 会把传进来的参数转换成int类型，作为post_id参数传入到处理函数中（注意，两个名称要一致）

  @app.route('/post/<int:post_id>', methods=['GET'])
  def get_post(post_id):
      pass

  # 内置的转换器包括
  # int 整形
  # float 浮点型
  # path 路径
  # string 默认的转换器就是字符串（和path区别开，string的不会接收带/斜杠的参数
  # @app.route('/post/<string:test>') 如果访问 xxx/post/dsd/dsds 会返回404，找不到页面
  # 如果要作为路径传入应该这样定义 @app.route('/post/<path:test>')，则传入的值为/post/后面的字符串，包含斜杠
  ```

- 正则 url 匹配

  ```py
  from werkzeug.routing import BaseConverter
  class RegexConverter(BaseConverter):
    def __init__(self, url_map, *args):
        super(RegexConverter, self).__init__(url_map)
        # 把入参作为匹配规则
        self.regex = args[0]

  # 把转换器添加到转换器列表中
  app.url_map.converters['regex'] = RegexConverter

  @app.route("/user/<regex('[a-z]+'):name>")
  def user(name):
    pass
  ```


# 蓝图


[蓝图（Blueprint）和视图](https://blog.csdn.net/aninstein/article/details/109431394)

# 其他

- [循环引入的问题](https://juejin.cn/post/6844903919592669191)

# 参考资料

[★ Flask 路由设计思路](https://segmentfault.com/a/1190000004213652)
