- [Django 高并发处理与解决方案探讨](#django-高并发处理与解决方案探讨)
  - [高并发的四个角度](#高并发的四个角度)
    - [PV 和 QPS](#pv-和-qps)
  - [Python 常见部署方法](#python-常见部署方法)
  - [什么是负载均衡](#什么是负载均衡)
    - [HTTP 重定向实现负载均衡](#http-重定向实现负载均衡)
    - [DNS 负载均衡](#dns-负载均衡)
    - [反向代理负载均衡（Nginx+uwsgi）](#反向代理负载均衡nginxuwsgi)
    - [IP 负载均衡](#ip-负载均衡)
    - [数据链路层负载均衡](#数据链路层负载均衡)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.Django.cn](https://www.Django.cn/forum/forum-508.html)

## Django 高并发处理与解决方案探讨

一直在听别人说，Django 在处理高并发时很低效，甚至有些人道听途说 Django 并不能处理高并发，然后萌发放弃 Django 的念头。那么在这里就和大家一起探讨一下 Django 高并发怎么处理。

一直都在说高并发，在这之前，我们先了解一下什么是高并发。多少 QPS 才算是高并发？业务系统服务，单机，集群分别是多少呢？先来科普一下 QPS 和 TPS 这两个概念。

- QPS：Queries Per Second 意思是 “每秒查询率”

  是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

- TPS：是 TransactionsPerSecond 的缩写

  也就是事务数 / 秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

### 高并发的四个角度

只说并发不提高可用就是耍流氓。可以从四个角度讨论这个问题。

- 首先是无状态前端机器不足以承载请求流量，需要进行水平扩展，一般 QPS 是千级

- 然后是关系型数据库无法承载读取或写入峰值，需要数据库横向扩展或引入 nosql，一般是千到万级

- 之后是单机 nosql 无法承载，需要 nosql 横向扩展，一般是十万到百万 QPS

- 最后是难以单纯横向扩展 nosql，比如微博就引入多级缓存架构，这种架构一般可以应对百万到千万对 nosql 的访问 QPS。当然面向用户的接口请求一般到不了这个量级，QPS 递增大多是由于读放大造成的压力，单也属于高并发架构考虑的范畴

#### PV 和 QPS

比如微博每天 1 亿多 pv 的系统一般也就 1500QPS，5000QPS 峰值。 比如有人说：

```
2C + 4G 机器单机一般 1000 QPS
8C + 8G 机器单机可承受 7000 QPS
```

具体多少 QPS 跟业务强相关，只读接口读缓存，将压力给到缓存单机 3000+ 没问题，写请求 1000+ 也正常，也复杂些可能也就 几百+ QPS

所以 QPS 和业务场景和设计相关性很大，比如可以通过浏览器本地缓存，用缓存做热点数据查询，写事务 MQ 异步处理等方式提升 QPS。

- 回到 Django，Django 如何处理高并发呢

  Django 框架本身的并发能力真的是令人担忧，所以一般我们就使用 Nginx + uwsgi 提供高并发。Nginx 的并发能力超高，单台并发能力过万（这个也不是绝对），在纯静态的 web 服务中更是突出其优越的地方，由于其底层使用 epoll 异步 IO 模型进行处理，使其深受欢迎。

- **如何再次增加并发量**

  采用 nginx 做负载

- **去掉自增主键**

  原因很简单, 因为自增主键的存在写库存在抢锁, 可以利用全局 id 生成器提前生成 id 直接写入数据库

- **换成异步任务去写库**

  如果数据只是存在 mysql 中做备份，建议使用异步的方式写入库，先把数据写到缓存下发给用户，之后在利用后台异步任务一点点的写入，例如聊天系统可以这样干

- **换成更高效的框架或者语言**

  可以试试 tornado, 如果 tornado 依然无法满足，可以尝试使用 golang，毕竟 golang 是以高并发著称, 而且是编译语言，而且基于它的 web 框架也很容易上手，性能很可观，例如 Iris。这些我们就不提了，我们主要的是谈论使用 Django 如何进行高并发。

- **Django**

  毫无疑问，用原生 Django 的 server 做处理的表现是最烂的，在 10000 次请求的情况下 brokenpipe 的几率极高，只有 1400 次请求被处理，成功率只有 14%。

- **Django + nginx**

  这次搭上了 nginx 做反向代理，也使的脆弱的 Django 服务器的情况有所缓解，但成功率仍然不高（10000 次请求中有 3684 个请求被处理）。

- **uwsgi + nginx**

  uwsgi 是性能极高的一个由 C 编写的服务器，它使用 uwsgi 协议，这次让它配合 nginx 处理 Django 的 request，参数为 4 进程 + 2 线程，性能立即直线上升，处理请求的成功率也基本在 90% 左右，不过我在测试时遇到了一个坑，就是 uwsgi 在处理请求的时候发送了队列溢出的问题，因为当前测试设置的并发数为每秒 1000 次并发，而 uwsgi 的处理队列容量默认为 100，导致处理请求的时间加长，而这个问题则可以通过修改 somaxcon 的大小解决，总的来说，使用 uwsgi+nginx 是一个理想的选择。

- **gunicorn + nginx**

  gunicorn 跟 uwsgi 类似，也是一个高性能的 http 服务器，它由 ruby 的 unicorn 项目移植，是由 Python 编写的，它的配置简单，而且可以灵活地搭配其他网络库，部署十分方便，在测试数据中可以看到，用这种配置运行 Django 能在短时间内就能处理大量的并发请求，成功率在 90% 左右。

- **gunicorn + nginx + gevent**

  前面说的几种环境，看似不错，但我们需要追求完美！由于 gunicorn 是同步（sync）单线程模型的，有的时候它不免会发生一些阻塞问题，这时候我们为 gunicorn 加上 -k gevent 参数来用 gevent 做处理接口，这就比较靠谱地处理了阻塞问题，从数据中可以看到，gunicorn + nginx + gevent 的模式不仅拥有 100% 的处理成功率，而且时间也在很短之内完成，是 5 组测试数据当中的性能最好的。

### Python 常见部署方法

- `fcgi`

  用 spawn-fcgi 或者框架自带的工具对各个 project 分别生成监听进程，然后和 http 服务互动

- `wsgi`

  利用 http 服务的 mod_wsgi 模块来跑各个 project(Web 应用程序或框架简单而通用的 Web 服务器 之间的接口)。

uWSGI 是一款像 php-cgi 一样监听同一端口，进行统一管理和负载平衡的工具，uWSGI，既不用 wsgi 协议也不用 fcgi 协议，而是自创了一个 uwsgi 的协议，据说该协议大约是 fcgi 协议的 10 倍那么快。

其实 WSGI 是分成 server 和 framework (即 application) 两部分 (当然还有 middleware)。

严格说 WSGI 只是一个协议, 规范 server 和 framework 之间连接的接口。

WSGI server 把服务器功能以 WSGI 接口暴露出来。比如 mod_wsgi 是一种 server, 把 Apache 的功能以 WSGI 接口的形式提供出来。

WSGI framework 就是我们经常提到的 Django 这种框架。不过需要注意的是, 很少有单纯的 WSGI framework , 基于 WSGI 的框架往往都自带 WSGI server。比如 Django、CherryPy 都自带 WSGI server 主要是测试用途, 发布时则使用生产环境的 WSGI server。而有些 WSGI 下的框架比如 pylons、bfg 等, 自己不实现 WSGI server。使用 paste 作为 WSGI server。

Paste 是流行的 WSGI server, 带有很多中间件。还有 flup 也是一个提供中间件的库。

搞清除 WSGI server 和 application, 中间件自然就清楚了。除了 session、cache 之类的应用, 前段时间看到一个 bfg 下的中间件专门用于给网站换肤的 (skin) 。中间件可以想到的用法还很多。

这里再补充一下, 像 Django 这样的框架如何以 fastcgi 的方式跑在 Apache 上的。这要用到 flup.fcgi 或者 fastcgi.py (eurasia 中也设计了一个 fastcgi.py 的实现) 这些工具, 它们就是把 fastcgi 协议转换成 WSGI 接口 (把 fastcgi 变成一个 WSGI server) 供框架接入。整个架构是这样的: `Django -> fcgi2wsgiserver -> mod_fcgi -> Apache`

虽然我不是 WSGI 的粉丝, 但是不可否认 WSGI 对 Python web 的意义重大。有意自己设计 web 框架, 又不想做 socket 层和 http 报文解析的同学, 可以从 WSGI 开始设计自己的框架。在 Python 圈子里有个共识, 自己随手搞个 web 框架跟喝口水一样自然, 非常方便。或许每个 Python 玩家都会经历一个倒腾框架的。

**uWSGI 的主要特点如下：**

- 超快的性能。

- 低内存占用（实测为 apache2 的 mod_wsgi 的一半左右）。

- 多 app 管理。

- 详尽的日志功能（可以用来分析 app 性能和瓶颈）。

- 高度可定制（内存大小限制，服务一定次数后重启等）。

### 什么是负载均衡

> 上面讲的都是单机处理高并发，如果单机处理不过来，我们还可以通过负载均衡来解决高并发。

当一台服务器的性能达到极限时，我们可以使用服务器`集群`来提高网站的整体性能。那么，在服务器集群中，`需要有一台服务器充当调度者的角色`，用户的所有请求都会首先由它接收，调度者再根据每台服务器的负载情况将请求分配给某一台后端服务器去处理。

那么在这个过程中，调度者如何合理分配任务，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优，这就是负载均衡问题。

下面详细介绍负载均衡的五种实现方式

#### HTTP 重定向实现负载均衡

> **过程描述**

- 当用户向服务器发起请求时，请求首先被`集群调度者`截获；调度者根据某种分配策略，选择一台服务器，并将选中的服务器的 IP 地址封装在 HTTP 响应消息头部的 Location 字段中，并将响应消息的状态码设为 302，最后将这个响应消息返回给浏览器。

- 当浏览器收到响应消息后，解析 Location 字段，并向该 URL 发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。

- 在使用 HTTP 重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为`请求调度者`。用户的一项操作需要发起两次 HTTP 请求，一次向调度服务器发送请求，获取后端服务器的 IP，第二次向后端服务器发送请求，获取处理结果。

> **调度策略**

- 随机分配策略

  当调度服务器收到用户请求后，可以随机决定使用哪台后端服务器，然后将该服务器的 IP 封装在 HTTP 响应消息的 Location 属性中，返回给浏览器即可。

- 轮询策略 (RR)

  调度服务器需要维护一个值，用于记录上次分配的后端服务器的 IP。那么当新的请求到来时，调度者将请求依次分配给下一台服务器。由于轮询策略需要调度者维护一个值用于记录上次分配的服务器 IP，因此需要额外的开销；此外，由于这个值属于互斥资源，那么当多个请求同时到来时，为了避免线程的安全问题，因此需要锁定互斥资源，从而降低了性能。而随机分配策略不需要维护额外的值，也就不存在线程安全问题，因此性能比轮询要高。

- **优缺点分析**

  - 采用 HTTP 重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单，但缺点也较为明显。

  - 在 HTTP 重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的 URL 进行的 (也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：

    - 由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此`这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了`。

    - 若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。

#### DNS 负载均衡

首先需要将我们的域名指向多个后端服务器 (将一个域名解析到多个 IP 上)，再设置一下调度策略，那么我们的准备工作就完成了，接下来的负载均衡就完全由 DNS 服务器来实现。

当用户向我们的域名发起请求时，DNS 服务器会自动地根据我们事先设定好的调度策略选一个合适的 IP 返回给用户，用户再向该 IP 发起请求。 调度策略

一般 DNS 提供商会提供一些调度策略供我们选择，如随机分配、轮询、根据请求者的地域分配离他最近的服务器。

- **优缺点分析**

  - DNS 负载均衡最大的优点就是配置简单

    服务器集群的调度工作完全由 DNS 服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心 DNS 服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。此外，DNS 负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的 IP，而且不用担心性能问题。

  - 由于把集群调度权交给了 DNS 服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。

  - DNS 服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。`它和 HTTP 重定向一样，只不过把所有请求平均分配给后端服务器罢了`。

  - 当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于 DNS 服务器会有缓存，该 IP 仍然会在 DNS 中保留一段时间，那么就会导致一部分用户无法正常访问网站。这是一个致命的问题！好在这个问题可以用动态 DNS 来解决。

- **动态 DNS**

  动态 DNS 能够让我们通过程序动态修改 DNS 服务器中的域名解析。从而当我们的监控程序发现某台服务器挂了之后，能立即通知 DNS 将其删掉。

综上所述，DNS 负载均衡是一种粗犷的负载均衡方法，这里只做介绍，不推荐使用。

#### 反向代理负载均衡（Nginx+uwsgi）

- `正向代理`

  ![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-f339964bbc01f2437f93acbac8158715_r.jpg&refer=http%3A%2F%2Fpic2.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640443777&t=d62f196fb8b44c585f1f1f8d7f2f85c3)

  是指内网通过代理访问外网，这个代理就是正向代理

- `反向代理`

  ![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic1.zhimg.com%2F80%2Fv2-102d945941e4c24ccc7c4712474cadd7_1440w.jpg&refer=http%3A%2F%2Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640443800&t=a3c95377b73501696ec2a546a2f5f343)

  外网通过代理访问内网，那这个代理就是反向代理

- 假设把你公司的网看成是内网，那么你从公司里面的一台电脑上访问你家里的电脑上的服务，那就的通过正向代理，而你从你家电脑访问公司的这台电脑，就要通过反向代理。

使用代理服务器可以将请求转发给内部的 Web 服务器，使用这种加速模式显然可以`提升静态网页的访问速度`。因此也可以考虑使用这种技术，让代理服务器将请求均匀转发给多台内部 Web 服务器之一上，从而达到负载均衡的目的。

这种代理方式与普通的代理方式有所不同，标准代理方式是客户使用代理访问多个外部 Web 服务器，而这种代理方式是多个客户使用它访问内部 Web 服务器，因此也被称为反向代理模式。

反向代理处于 web 服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组 web 服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的 web 服务器处理，处理结果经过反向服务器返回给浏览器。

- **优点**

  - 隐藏后端服务器

    与 HTTP 重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。

  - 故障转移

    与 DNS 负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。

  - 合理分配任务

    HTTP 重定向和 DNS 负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。

- **缺点**

  - 调度者压力过大

    由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。

  - 制约扩展

    当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。

#### IP 负载均衡

> 原理：在网络层通过修改目标地址进行负载均衡。

用户访问请求到达负载均衡服务器，负载均衡服务器在操作系统内核进程获取网络数据包，根据算法得到一台真实服务器地址，然后`将用户请求的目标地址修改成该真实服务器地址`，数据处理完后返回给负载均衡服务器，负载均衡服务器收到响应后将自身的地址修改成原用户访问地址后再讲数据返回回去。类似于反向服务器负载均衡。

- **优点**

  在响应请求时速度较反向服务器负载均衡要快。

- **缺点**

  当请求数据较大（大型视频或文件）时，速度较慢。

#### 数据链路层负载均衡

> 原理：在数据链路层修改 Mac 地址进行负载均衡。

负载均衡服务器的 IP 和它所管理的 web 服务群的虚拟 IP 一致；负载均衡数据分发过程中不修改访问地址的 IP 地址，而是修改 Mac 地址；通过这两点达到不修改数据包的原地址和目标地址就可以进行正常的访问。

- **优点**

  不需要负载均衡服务器进行地址的转换。数据响应时不需要经过负载均衡服务器。

- **缺点**

  负载均衡服务器的网卡带宽要求较高。

最后：其实大家并不需要担心 Django 高并发处理的这些问题，任何问题都有解决方案，我们只需要在适当的时候和适当的场景用适当的方法来处理即可。所以还是安安心心的玩 Django 吧。
