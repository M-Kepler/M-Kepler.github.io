- [Django](#django)
  - [初始文件](#初始文件)
    - [manage.py](#managepy)
    - [settings.py](#settingspy)
    - [urls.py](#urlspy)
    - [wsgi.py](#wsgipy)
  - [调试](#调试)
  - [路由系统](#路由系统)
  - [异常处理](#异常处理)
  - [插件](#插件)
    - [rest_framework](#rest_framework)
    - [django.contrib.admin](#djangocontribadmin)
      - [登录认证增加错误次数限制](#登录认证增加错误次数限制)
    - [django-xadmin](#django-xadmin)
    - [django.db](#djangodb)
    - [django.http](#djangohttp)
  - [`manage.py`](#managepy-1)
  - [国际化](#国际化)
  - [单元测试](#单元测试)
  - [部署](#部署)
    - [https](#https)
  - [其他](#其他)
- [认证](#认证)
  - [安全性](#安全性)
- [其他](#其他-1)

# Django

> [Django 中文社区](https://www.django.cn)

- 查看版本

- 启动项目 `python manage.py runserver`

## 初始文件

### manage.py

> 命令行工具，可让你以各种方式与该 Django 项目进行交互

### settings.py

https://www.cnblogs.com/senzhe/p/5798309.html

> 该 Django 项目的设置/配置

- `ALLOWED_HOSTS` 列表为了防止黑客入侵，只允许列表中的 ip 地址访问，`*`可以使所有的网址都能访问 Django 项目

- 使用 setting.py 中的配置

  ```py
  from django.conf import settings
  test = getattr(settings, "test", "default_val")
  ```

- [Django 的时区问题](https://www.cnblogs.com/shilxfly/p/9436981.html)

### urls.py

> 该 Django 项目的 URL 声明

### wsgi.py

> 一个 WSGI 兼容的 Web 服务器的入口

## 调试

https://www.jianshu.com/p/a0741a463422

## 路由系统

- 重定向

- `Flask` 是可以多个 `url` 走同一个视图函数的

  ```py
  @app.route("/", methods=["GET"])
  @app.route("/index", methods=["GET"])
  def do_get()
      return 'do something...'
  ```

## 异常处理

## 插件

### rest_framework

> https://segmentfault.com/a/1190000004399682

- 自定义返回数据结构

### django.contrib.admin

> Django 自带后台的管理界面显示设置
> https://www.cnblogs.com/wumingxiaoyao/p/6928297.html > https://zhuanlan.zhihu.com/p/47962034

```py
# 在创建应用的时候自动生成的 admin.py
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    '''可编辑的字段'''
    fieldsets = [

    ]

    '''设置列表可显示的字段'''
    list_display = ('title', 'author',  'status', 'mod_date',)

    ''''设置哪些字段可以点击进入编辑界面'''
    list_display_links = ('title')

    '''设置过滤选项'''
    list_filter = ('status', 'pub_date', )

    '''每页显示条目数'''
    list_per_page = 5

    '''设置可编辑字段'''
    list_editable = ('status',)

    '''按日期月份筛选'''
    date_hierarchy = 'pub_date'

    '''按发布日期排序'''
    ordering = ('-mod_date',)

# admin.site.register(Article, ArticleAdmin)
```

#### 登录认证增加错误次数限制

> - 希望现有的登录界面（django-admin)支持对输入密码错误次数做限制
> - 思路很清楚，找到处理登录的那个 web views 然后再判断密码的时候做修改
> - 但是怎么返回错误信息回去呢？django-admin 的这个认证界面有没有可以填充的字段

- [django-重写登录认证（可以使用用户名或手机号登录）](https://www.cnblogs.com/yuanzongyin/p/10032368.html)

- [django 实现登录时候输入密码错误 5 次锁定用户十分钟](https://www.jb51.net/article/127547.htm)

- [django admin.py 如何定制错误信息提示？](https://www.v2ex.com/t/334182)

- `models.py`

  ```py
  # 重写用户表
  from django.db import models
  from django.contrib.auth.models import AbstractUser

  class UserProfile(AbstractUser):
    custom_ip = models.CharField(u'用户IP', max_length=16)
    login_locked_tm = models.DateTimeField(u'登录锁定时间', null=True)
    pass_errnum = models.IntegerField(u'用户密码输入错误次数', default=0)
    class Meta:
      verbose_name = u'用户'
      verbose_name_plural = verbose_name
      ordering = ['-id']

    def __str__(self):
      return self.username

  # 同步一次数据库就可以看到这张 appname_userprofile 表了
  ```

- `views.py`

  ```py
  # 重写认证后台
  from datetime import datetime
  from .models import UserProfile
  from django.contrib.auth.backends import ModelBackend
  from django.contrib.auth.hashers import check_password

  class CustomBackend(ModelBackend):
    def __init__(self):
      self.error_messages = {
        'forbidden': '用户（%(username)s）已锁定，请在（%(limit_time)s） 秒后重试',
        'locked': '密码输入超过 %s 次，用户将被锁定 %s 秒' % (LOGIN_ERR_LIMIT, LOGIN_LOCKED_TIME),
        'login_err': '用户名不存在或密码错误！剩余重试次数：%(try_times)s'
      }

    def _login_error(self, errkey, params=None):
      # 只要抛出这个表单错误，就可以实现不修改django-admin认证界面，又可以把自定义错误信息抛出了
      raise forms.ValidationError(
        self.error_message[errkey],
        code=errkey,
        params=params
      )

    def authenticate(self, request, username=None, passowrd=None, **kwargs):
      user = UserProfile.objects.filter(username=username).first()
      # 用户不存在
      if not user:
        # 只要return None 就会由admin来处理异常，界面表现为用户名密码错误
        return None

      # 判断限制登录时长
      if user.login_locked_tm is not None:
        sec_deltas = (datetime.now() - user.login_locked_tm).total_seconds()
        if sec_deltas < LOGIN_LOCKED_TIME:
          raise self._login_err('forbidden', {
            'usernmae': user.username,
            'limit_time': LOGIN_LOCKED_TIME - int(sec_deltas)
          })
        else:
          # 如果超过限制时长后再次登录，清空原有登录错误状态
          user.login_locked_tm = None
          user.pass_errnum = 0
          user.save()

      # 校验密码
      if check_password(password, user.password):
        user.last_login = datetime.now()
        user.is_login = True
        user.login_locked_tm = None
        user.save()
        return user

      # 判断登录错误次数
      # 记录首次登录错误信息
      user.custom_ip = get_client_ip(request)
      user.pass_errnum += 1
      user.save()
      left_cnt = LOGIN_ERR_LIMIT - user.pass_errnum + 1
      if left_cnt > 0:
        raise self._login_error('login_err', {
          'try_times':LOGIN_ERR_LIMIT - user.pass_errnum + 1
        })
      else:
        user.login_locked_tm = datetime.now()
        user.save()
        raise self._login_error('locked')
  ```

- `setting.py`

  ```py
  # 这里要注意，虽然 UserProfile 是定义在 appname/models.py 下的，但是这里引用不用谢models
  AUTH_USER_MODEL = 'appname.UserProfile'
  AUTHENTICATION_BACKENDS = {
    # 使用自定义的认证后台
    'appname.views.CustomBackend'
  }
  ```

### django-xadmin

### django.db

- 在项目 `settings.py` 中指定数据库

  ```py
  # settings.py
  # 如果需要更换为mysql数据库只需要把ENGINE改了,然后执行以下命令
  DATABASES = {
      'default': {
          'ENGINE': 'django.db.backends.sqlite3',
          'NAME': os.path.join(BASE_DIR, 'db.sqlite3')
      }
  }
  ```

- [sqlite3 版本问题](https://blog.csdn.net/qq_39969226/article/details/92218635)

- 正常通过 `python manage runserver 0.0.0.0:8080` 运行没有问题，但是通过 `systemctl` 运行就有问题，通过 `journalctl -xe` 查看日志还是报 `sqlite3` 版本问题，但是命名直接执行 `*.service` `systemctl` 管理文件里的命令是正常的
  解决方法是直接屏蔽掉版本报错（不清楚会有什么影响） `python3.6/site-packages/django/db/backends/sqlite3/base.py` 的第 63 行

- datetime 的时区问题
  > https://blog.csdn.net/penghe00/article/details/81152242
  > 字段类型为 `models.DataTimeField`，保存 `datetime.now()` 数据后，查询出来使用 `datetime.now()` 保存在数据库中的有时区信息，在与查询出来的数据相减会报错

### django.http

## `manage.py`

> django 自带的项目管理命令
> [Django--自定义 Command 命令](https://www.cnblogs.com/polly-ling/p/9830060.html)

- 添加自定义的命令到 `manage.py`

  ```py
  """
  # 目录必须放在management/command下
  downloadapp/
      management/
      command/
          delete_old_rec.py
  """
  # delete_old_rec.py
  import argparse
  from django.core.management.base import BaseCommand
  from django.core.management.base import CommandError
  class Command(BaseCommand):
      help = "command usage"
      def add_arguments(self, parser:argparse.ArgumentParser):
          parser.add_argument("n_days", nargs="?", type=int, default=30)

      # 必须覆盖父类的handle方法
      def handle(self, *args, **options):
          ndays = options["n_days"]
          if ndays < 0:
              raise CommandError("days less than 0 not allowed")
          print("do something...")
          self.stdout.write("done do something...)
  # python manage.py 可以查看到自定义的命令
  # python manage.py delete_old_rec 10
  ```

## 国际化

https://blog.csdn.net/scissors0707/article/details/79042458

## 单元测试

## 部署

- no python application found, check your startup logs for errors

- 在 `centos` 上部署 `django + gunicorn` 直接执行命令可以运行起来，但是通过 `systemctl` 启动就会报 `sqlite` 版本过低，实际已经升级 SQLite 了，LD_LIBRARY_PATH 环境变量也设置了，已确认使用的是 `python3`
  最后 `vi /usr/local/lib/python3.6/site-packages/Django-2.2-py3.6.egg/django/db/backends/sqlite3/base.py` 把这个文件里的 `check_sqlite_version` 抛异常注释掉就可以使用 `systemctl` 来启动了

### https

https://www.cnblogs.com/kusy/p/9560458.html
https://www.cnblogs.com/fengyuhao/p/10069965.html

## 其他

- `Django` 很多都是在一个类里面定义一个类

# 认证

## 安全性

# 其他

- SQLite 版本问题

  > 明明已经安装新版的 SQLite 了，但还是 I 提示 django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17).

  把新版的 SQLite 库添加到环境变量中 `export LD_LIBRARY_PATH=/usr/local/sqlite/lib:$LD_LIBRARY_PATH`
