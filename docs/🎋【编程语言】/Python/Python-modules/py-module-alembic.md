- [`alembic`](#alembic)
  - [常规操作](#常规操作)
  - [日志](#日志)
  - [`alembic` 命令](#alembic-命令)
  - [测试](#测试)
  - [升级脚本模板](#升级脚本模板)
    - [索引](#索引)
    - [表结构](#表结构)
  - [多版本并行开发的数据库升级问题](#多版本并行开发的数据库升级问题)
    - [问题描述](#问题描述)
    - [方案一](#方案一)
    - [方案二](#方案二)
  - [回滚](#回滚)
  - [其他](#其他)

# `alembic`

[使用 alembic 进行数据库版本管理](https://www.cnblogs.com/xiaoming279/p/6641601.html)

[使用 alembic 进行数据库版本管理](https://www.cnblogs.com/blackmatrix/p/6236573.html)

- 没找到中文文档，搜到的博客都是一些基础使用，官方应该还有很多值得发掘的地方

## 常规操作

- `alembic init migration` 初始化版本控制目录，该命令会创建如下文件和目录：

  ```sh
  alembic.ini # 提供了一些基本的配置，如数据库连接
  migration/
      env.py
      # 每次执行Alembic都会加载这个模块
      # target_metadata 主要提供项目Sqlalchemy Model 的连接(表模型)
      script.py.mako # 迁移脚本生成模版
      README
      versions/ # 存放生成的迁移脚本目录
  ```

- 修改 env.py 配置

  ```py
  # FIXME from sqlalchemy.ext.declarative import declarative_base
  # Base = declarative_base()
  from /path/to/modules import Base as BaseModule
  from /path/to/dbconfig import DbConfig
  # 配置数据库连接（也可以直接在alembic.ini中配置）
  sa_url = 'mysqlsql://{user}:{passwd}@{host}:{port}/{db_name}'.format(
      user=DbConfig.username,
      passwd=DbConfig.passwd,
      host=DbConfig.host,
      port=DbConfig.port,
      db_name=DbConfig.db_name
  )
  config.set_main_option('sqlalchemy.url', sa_url)

  # 修改 target_metadata = None
  target_metadata = BaseModule.metadata
  ```

- 从 modules 初始化数据库

  ```sh
  # 此时versions文件夹下会出现一个迁移脚本
  $alembic revision --autogenerate -m "init"
  # 生成一个模板，需要自己补充 upgrade 和 downgrade 实现
  $alembic revision -m "Add a email column to account table"
  $alembic upgrade head
  ```

- 进行一次数据库升级

  - 修改 module 文件，增加表或修改字段等，即 env.py

  - 自动生成部署脚本

    ```sh
    $ alembic revision --autogenerate -m "initdb"
    # 此时在versions文件夹下会根据模板自动生成一个迁移脚本
    # 根据模板的样式可以通过 alembic show [alembic_id] 来查看注释信息
    ```

  - `alembic upgrade head` 即可升级到最新版本

  - 此时数据库已发生更改

## 日志

[using-alembic-config-main-redirects-log-output](https://stackoverflow.com/questions/42427487/using-alembic-config-main-redirects-log-output)

## `alembic` 命令

- `alembic branches` 查看有哪些分支，结果是那些还没有执行应用到数据库中的脚本

- `alembic heads` 查看有哪些分支（查看的是升级脚本的关系，一般只有一个 HEAD，如果使用了多分支，这个表就会出现多条记录

- `alembic history` 查看升级历史记录

- `alembic upgrade`

  - `alembic upgrade head` 升级到 base 分支的最新版本

  - `alembic upgrade [ver_num]` 执行该升级脚本

  - `alembic upgrade [branch_name@head]` 执行该分支的升级脚本

- `alembic downgrade [version_num]` 降级到版本

  `alembic downgrade -1` 降级到 head 前一版本

## 测试

- 测试两个有相同 `down_revision` 的升级脚本

  ````sh
  $alembic heads
  vabc256seq001 (head)
  vabc256seq002 (head)

  $alembic upgrade heads

  ```sh
  # 数据库出现了两个版本号
  # 查看表结构，这两个脚本都已经执行了
  MySQL > select * from alembic_version;
  +---------------+
  | version_num   |
  +---------------+
  | 3918b7a3aec0  |  -- head 分支，与其他分支是平行关系，没有相互依赖
  | v256seq002    |  -- 2.5.6 分支的最新执行到的脚本序号
  | v257seq002    |  -- 2.5.7 分支的最新执行到的脚本序号
  +---------------+

  # 降级的话，会从 version_num 表里删除一条记录
  # 如果不指明是 2.5.6 这个分支的话，会默认从head分支回退一个版本
  $ alembic downgrade 2.5.6@head-1
  MySQL > select * from alembic_version;
  +---------------+
  | version_num   |
  +---------------+
  | 3918b7a3aec0  |
  | v256seq001    |
  | v257seq002    |
  +---------------+

  $ alembic downgrade 2.5.6@head-1 # 回退完，表里的数据也没了
  MySQL > select * from alembic_version;
  +---------------+
  | version_num   |
  +---------------+
  | 3918b7a3aec0  |
  | v257seq002    |
  +---------------+
  ````

## 分支和版本管理

单独归档

## 依赖

- 分支依赖

  TODO
  两个版本是并行的，不需要依赖吧？不过会出现 259 后面的脚本使用 257 创建的数据表的情况，有方法确定限制性哪条分支吗，如果是按照 version_location 顺序的话那就还好

  ```sh
  # 支持多个依赖项
  depends_on = ('55af2cb1c267', 'd747a8a8879', 'fa4456a9201')
  # 可惜的是不支持整个分支依赖，比如257的第一个脚本写上依赖于256，期望的是执行完全部256
  # 的脚本后，开始执行257的脚本，自动衔接；可是实际上是执行有 branch_labels = '2.5.6'那个
  # 脚本之后就开始执行257的脚本了，执行完所有257分支的脚本之后才开始执行256分支剩下的脚本，脚本执行顺序乱了
  depends_on = ('2.5.6')
  ```

## 升级脚本模板

```py
"""升级脚本备注信息
Revision ID: 当前升级脚本的版本号
Revise: 上一个升级脚本的版本号
Create Date: 创建时间
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '000000000002'
down_revision = '000000000001'
branch_labels = None
depends_on = None

def upgrade():
  """升级操作"""
  # ## commands auto generated by Alembic - please adjust! ###
  pass
  # ## end Alembic commands ###

def downgrade():
  """降级操作"""
  # ## commands auto generated by Alembic - please adjust! ###
  pass
  # ## end Alembic commands ###
```

### 索引

- 多个字段作为唯一索引

  ```py
  op.create_index('idx_bbc_device_list_query', 'bbc_device_list',
                  ['id', 'key', 'auth_id', 'delete_flag'], unique=True)
  ```

- 唯一索引

  ```py
  op.create_index(op.f('ix_bbc_device_list_id'), 'bbc_device_list', ['id'], unique=False)
  op.create_index(op.f('ix_bbc_device_list_key'), 'bbc_device_list', ['key'], unique=True)
  ```

### 表结构

> FIXME 我有点迷惑了，升级脚本里描述了一遍表的结构和字段属性，为什么`表模型`那里又要描述一遍，而且不知道以哪个为准？有时候升级脚本没有限制说该字段是 `unique` 的，但是 `表模型` 那里有说明，实际上却没有效果？

- 数据类型

  > https://blog.csdn.net/aimill/article/details/81531499

  ```py
  from sqlalchemy.dialects.mysql import VARCHAR, INTEGER
  import sqlalchemy as sa
  # 类型区别

  sa.Column('org_id', sa.String(length=16), server_default='0', nullable=False)
  sa.Column('org_id2', sa.Integer(), server_default='0', nullable=False)

  sa.Column('org_id', VARCHAR(16), server_default='0', nullable=False)
  sa.Column('org_id', INTEGER, server_default='0', nullable=False)
  ```

- 添加表

  ```py
  from alembic import op
  import sqlalchemy as sa
  def upgrade():
    op.create_table(
      'bbc_org',
      sa.Column('id', sa.Integer(), nummable=False, primary_key=True),
      sa.Column('main_dns', sa.String(length=16), nummable=False),
    )

  def downgrade():
    op.drop_table('bbc_org')
  ```

- 创建索引

  ```py
  # 创建联合唯一索引
  def upgrade(self):
    op.create_index('ix_bbc_org_dhcp_cfg', 'bbc_org_dhcp_cfg', ['id', 'main_dns'], unique=True)

  def downgrade():
    op.drop_index(op.f('ix_bbc_org_dhcp_cfg'), table_name='bbc_org_dhcp_cfg')
  ```

- 添加表字段

  ```py
  op.add_column('table_name', sa.Column('column_name', sa.Integer(), server_Default='0', nullable=False))
  ```

- 修改字段属性

  ```py
  from alembic import op
  import sqlalchemy as sa
  def upgrade():
    op.alter_column('table_name', 'column_name', existing_type=sa.VARCHAR(length=90), type_=sa.String(length=2048))
  ```

- 删除回退

  ```py
  from alembic import op
  import sqlalchemy as sa

  # 删除表
  op.drop_table('table_name')

  # 删除索引
  op.drop_index(op.f('index_name'), table_name='table_name')

  # 删除字段
  op.drop_column('table_name', 'column_name')
  ```

## 多版本并行开发的数据库升级问题

### 问题描述

- 并行开发，序号手工递增，版本冲突

  > 不懂为什么要手工递增这个编号，alembic 原本是自动生成迁移脚本，需要时随机的

- `2.5.7` 版本和 `2.5.9` 版本并行开发，`2.5.7` 写了升级脚本 `abcdef40_device_list.py`，`2.5.9` 写了升级脚本 `abcedf40_epool_dhcp_pool.py` 最后把两个版本都合到 `2.5.10` 中，`alembic upgrade head`执行数据库升级脚本就会有问题，因为存在两个 `abcedf40` 编号的脚本.

- `2.5.7` 和 `2.5.9` 版本都是基于 `2.5.6` 版本进行开发的，`2.5.7` 版本已发布出去，最新的脚本序号是 `43`，`2.5.9` 版本也已经发布，最新的脚本序号是 `44`

### 方案一

- 先把脚本理清楚，比如 A 合入 B 时，把 B 的脚本编号修改为从 A 版本最大的编号开始排号
  这样的话从没升级过 A 或 B 的版本，比如 A-升级上来没问题，但是如果某些设备已经升级到 A，某些已经升级到 B 了，那这个方法就没用了，因为你不可能登录到所有设备上去修改这些脚本编号。其实并行开发没问题，问题的关键在于这个升级脚本的序号会关联到一起，所以，如果能把序号分开就 OK 了

- **从哪个版本升级上来就把那个版本的脚本拷贝到 version_control 下**

  - 即 `version_control` 下按版本存放的文件夹为先放当前版本的，再放后续版本的；然后在数据库升级的前先判断设备当前的版本是 `2.5.9`，将要升级到 `2.5.10`，则把 `version_control/2.5.9/` 下的脚本拷贝到 `version_control/` 下再执行 `alembic upgrade head` 升级

  ```sh
  version_control
      abcdef39_xxx.py
      2.5.6/
          abcdef40_xxx.py
          abcdef41_xxx.py
          abcdef42_xxx.py
          abcdef43_xxx.py
      2.5.7/
          # 本版本的序号优先排序，这样的话从已发布出去的257升级到257不会有问题，从257升级到259也没问题
          # 分文件夹的目的是为了理顺脚本升级顺序，所以每个文件夹下最后的脚本序号肯定是一致的
          abcdef40_aaaaa.py
          abcdef41_aaaaa.py
          abcdef42_bbbbb.py  # 即 abcedf40_bbbbb.py
          abcdef43_bbbbb.py  # 即 abcedf41_bbbbb.py
      2.5.9/
          # 本版本的序号优先排序
          abcdef40_bbbbb.py
          abcdef41_bbbbb.py
          abcdef42_aaaaa.py  # 即 abcedf40_aaaa.py
          abcdef43_aaaaa.py  # 即 abcedf41_aaaaa.py
      2.5.10/
          .. # 空文件夹，处理从2510升级到2510的情况，也要保证能找到2510的文件夹
             # 否则会默认从256文件夹下拷贝脚本
      # 2.5.10以后版本的升级脚本可以直接放在外层目录下，如果不会再冲突的话
      abcdef44_ccccc.py
  ```

- 优点

  - 解决了当两个版本并行开发存在数据库升级脚本冲突，而且都已经发布出去了，新版本要合入这两个冲突版本导致数据库升级失败的问题

- 缺点

  - 脚本冗余
    比如上面的 2.5.7 和 2.5.9, 很多脚本内容都是一样的，只是为了理顺序号而把很多相同内容的脚本拷贝了一次

  - 处理逻辑不清晰
    不加说明不知道为什么就 257 和 259 要分文件夹，后续新版本的脚本不知道要不要放到文件夹内，而且还涉及到了开机升级过程（升级的时候会先拷贝版本文件到/sf/cfg/last_version_dc，并且执行脚本去把版本对应的文件夹下的文件拷贝到 version_control 下）

  - 灵活度非常低
    现在 `2.5.13` 和 `2.5.14` 版本出现了脚本序号冲突，而且也是都发布出去了（其实 `2.5。13` 就仅仅是新增了一个脚本而已），按照现在的方案，`2.5.6 到 2.5.14` 之间的版本如果需要升级到 `2.5.14` 则都需要新建一个对应版本的文件夹，然后把理顺次序之后的脚本放进去。比如 `2.5.14` 需要支持 `2.5.6` 升级上来，则 `2.5.6`文件夹下就需要放从 `e4f027f58cb39 - e4f027f58cb68` 共几十个脚本，而且每个版本有正式版和 beta 版，文件夹下都有那么多脚本

### 方案二

> 参见[分支和版本管理]那一节，主要是用了 branch_lanble 属性和 version_locations 配置

- 这种方法只是更好地组织多版本开发的场景下的升级脚本，并没有解决到目前遇到的问题，现在 257 已经发布出去了，比如升级到了 40 号脚本；259 也已经发布出去了，升级到了 43 号脚本，两个版本都是紧接着 36 号脚本开发的，所以如果 257 要升级到 2510，就要把 259 的升级脚本需要重新整理。

- XXX 解决方法是，从现在这个版本开始，往后的版本都用新的脚本归档方案；以目前为止最大的序号，比如 40 开始作为基准，259 版本的脚本归档到 259 文件夹下，基于 40 开始创建 2.5.9 分支（配置 branch_label 属性）; 实行新方案以前的版本升级时，仍然保留着方案一的做法，即会从 257 版本文件夹下把脚本全部拷贝出来（根据方案一，此时 257 下最大的脚本需要就是 40）；升级命令修改为 `alembic upgrade heads` 这样就可以把基线升级到 40 号，并且执行 259 的脚本

## 回滚

升级脚本有两个操作：增加一个字段和修改一个字段属性，但是在执行过程中，由于语法问题修改字段语句没有执行成功，报错了。查看数据库版本号没有变更，修改脚本后再次执行，会报脚本中需要新增的字段在数据库中已存在，只能把新增字段语句注释掉，然后才能再次执行。没报错执行完成后，数据库版本号才改变也就是说这个 `upgrade` 操作 **不是事务性** 的

https://github.com/sqlalchemy/alembic/issues/755

## 其他

- 当出现两个同编号的脚本时，`alembic` 只会执行其中的一个，而且版本号已经更新为新的了，那我后续想修复，有没有办法单独执行漏掉的那个？

- `run_migrations_online`

- [alembic 中的 op 模块使用](https://blog.csdn.net/Zp18189530679/article/details/111566700#t1)

- `upgrade()` 操作不是原子性地
