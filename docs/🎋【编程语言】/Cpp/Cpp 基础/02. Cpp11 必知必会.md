- [参考资料](#参考资料)
- [`CPP11`](#cpp11)
  - [★ 关键字](#-关键字)
    - [`auto` 的原理是什么](#auto-的原理是什么)
    - [`decltype`](#decltype)
    - [`constexpr`](#constexpr)
  - [初始化列表](#初始化列表)
  - [★ 左右值引用和完美转发](#-左右值引用和完美转发)
    - [什么叫左值右值](#什么叫左值右值)
    - [左值引用和右值引用](#左值引用和右值引用)
    - [移动构造和移动赋值运算符](#移动构造和移动赋值运算符)
    - [所有权转移 `std::move`](#所有权转移-stdmove)
      - [`std::move` 需要注意什么](#stdmove-需要注意什么)
      - [复制 `copy` 和 `move` 的区别](#复制-copy-和-move-的区别)
    - [引用折叠问题](#引用折叠问题)
    - [完美转发 `std::forward`](#完美转发-stdforward)
      - [实现原理](#实现原理)
  - [`lambda`](#lambda)
    - [`lambda` 底层实现](#lambda-底层实现)
    - [lambda 表达式和内联函数有什么区别](#lambda-表达式和内联函数有什么区别)
    - [`lambda` 表达式用在什么场景下](#lambda-表达式用在什么场景下)
  - [委托构造](#委托构造)
  - [继承构造](#继承构造)
  - [`std::function`](#stdfunction)
  - [`std::bind`](#stdbind)
  - [★ `nullptr` 和 `NULL`](#-nullptr-和-null)
  - [★ 智能指针](#-智能指针)
    - [智能指针的原理](#智能指针的原理)
    - [C++98 中的 `auto_ptr` 有什么问题](#c98-中的-auto_ptr-有什么问题)
    - [C++11 新型智能指针](#c11-新型智能指针)
      - [`unique_ptr`](#unique_ptr)
      - [`shared_ptr`](#shared_ptr)
        - [智能指针什么时候改变引用计数](#智能指针什么时候改变引用计数)
      - [`weak_ptr`](#weak_ptr)
- [其他](#其他)

# 参考资料

- [C++ 智能指针详解](https://mp.weixin.qq.com/s/jOJNGY28riwxmTZM901n1w)

- [★ C++11 新特性扫盲](https://mp.weixin.qq.com/s/G7HwKlSA1d8h2nRTs8s1DA)

- [C++11 新特性](http://mp.weixin.qq.com/mp/homepage?__biz=MzI2MDYyNDgzMQ==&hid=11&sn=06773b401470580f7cf24a9385a8495c&scene=18#wechat_redirect)

- [C++11 常用新特性快速一览](https://blog.csdn.net/jiange_zh/article/details/79356417)

# `CPP11`

## ★ 关键字

C++11 引入了 auto 和 decltype （declare：声明） 关键字，使用他们可以在`【编译阶段】`就推导出变量或者表达式的类型，方便开发者编码也简化了代码。

### `auto` 的原理是什么

让编译器在 `【编译期间推导出变量类型】`，可以通过等号右边的类型推导出变量的类型；`auto` 作为函数返回值时，只能用于定义函数；不能用于声明函数

```c++
// 10 是 int 型，可以自动推导出 a 是 int
auto a = 10;
```

[C++11 中的 auto 和 decltype 的原理](https://www.zhihu.com/question/294048058/answer/702463871)

当你在代码里面写了这么一句话 `std::string str; int n = str;` 编译的时候，肯定会报错说 `std::string` 无法转化为 `int`，这说明`编译器明明是知道等号右边是什么类型`，也就是说，编译器完全有能力根据等号右边去推断出左边可以定义成什么类型。这就是 auto 这个特性可以做出来的原因。auto 只是编译器自动根据一定的规则帮你写了类型而已，因为他知道。

`auto` 使用的是 ==【模板实参推断（Template Argument Deduction）】== 的机制；auto 被一个虚构的模板类型参数 T 替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，相当于利用了其中进行的实参推断，承担了模板参数 T 的作用

```cpp
auto pos = container.begin()

// 相当于下面这个模板传参时的情形，T 就是为 auto 推断的类型
template<typename T>
void deducePos(T pos);
deducePos(containser.begin());
```

### `decltype`

[C++ decltype](https://blog.csdn.net/u014609638/article/details/106987131)

相对于 `auto` 用于推导变量类型，而 `decltype` 则用于`【推导表达式类型】`，这里只用于编译器分析表达式的类型，表达式实际不会进行运算

```cpp
const int &i = 1;
int a = 2;
decltype(i) b = 2;  // b 是 const int&

int a = 0, b = 0;
decltype(a + b) c = 0;   // c 是 int，因为 (a + b) 返回一个右值
decltype(a += b) d = c;  // d 是 int&，因为 (a += b) 返回一个左值
d = 20;
cout << "c " << c << endl;  // 输出c 20
```

### `constexpr`

（express 表达） 近似 const，可以修饰变量，也可以修饰函数

- `constexpr` 修饰的函数，生效于`【编译期】`；重点应用于修饰函数 `使其在编译期大幅度被解释`

- `constexpr` 修饰的函数，无论是普通函数，还是类成员函数，`【必须是编译器可计算得到结果】`，即字面常量，不可是运行时才能获取的内容

```c++
#include <iostream>
using namespace std;

constexpr int func(int i)
{
    return i + 1;
}

int main()
{
    int i = 2;
    func(i);  // 普通函数
    func(2);  // 编译期间就会被计算出来
}
```

## 初始化列表

[C++11 初始化列表](https://blog.csdn.net/li1615882553/article/details/86529889)

C++11 中统一了初始化列表，即均可以使用 `{}` 来对对象进行初始化

```cpp
/* map 中 */
map<int, char> test = {
    {1, 'a'},
    {2, 'b'}
};

/* vector 中 */
vector<int> test = {1, 2, 3, 4};

vector<int> func()
{
    return {1, 2, 3, 4};
}

/* matrix 中 */
vector<vector<int>> matrix;
matrix.push_back(vector<int> {});

/* 结构体中 */
struct People
{
    string name;
    int pos;
};

People p[2]
{
    {"ab1", 1},
    {"ab2", 2}
};
```

## ★ 左右值引用和完美转发

[★ 我理解的右值引用、移动语义和完美转发](https://www.jianshu.com/p/d19fc8447eaa/)

[【Modern C++】深入理解移动语义](https://mp.weixin.qq.com/s/vIeeIw817ZPSL6uYZmD5OQ)

引入了右值引用和移动语义，可以`避免无谓的复制`，提高程序性能

### 什么叫左值右值

在 C++中==右值指的的临时值或常量==，更准确的说法是保存在 CPU 寄存器中的值为右值，而保存在内存中的值为左值。

感觉左值就是结果值，右值就是一个临时值

- 左值是指表达式结束后依然存在的 `持久` 对象，在等号左边

- 右值是指表达式结束时就不存在的 `临时` 对象，在等号右边

### 左值引用和右值引用

> - 左值引用就是通常说的引用、别名
> - 右值引用就是省略了临时变量拷贝的过程，引用临时变量

**`左值引用（就是原来那种）`**

```c++
int a = 10;

// refA 是 a 的别名，修改 refA 就是修改a
// a 是左值，refA 是左值引用
int& refA = a;

//编译错误! 1是右值，不能够使用左值引用
int& b = 1;
```

**`右值引用`**

在 C++11 之前，当进行值传递时，编译器会隐式调用拷贝构造函数；自 C++11 起，通过右值引用来避免由于拷贝调用而导致的性能损失。

```c++
int a = 10;

// 实质上就是将匿名变量取了个别名
int &&a = 1;

// 编译错误！不能将一个左值复制给一个右值引用
int b = 1;
int &&c = b;

class A
{
public:
    int a;
};

A getTemp()
{
    return A();
}
// getTemp()的返回值是右值（临时变量）
A && a = getTemp();

/*
getTemp() 返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量）

但是，通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量a的生命期一样，只要a还活着，该右值临时变量将会一直存活下去

实际上就是给那个临时变量取了个名字
*/
```

### 移动构造和移动赋值运算符

[移动构造函数和移动赋值](https://blog.csdn.net/craftsman1970/article/details/81087262)

右值引用的主要用途是创建移动构造函数和移动赋值运算符。移动拷贝和移动赋值就是 `将对右值引用作为形参进行拷贝或者赋值`，**移动 `std::move` 代替拷贝，从而避免创建新对象**

直接使用临时对象已经申请的资源，它以右值引用为参数，拷贝为左值；由于临时对象是右值，需要用 `move` 函数强制转换为左值。

**移动构造**

```cpp
/* 要考虑深拷贝的处理 */

/* old */
Test(Test& t)
{
    // 需要用 strcpy 或者 memcpy 等方式来进行内存拷贝
    // 把 t.text 的值拷贝到 test
    int len = strlen(t.text)
    auto test = new char[len + 1];
    strcpy(test, t.text);
}

/* new */
/* 移动代替拷贝：不需要额外分配资源，也不需要拷贝 */
Test(Test && t)
{
    // t.text 的资源被 `移动` 到了 test 上
    // 然后把 t.text 置为默认值（因为移动后，原来的资源不能再被访问了）
    auto test = t.text;
    t.text = nullptr;
}
```

**移动赋值运算符**

```cpp
/* 重载 赋值运算符*/

/* old */
Test& operator = (const Test& rhs)
{
    if (this != &rhs)
    {
        free();
        if (rhs.text != nullptr)
        {
            int len = strlen(rhs.text);
            auto text = new char[len + 1];
            strcpy(text, rhs.text);
        }
    }
    return *this;
}

/* new */
Test& operator = (Test&& rhs) noexcept
{
    if (this != &rhs)
    {
        free();
        // 移动代替拷贝
        auto text = t.text;
        t.text = nullptr;
    }
    return *this;
}

```

### 所有权转移 `std::move`

无论你传给它的是左值还是右值，通过 `std::move` 都给你转成右值

- 引入了右值引用和移动语义，`避免无谓的复制，提高程序性能`

- `std::move` 只是转移了资源的控制权，`本质上是将左值强制转化为右值使用`，以用于移动拷贝或赋值，避免对含有资源的对象发生无谓的拷贝

- `vector::push_back` 等这类函数时, 会对参数的对象、数据进行复制；这就会造成对象内存的额外创建, 本来原意是想把参数 `push_back` 进去就行了, `【通过 std::move，可以避免不必要的拷贝操作】`

  ```cpp
  string str1("hello");
  string str2("world");
  string str3(str1);
  string str4(std::move(str1));

  string str5;
  str5 = std::move(str2);
  // 虽然将str2的资源给了str5，但是str2并没有立刻析构，【只有在str2离开了自己的作用域的时候才会析构】
  // 所以，如果继续使用str2变量，可能会发生意想不到的错误。

  for(int i = 0; i < 1000; i++)
  {
      // string("hello") 只是临时对象，拷贝完就没什么用了，这就造成了没有意义的资源申请和释放操作
      // 如果能够直接使用临时对象已经申请的资源，既能节省资源，又能节省资源申请和释放的时间
      // 而 C++11 新增加的移动语义就能够做到这一点。
      string tmp("hello");
      vecStr2.push_back(std::move(tmp));
  }
  ```

- `std::move` 是将对象的状态或者所有权从一个对象转移到另一个对象，`只是所有权转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率`, 改善性能。

  ```cpp
  // std::move 将它的【前两个输入迭代器参数指定的序列移到第三个参数定义的目的序列的开始位置】，第三个参数必须是输出迭代器。这个算法返回的迭代器指向最后一个被移动到目的序列的元素的下一个位置。

  std::vector<int> srce {1, 2, 3, 4};
  std::deque<int> dest {5, 6, 7, 8};
  std::move(std::begin(srce), std::end(srce), std::back_inserter(dest));
  ```

- 移动语义可以使用在 `string` 拷贝的场景下，比如 string a 赋值给 string b 的情况下，而且 a 不在使用的情况

- 还有就是 `uniq_ptr` 智能指针场景，`uniq_ptr 智能指针独占资源`，不用使用智能指针传递，可以使用 move 语义进行资源转义

#### `std::move` 需要注意什么

==**源元素还不会释放，如果用了 `std::move` 就不要再用源元素了**==

- 如果源可以被替换或破坏，就可以选择使用 move() 算法。`如果不想扰乱源，可以使用 copy() 算法`

- `移动操作【无法保证】在进行这个操作之后，输入序列仍然保持不变`

- 源元素仍然会存在，但它们的值可能不再相同了，==因此在移动之后，就不应该再使用它们==

- 需要在在类中实现移动构造函数和移动拷贝函数

  - 并且在实现的时候需`要把被拷贝对象的成员变量设置为 nullptr 值`

  - 并且避免在析构函数中注意不要意外释放

- c++11 中 STL 所有容器都已经实现了移动构造和移动拷贝函数

#### 复制 `copy` 和 `move` 的区别

![alt](http://upload-images.jianshu.io/upload_images/4427263-81a47fdc9b8d9e98.png)

- 以 string 为例，string a 拷贝给 string b，首先 string b 开辟一个和 string a 成员变量 c_str 指向的字符串大小的空间，然后拷贝 string a 的 c_str 指向的内容。这就是复制。

- 而 move 则是，string b 的 c_str 指向 string a 的 c_str 指向的地址空间，类似于浅拷贝，然后 a 放弃对这块地址空间的控制权，指向 nullptr 空指针，然后 string a 就不能再操作，减少了不必要的拷贝操作，这就是 move 操作

- copy 就是照着别人的东西复制一份，所需的工作量随拷贝对象的不同而不同，比如拷贝一个字很快，拷贝一本书很慢。

- move 就是把别人书上的名字擦掉，写上自己的。因为 move 不需要复制，所以很快。其实就是把自己的指针指过去，把原属主的指针指向别处。

### 引用折叠问题

[通用引用、引用折叠与完美转发问题](https://blog.csdn.net/qq_38216239/article/details/80815142)

如果间接创建了一个`引用的引用`，那么这些引用就会折叠

- 引用折叠规则

  - 所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）

  - 所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）

### 完美转发 `std::forward`

[聊聊 C++ 中的完美转发](https://zhuanlan.zhihu.com/p/161039484)

为了解决引用折叠问题，必须写一个任意参数的函数模板，并转发到其他函数，为了保证完美转发，必须使用 `forward()`；我们希望左值转发之后还是左值，右值转发之后还是右值。

它的作用是保持原来的值属性不变；通俗的讲就是，如果原来的值是左值，经 `std::forward` 处理后该值还是左值；如果原来的值是右值，经 `std::forward` 处理后它还是右值

```c++
#include <iostream>
using namespace std;

void print(int& t)
{
    cout << "传入左值，打印" << endl;
}

void print(int&& t)
{
    cout << "传入右值，打印" << endl;
}

template<typename T>
void testForward(T && v)
{
    print(v);

    // 用了 std::forward 函数，所以不会改变它的右值属性
    print(forward<T>(v));

    // std::move 不管你左值右值，一律转换成右值
    print(move(v));
}

int main(int argc, char * argv[])
{
    // 传入的 1 虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）
    testForward(1);

    cout << "======================" << endl;

    // 传入左值
    int x = 1;
    testForward(x);
}

/*
传入左值，打印     // print(v);
传入右值，打印     // ---------- print(forward<T>(v));
传入右值，打印     // print(move(v));
======================
传入左值，打印     // print(v);
传入左值，打印     // ---------- print(forward<T>(v));
传入右值，打印     // print(move(v));
*/
```

#### 实现原理

- `实现了两个模板函数，模板函数对传入的参数进行强制类型转换`，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。

  ```cpp
  // typename std::remove_reference<T>::type 含义就是获得去掉引用的参数类型

  // 左值引用模板函数
  template <typename T>
  T&& forward(typename std::remove_reference<T>::type& param)
  {
      return static_cast<T&&>(param);
  }

  // 右值引用模板函数
  template <typename T>
  T&& forward(typename std::remove_reference<T>::type&& param)
  {
      return static_cast<T&&>(param);
  }
  ...
  ```

## `lambda`

- [C++中的 Lambda 表达式](https://www.jianshu.com/p/96e9dba6e7a9)

- [C++ 11 Lambda 表达式](https://www.cnblogs.com/DswCnblog/p/5629165.html)

- [C++11 lambda 表达式与函数对象](https://blog.csdn.net/u010525694/article/details/72846701?locationNum=3&fps=1)

- 栗子

  ```cpp
  int main()
  {
      auto func = [](int a, int b){return a>b;};
      sort(data.begin(), data.end(), [](int& a, int& b)->bool{ return a > b; });


      int a = 0;
      // 因为 a 在外部，所以要把 a 放入到捕获列表中，否则 lambda 内部无法访问
      auto f = ([a]()->void {cout << a << endl;});
      f();

      // 通过引用访问，可以修改 a 的值
      auto f1 = ([&a]()->void {a++;});
      f1();

      return 0;
  }
  ```

- 函数原型

  ```cpp
  [capture list](param list) mutable exception ->return_type {body}
  ```

  - 捕获列表和函数体是必须有的,(但捕获列表可以为空)

  - 不支持默认参数、不支持可变参数、所有参数必须有参数名

  - `capture-list`: 捕捉外部变量列表,可在 lambda 中使用其所在函数体的局部变量

    如果以值传递方式捕获外部变量，在 lambda 表达式函数体内不能修改该外部变量（除非加上 mutable)

    `[]` 的形式有以下几种：

    - `[]` 未定义任何变量，不能访问 lambda 之外定义的变量

    - `[x, &y]` x 是通过值复制来访问的，y 通过引用访问

    - `[&]` 能通过引用访问外部所有变量

    - `[=]` 外部变量都是通过值复制来访问

    - `[&, x]` x 通过值复制访问，其他变量通过引用访问

    - `[=, &z]` z 通过引用访问，其他变量通过值捕获

  - `params`: 形参列表

  - `mutable`: 说明是否允许修改捕捉的变量

  - `exception`: 异常设定

  - `ret_type`: 返回类型, 如果没有 return 语句, 则默认为 void

  - `body`: 函数体

- Python 中时怎么用匿名函数的

  > 学习 lambda 先知道 **闭包**，可以回想一下 python 的装饰器（其实闭包就是变量作用域的问题)

  ```py{cmd=true}
  list(map(lambda x: x*x, [1, 2, 3, 4,]))
  ```

- `闭包` 可以不通过传参获取调用者的上下文环境

  闭包: 引用了自由变量的函数, 这个被引用的自由变量将和这个函数一同存在，即使离开了创造它的环境

### `lambda` 底层实现

> - [C++11 LAMBDA 表达式是如何实现的](https://www.cnblogs.com/diegodu/p/9377438.html)
> - 编译器创建了一个重载了 `()` 的类，让我们可以像调用函数一样使用；`【函数对象】`

![alt](https://i1.wp.com/blog.feabhas.com/wp-content/uploads/2014/08/image_thumb.png?zoom=2&resize=365,332)

### lambda 表达式和内联函数有什么区别

- 内联函数实际是代码片段，在调用出展开，`不会进行函数入栈出栈的操作`

- lambda 是匿名函数，实际是个函数，会进行函数调用过程

### `lambda` 表达式用在什么场景下

> - 在函数参数为`函数指针`的情况下，比如 sort 排序时使用
> - lambda 表达式可以`替代仿函数`，减少代码中的函数对象
> - 可以用 `auto` 变量或者 `function` 类来接受 lambda 表达式

- 传`函数指针的地方`都可以用 lambada 表达式，比如使用 stl 的 sort 排序的时候

  ```cpp
  sort(testdata.begin(), testdata.end(), [](int a, int b){ return a > b; });
  ```

- 用 `auto` 变量或者 `function` 类来接受函数

  用 auto 来接收一个 `lambda` 表达式，当然也可以直接使用 `C++11` 里面的新特性 `function` 来接收 `lambda` 表达式，两者等价的，因为 `auto` 是自动类型转换,所以在某些场合使用起来更方便

  ```cpp
  auto add = [](int a, int b) {return a + b;};

  std::function<int(int, int)> Add = [=](int a, int b) { return a + b; };

  cout << add(x, y) << endl;
  ```

- `实现递归算法`

  ```cpp
  /**
   * 已知 f(1)=1, f(2)=2
   * 那么请实现 f(n) = f(n - 1) + f(n - 2)
   * 此处的 n>2
   */

  std::function<int(int)> recursion = [&recursion](int n) {
      return n < 2 ? 1 : recursion(n - 1) + recursion(n - 2);
  };
  cout << "recursion(2):" << recursion(2) << endl;
  ```

- lambda 表达式可以`替代仿函数`，减少代码中的函数对象

  ```cpp
  class Tax
  {
  public:
      Tax(float r, float b):_rate(r),_base(b){}
      float operator()(float money)
      {
          return (money-_base)*_rate;
      }
  private:
      float _rate;
      float _base;
  };
  // Tax high(0.40,30000);
  // Tax middle(0.25,20000);
  // Tax low(0.12,10000);
  // cout<<"大于 3w 的税:"<<high(37500)<<endl;
  // cout<<"大于 2w 的税:"<<middle(27500)<<endl;
  float rate = 0.40;
  float base = 30000;
  auto high = [&](float money){return (money-base)*rate;};
  ```

- 在 `for_wach` 语句中使用

  ```cpp
  // for_each(vi.begin(), vi.end(), [](int i){cout<<i<<endl;});

  int count;
  bool op(int a) {
      printf("%d ",a);
      count++;
      if(count==10) {
          count=0;
          puts("");
      }
      return 1;
  }

  int main() {
      int a[1000];
      count = 0;
      fill(a, a + 1000, 1);
      for_each(a, a + 1000, op);
      return 1;
  }
  ```

- 存在大量的小函数，而这些函数一般只被调用一次

## 委托构造

委托构造函数允许在 `同一个类中一个构造函数调用另外一个构造函数`。

```cpp
struct A
{
    A(){}
    A(int a) { a_ = a; }
    // 委托构造函数，构造函数中调用另一个构造函数
    A(int a, int b) : A(a) { b_ = b; }
    A(int a, int b, int c) : A(a, b) { c_ = c; }
    int a_;
    int b_;
    int c_;
};
```

## 继承构造

继承构造函数可以让 `子类直接使用父类的构造函数`，如果有一个子类，我们希望子类采用和父类一样的构造方式，那么可以直接使用父类的构造函数，而不是再重新写一遍构造函数

```cpp
struct Base
{
    Base() {}
    Base(int a) { a_ = a; }
    Base(int a, int b) : Base(a) { b_ = b; }
    Base(int a, int b, int c) : Base(a, b) { c_ = c; }
    int a_;
    int b_;
    int c_;
};

struct Derived : Base
{
    using Base::Base;
};

int main()
{
    Derived a(1, 2, 3);
    return 0;
}

```

## `std::function`

[Cpp11 新特性之 std::function 与 std::bind](https://www.jianshu.com/p/e396c1aab4b0)

`std::function` 类模板是一种通用的函数包装器，它可以容纳所有可以调用的对象（Callable），包括 函数、函数指针、Lambda 表达式、bind 表达式、成员函数及成员变量或者其他函数对象

因为 `std::function` 兼容 C 的函数指针，所以它还包含函数指针应有的特性。但是它又和函数指针不同，函数指针只能指向一个函数，而 `std::function` 可以指向任何可以被当做函数调用的对象（函数对象）

```cpp
#include <iostream>
#include <functional>
#include <list>
using namespace std;

int c_function(int a, int b)
{
    return a + b;
}

class Functor
{
public:
    int operator()(int a, int b)
    {
        return a + b;
    }
};

int main(int argc, char** argv)
{
    // std::function 作为回调函数使用，它可以调用任何有两个int形参的返回值为int的对象
    std::list<std::function<int(int, int)>> callables;

    // 普通函数
    callables.push_back(c_function);

    // 函数对象
    Functor functor;
    callables.push_back(functor);

    // 匿名函数 lambda
    callables.push_back([](int x, int y)->int{
        return x + y;
    });

    for (const auto& func : callables)
    {
        cout << func(3, 4) << endl;
    }

    ////////////////////////////////////////////////////////

    cout << "C++11 以前的做法" << endl;

    // 定义一个函数指针类型
    typedef int (*lpFunc)(int, int);

    // 定义一个 lpFunc 函数指针类型的容器
    std::list<lpFunc> c_callables;
    // 普通函数
    c_callables.push_back(c_function);
    // 匿名函数 lambda
    c_callables.push_back([](int x, int y)->int{
        return x + y;
    });
    // 不支持函数对象
    for (const auto& func : c_callables)
    {
        cout << func(3, 4) << endl;
    }
}

```

## `std::bind`

> `std::bind` 函数用来绑定函数的某些参数并生成一个新的 function 对象 （Python 中的偏函数）

bind 用于实现偏函数（Partial Function），将函数的一些参数绑定上值，其余部分用占位符对象（`std::placeholders`）表示。占位符是有序号的，代表调用此函数对象时参数在参数列表中的位置。比

```c++
#include <iostream>
#include <functional>
using namespace std;

// 一个参数复杂的函数
void func_muti(int a, std::string&& b, const char* c, double d, char e)
{
    std::cout << a << ", " << b << ", " << c << ", " << d << ", " << e << "\n";
}

int main(int argc, char* argv[])
{
    // 偏函数，预置一些参数
    auto func = bind(&func_muti, 24, placeholders::_1, "arg_char*", placeholders::_2, 'c');
    func("arg_string", 24.24);
    return 0;
}

```

## ★ `nullptr` 和 `NULL`

- 传统 C++ 会把 `NULL`、`0` 视为同一种东西，这取决于编译器如何定义 `NULL`，有些编译器会将 `NULL` 定义为 `((void*)0)`，有些则会直接将其定义为 `0`

- `C++ 【不允许直接将 void * 隐式转换到其他类型】`，但如果有些编译器把 `NULL` 定义为 `((void*)0)`，那么当编译 `char *ch = NULL;` 时，`NULL` 只好被定义为 `0`。而这依然会产生问题，`【将导致了 C++ 中重载特性会发生混乱】`

## ★ 智能指针

### 智能指针的原理

- 智能指针`实质是一个类`，行为上表现得像一个指针（如使用->访问）这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针来实现资源的分配和释放。

- 智能指针的类`都是栈上的对象`，所以当函数（或程序）结束时会自动被释放

- 声明一个智能指针，实际的指针在内部保存，当智能指针析构时引用计数减一，当引用计数减为零时才释放真正的对象

### C++98 中的 `auto_ptr` 有什么问题

[c++：智能指针（c++98 版本 auto_ptr）](https://blog.csdn.net/weixin_42423872/article/details/99059529)

- **多个 auto_ptr 不能同时指向同一个对象**

  ```cpp
  // ERROR
  Test *t1 = new Test(3);
  auto_ptr<Test> ptr1(t1);
  auto_ptr<Test> ptr2(t1);
  // ptr1 与 ptr2 都认为指针 t1 是归它管
  // 析构时都试图删除 t1，这样就造成了重复释放问题
  ```

- **不能管理数组指针**

  因为 auto_ptr 的析构函数中删除指针用的是 `delete`, 而不是 `delete []`，所以 auto_ptr 不能用来管理一个数组指针

- **不可做为容器元素**

  ```cpp
  // ERROR
  vector<auto_ptr<int>> vec;

  auto_ptr<int> ptr1(new int(3));
  vec.push_back(ptr1);
  ```

### C++11 新型智能指针

- [★ 智能指针（c++11 版本 unique_ptr、shared_ptr、weak_ptr）](https://blog.csdn.net/weixin_42423872/article/details/99064821)

- [C++11 中智能指针的原理、使用、实现](https://www.cnblogs.com/wxquare/p/4759020.html)

- [c++11 新特性之智能指针](https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484781&idx=1&sn=008834d760aa70559dc4d532a5383107)

#### `unique_ptr`

- 特点：所有权唯一，禁止拷贝和权限转移

- 缺点：`unique_ptr` 是简单粗暴的防止拷贝

- 这种比较简单，效率高，但是功能不全面，不支持拷贝和赋值操作，无法共享数据，可自主实现数据共享，但在释放时会导致堆内存重复释放导致系统崩溃。

- `unique_ptr` 只能由一个智能指针指向对象

  不支持复制和赋值，但比 auto_ptr 好，直接赋值会编译出错。实在想赋值的话，需要使用 `std::move` 转移所有权

  ```cpp
  {
      std::unique_ptr<int> uptr(new int(10));  // 绑定动态对象

      // 和 shared_ptr 相比，不能拷贝，不能赋值
      // std::unique_ptr<int> uptr2 = uptr;    // 不能赋值
      // std::unique_ptr<int> uptr2(uptr);     // 不能拷贝

      std::unique_ptr<int> uptr2 = std::move(uptr); // 转换所有权
      uptr2.release(); // 释放所有权
  }
  // 超过作用域，会自动释放内存
  ```

#### `shared_ptr`

可以有多个持有者的共享指针，即所谓引用计数型指针，直到最后一个持有者 delete 释放时，其指向的资源才会真正被释放

- 特点：`shared_ptr` 的实现原理是通过`【引用计数】`来实现

- 拷贝或赋值时将引用计数加 1，析构时只有当引用计数减到 0 才释放空间，否则只需将引用计数减 1 即可；shared_ptr 共享所有权。

- 引用计数有一个问题就是`【互相引用形成环】`，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用 `weak_ptr`

- `shared_ptr` 允许多个指针指向同一个对象

  基于引用计数的智能指针。可随意赋值，直到内存的引用计数为 0 的时候这个内存会被释放。

  ```cpp
  int a = 10;
  int *p = NULL;
  int testp = new int;

  // 传入指针，通过构造函数初始化
  shared_ptr<int> test(testp);

  // 用 make_shared 初始化
  shared_ptr<int> ptra = make_shared<int> a;

  // copy 指针ptra和ptra2都指向 a
  shared_ptr<int> ptra2(ptra);

  // 获取原始指针
  p = ptr.get();
  ```

##### 智能指针什么时候改变引用计数

- 构造函数中计数初始化为 `1`

- 拷贝构造函数中计数值 `+1`

- 析构函数中引用计数 `-1`

- 赋值运算符中，左边的对象引用计数 `-1`，右边的对象引用计数 `+1`

- 赋值运算符和析构函数中，如果减一后为 `0`，则调用 delete 释放对象

#### `weak_ptr`

> - `weak_ptr`是一个弱引用，只引用，不计数；是为了解决 `shared_ptr` 相互引用而存在的
> - 使用智能指针就一定没有内存泄漏了？不一定，使用不好也会有，比如共享指针 `shared_ptr` 相互包含就会导致内存泄漏，这是要用 `weak_ptr`

- 如果一块内存被 `shared_ptr` 和 `weak_ptr` 同时引用，当所有 `shared_ptr` 析构了之后，不管还有没有 `weak_ptr` 引用该内存，内存也会被释放

- `weak_ptr` 不保证它指向的内存一定是有效的，在使用之前需要检查是否为空指针

# 其他

- multiset、multimap、unordered_map、unordered_set 这些都是 C++11 加进来的

- [std::begin、std::end 标准库函数](https://blog.csdn.net/myruo/article/details/84330546)

  `begin` 返回首元素的地址，`end` 返回尾元素的下一个地址

  ```cpp
  int arr[5] = { 1, 2, 3, 4, 5 };

  //利用 begin、end 函数修改元素值
  for (int *p = begin(arr); p != end(arr); p++)
  {
      *p = 0;
  }

  for (auto i : arr)
  {
      cout << i << endl;
  }
  ```

- [成员函数.begin() 和 std::begin()](https://www.icode9.com/content-4-493991.html)

- [尾置返回类型](https://blog.csdn.net/lixiaogang_theanswer/article/details/81014190)

- [C++11 新特性（64）- 模板函数与返回类型后置](https://blog.csdn.net/craftsman1970/article/details/81949960)

  ```cpp
  // decltype 得到变量类型
  auto AddSum(int a, int b) -> decltype(a) // 只能用参数
  {
      int sum;
      ...
      return sum;
  }
  ```

- thread 查看网易云课堂课程【c++并发与多线程】课程

- delete 和 default 和 final

  - [C++11 中 =defaule 和 =delete 使用](https://blog.csdn.net/lmb1612977696/article/details/80035487)

  - [C++11 之 final 关键字](https://blog.csdn.net/u012333003/article/details/28696521)
