- [参考资料](#参考资料)
- [指针](#指针)
  - [`printf`输出字符串指针](#printf输出字符串指针)
  - [数组指针、指针数组、函数指针](#数组指针指针数组函数指针)
  - [函数指针](#函数指针)
  - [数组和指针的区别](#数组和指针的区别)
  - [野指针](#野指针)
- [智能指针](#智能指针)
  - [`unique_ptr`](#unique_ptr)
    - [禁止赋值和复制](#禁止赋值和复制)
    - [针对 auto_ptr 缺陷的改善](#针对-auto_ptr-缺陷的改善)
  - [`shared_ptr`](#shared_ptr)
    - [shared_ptr 相互引用问题](#shared_ptr-相互引用问题)
  - [`weak_ptr`](#weak_ptr)

# 参考资料

[★ 深入理解 C 语言指针的奥秘](https://blog.csdn.net/fengidea/article/details/30237233)

# 指针

```c++
int *p
int **p
int (*)p[3]
int *(*p) [4]

对于 int *p, 指向整形的指针变量p

指针变量(指针名)    p存放的是地址,32位中是4字节，64位系统中是8字节
指针的类型(除去指针名外的)  int *
指针所指向的类型为（除去指针名和 * 外的）   int
星号只是用来标识这是个指针
指针的值？
指针本身所占据的内存区？

int *p  变量p是指向int型区域的指针，p存放的是地址
<特别要注意这里 * 和 &是操作符，而前面int *p的*是表示p是个指针变量>

*p 得到的是p所指向的具体内容
*p = a 把变量a赋值给 *p指向的地方
a = *p 把变量p存放的地址里的内容赋值给a
p = &b  取b变量的地址赋值给p

typedef struct BinSearNode{
    ...
}BinSearchNode, *PBinSearchNode；
PBinSearchNode q；

问题：为什么？这里PBinSearchNode是个指针，为什么可以用它来定义 p ？
* 这不是相当于：typedef int* p; 这里p表示所有指向int类型的指针
例如: p a; 相当于 int* a; 详见typedef
```

- 指针的类型: `int *`

  指针本身所具有的类型（指针声明语句里除指针名字以外）

  ```cpp
  int (_ptr)[3]; //指针类型是 int(_) [3]
  ```

- 指针所指向的类型：`int`

  指针所指向的内存区（把指针声明的名字和名字左边的指针声明符`*`去掉就行）

  ```cpp
  int *ptr; //指向的类型是 int
  int *(*ptr)[4];` //指向的类型是 int *()[4]
  ```

- 指针的值：`ptr`

  - 指针本身存储的数值，被编译器当作一个地址

  - sizeof 测出对象 自身类型的大小：32 位系统的话 sizeof(指针变量)得到的是 4，而 64 位得到的是 8

  - 指针的值是 XX，相当于指针指向了以 XX 为首地址的一片内存区域

- 指针本身所占的内存区

  一样可以用 sizeof(指针类型)测出来,指针存的就是地址啊，一个字节 8 位，所以在 32 位系统里，是 4 个字节长度

- `指针的算术运算`

  - 指针变量 ptr 加 n 相当于变量所存地址向高方向加 `n * sizeof(指针所指向类型)`个字节

  - 一个指针 ptrold 加/减一个整数 n 后，结果是一个`新的指针`ptrnew

  ```cpp
  int a[3] = {1,2,3};
  cout << a << endl;
  int *ptr = a + 2;
  // a = a+2; // ERR
  cout << ptr << '\t' << *ptr << endl;
  ```

- 运算符 `&(取地址)和*(间接运算符)`

  - `&a` 的结果是一个指针，取地址
  - `*p` 的结果是 p 所指向的内容，获取 p 保存的地址对应的数据

- 指针表达式

  表达式的结果是一个指针的表达式

- 数组和指针的关系

  - 数组是有指针来完成的。

  - 声明一个数组 `TYPE array[n]`，数组名有两重含义，代表整个数组,类型是 `TYPE[n]` 或者代表一个指针, 类型是 `TYPE*`

  - `char str[3]={'a','b','c'};`，`*str`是一个指向数组第 0 号单元的指针；它与数组第 0 号单元占据的内存区是不同的，该指针是不能修改的, `str++`是错的,但 `*(str+1)`是对的

  - 对空指针应用 `delete` 是安全的

  - 可以用指针创建动态数组（可在运行时选择数组长度）.

  - `psome = psome + 1;` 指针和数组名之间的区别，不能更改数组名的值; 但指针是变量，可以修改它的值

  - c++把数组名解释为第一个元素的地址,`str[1]`实际上是`*(str+1)`; `str[2]`实际上是`*(str+2)` 先算出了元素地址再去取存在那里的值

  - 字符指针变量指向的字符常量中的内容是不能修改

    - `char \*p = "abcdef";`

    - `p[3]='z';` 错误 指针变量指向的值存放在常量区, 不允许修改

    - `*p++;` 先计算 p++(指针移动)再取值 , 正确

    - `(*p)++;` 取字符常量然后自增 1, 错误

    - `*p = 'b';` 错误

    - `p = "dddddd";` 正确 可以修改指针的值

- 两种访问方式`->` 和 `.`

  - 通过**指针访问**成员变量的正确方法 `->`

  - 结构体变量和类对象访问用`.`

  - `(*a).b` 相当于 `a->b`

- `按值传递`

  - 值传递的方式无法实现交换，因为传参时对于参数 left 和 right 拷贝一临时副本， 交换的是副本值，因为其是临时变量，函数退出，变量销毁，并不会影响外部 left 和 right 的值。

  - 传递给函数的值被称为实参;用于接收传递值的变量称为形参

  - 意味着函数定义中的形参是新的变量，他被初始化为函数调用所提供的值.

  - C++将数组名参数视为数组地一个元素的地址,因为指针是原始地址的拷贝。

- `引用传递`

  - 引用传递和指针传递 `void doSomething(char*dest, const char* src);`

  - 用 const 修饰可防止变量在函数 doSomething 内被修改.

  - 使用引用的话，不做临时拷贝，&的使用说明此处只是传入的原参数的另一个名字而已，所以修改时直接在原参数的基础上修改变量值。

- `指针传递`

  传入的是地址，因为地址是唯一的，所以指针通过地址的访问进而可修改其内容。

- 指针与内存

  - c++创建指针时，计算机分配用来存储地址的内存，但不分配用来存储指针所指向的数据所需的内存

  - 指针没有初始化(之前它可能是任何值)为一个确定的适当的地址就使用的话，很可能存在一些隐患

  - 为一个数据对象(可以是结构或基本类型)分配内存的通用格式如下:

    - `typeName \* pointer_name = new typeName;` 指定需要什么样的内存和用来声明合适的指针
    - `typeName \* pointer_name = new typeName [num_elements];` 为数组分配内存

- 结构体与指针

  - 访问成员变量时，如果结构标识符是结构名，则使用点运算符;

  - 如果标识符是指向结构体的指针，则使用箭头运算符 `(ps->price); (\*ps).price` 也可以

- 引用

  ```cpp
  int rats;
  int& rodents = rats; // 引用就是目标的一个别名
  // int&指的是指向 int 的引用,rat 和 rodents 可以互换,他们指向相同的值和内存单元
  // &号和指针中的含义不一样. int \* const pr = &rats; //const 指针
  // 引用接近 const 指针,必须在创建时进行初始化，要一直跟着那个变量
  ```

- `int *p=new int(12)与 int *p=new int[12]` 的区别

  前者表示创建一个指针变量，其指向一个存储数字 12 的地址，后者表示创建一个长度为 12 的数组。

- **数组名的作用以及数组名前面添加取地址符的作用**

  - 数组名是数组首地址，是一个常量，不可以当作指针变量用，如：若 str 为数组名，str++就不合法，相当于常量自增。

    再次注意：数组名是常量！常量！常量！常量就不可被赋值，若有 `char s[10];char \*pt`，则如下：

  - `s="hello"；` //将常量赋给 s，实质就是将常量首地址赋值给 s；

  - `s=pt;` 都是错误的，s 是数组名不可被赋值，任何形式的赋值都不可以。

  - 同时，一维数组名当被直接使用时，是一个指向数组首地址的指针。 -还有，数组名表示首地址，那么数组名前有取地址符是什么意思？例如：数组 a[]，a 表示数组首元素地址，&a 表示数组整体地址，&a+1 就是该数组末尾后一个地址。

- 指针变量所占内存大小和指针加减有关的问题

  - 指针相减的值：只有同类型的指针才可以相减，且“相减结果/单个变量类型内存大小”才是最终结果；

  - 如 `int *p=a[0]，int *q=a[2]，那么 q-p=(q-p)/sizeof(int)=8/4=2` 是编译器默认的结果。

  - 指针变量自增自减

    自增自减中指针变量值的改变大小等于所指向的对象类型的内存大小。如：`char* pt1` 那么 `pt1++` 就是加 1，若为 `int* pt2`，那么 pt2++就是增加 4。指针运算问题都是以相应变量的类型大小作为基本单位的，例如 `int p[4]={0,0,0,0}，p+1` 就是指 p 的地址基础上偏移 4 字节。

## `printf`输出字符串指针

- 定义一个字符串指针, 并输出

  ```cpp
  char* p_buff = "huangjinjie";
  printf("%s", p_buff);
  ```

- 可不可以去掉 `"%s"`

  字符串是可以的, 如果 printf 一个非字符串不加字符格式是不行的

  ```cpp
  // 可以打印, 传入了一个地址 char* , 所以可以不需要`%s`
  printf("hello world");
  // "hell world"`是一个字符串常量, 和 printf(p_buff) 一样
  ```

## 数组指针、指针数组、函数指针

- 数组指针

  定义 `int (*p)[n]；`其中( )优先级高，首先说明 p 是一个指针，指向一个整型的一维数组（或二维数组的某一行）

- 指针数组

  定义 `int *p[n]；`其中[]优先级高，先与 p 结合成为一个数组，再由 int\*说明这是一个整型指针数组，它有 n 个指针类型的数组元素。

- 函数指针

  定义 `int (*pf)(int *)`为一个返回值为 int，参数为 int\*的函数指针

## 函数指针

> 回调函数

- 可以将函数 B 或函数 C 的地址作为函数 A 的参数. 这样的话通用部分的代码可以通过 A 实现, 然后特别部分通过函数指针传入

- 函数名就是函数的地址

  ```cpp
  process(func_think);    //传递函数的地址
  process(func_think());  //传递函数的返回值
  ```

- 声明函数指针(指定函数的返回类型以及函数的参数列表):

  ```cpp
  // 就是用 (*pf) 把原函数名替换就行了
  // pf 就是这个函数的指针,使用 (*pf) 把他当作函数名就可以了
  // 函数指针类型声明
  double (*pf)(int);

  // 符合函数指针声明的函数
  double pam(int);


  // lpFunc 表示所有入参为 const char* 返回值类型为 void* 的函数指针类型
  typedef void*(*lpFunc)(const char*);

  // 1. 作为变量类型
  lpFunc pTestFunc = dlsym("ldTest.so", "TestFunc");

  // 2. 作为函数参数
  void CallFunc(lpFunc pFunc, char*s)
  {
      pFunc(s);
  }
  ```

## 数组和指针的区别

> - 字符数组 `char sza[4] = "abc";`
> - 指针 `char *pszb = "abc";`
> - `++` 操作、取地址操作、 赋值操作、字符常量是否可修改

- `++ 操作`

  - 数组

    数组名是常量，常量不可以进行 `++` 操作

  - 指针

    指针++ 表示移动到下一个指针地址（即地址+sizeof(int\*)）

- `取地址操作`

  数组名表示首地址，那么数组名前取地址符什么意思

  - 数组

    ```c++
    int a[3] = {1, 3, 4};
    cout << &a << endl;      // 数组的地址(即第一个元素的地址)
    cout << &a + 1 << endl;  // 整个数组之后的一个地址，即元素4之后的地址
    ```

  - 指针

    ```c++
    int b = 4;
    int *p = &b;
    cout << &p << endl;     // 指针的地址
    cout << &p + 1 << endl; // 指针的下一个地址 + 1 * sizeof(int*)
    ```

- `sizeof`

  - 数组

    `sizeof(数组名)` = 数组所占内存大小,,如果是 char 数组，别忘了末尾有个\0

  - 指针

    `sizeof(指针)` = 指针大小(4 字节/8 字节)

- `赋值操作`

  - 数组

    数组名不可以被赋值

    ```c++
    char s[4];
    char* p = "abc";
    s = p; // 错误，不要以为数组名表示地址，p指针也是地址就可以赋值
    ```

  - 指针
    可以把新的地址赋值给指针

- `字符常量`

  【字符指针变量指向的字符常量中的内容是不能修改】

  - 数组

    数组 p 存放在栈上 ，内存分配时，会把`常量字符【拷贝】到栈`，所以可修改

    ```c++
    char p[] = "abcdef";
    ```

  - 指针

    指针存放在栈上，`指向全局区的常量字符串`，所以不可修改

    ```c++
    char *p = "abcdef";
    ```

## 野指针

> 那些未初始化的指针

- [什么是野指针]( https://bbs.csdn.net/topics/392082718

- [避免野指针的产生](https://www.cnblogs.com/mrlsx/p/5419030.html)，指针初始化

```cpp
类指针和类对象
A * p_ptr; // 指向类A的对象。。。这是野指针,就是指针没有指向某块内存
A * p_ptr = new A();
```

- `产生`

  - `声明`

    指针的时候, 没有初始化为 NULL, 这样的话这个指针指向什么地方都是不确定的

  - `释放`

    - 动态申请的内存时, 只 delete 或 free 了, delete 只是表示程序释放

    - delete 释放空间，只是做个标志，表示 p 所在的内存空间可以被其他进程使用了

    - 没释放之前，使用权是当前进程的；而且还需把指针 p 赋为 NULL

- `危害`

  - 指向不可访问地址

  - 破坏正在使用的地址空间

- `防范`

  - 定义指针的时候就进行初始化

  - 释放的时候要把指针指向 NULL

# 智能指针

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/weixin_42423872/article/details/99064821)

从前面的内容可以看出 [auto_ptr](https://blog.csdn.net/weixin_42423872/article/details/99059529) 具有比较多的缺陷，使用时容易出错。在 C++ 11 标准中出现了新的智能指针 `unique_ptr、shared_ptr 与 weak_ptr` 等

## `unique_ptr`

- `特点`

  所有权唯一，禁止拷贝和权限转移

- `缺点`

  unique_ptr 是简单粗暴的防止拷贝，这种比较简单，效率高，但是功能不全面，不支持拷贝和赋值操作。无法共享数据，可自主实现数据共享，但在释放时会导致堆内存重复释放导致系统崩溃。

下面是 unique_ptr 的实现：

```c++
#include<iostream>
#include<memory>

template<typename T>
class Unique_Ptr
{
public:
    Unique_Ptr(T* ptr) : mptr(ptr) {}
    Unique_Ptr()
    {
        delete mptr;
        mptr = NULL;
    }

    T& operator*()
    {
        return *mptr;
    }

    T* operator->()
    {
        return mptr;
    }

private:
    // 将拷贝构造和赋值写在私有下
    Unique_Ptr(Unique_Ptr<T>&);
    Unique_Ptr<T>& operator=(Unique_Ptr<T>&);
    T* mptr;
};

int main()
{
    int* p = new int;
    Unique_Ptr<int> up1(p);
    Unique_Ptr<int> up2(p);
    Unique_Ptr<int> up3(p);
    return 0;
}
```

### 禁止赋值和复制

- unique_ptr 禁止赋值和复制，“唯一” 地拥有其所指对象，同一时刻只能有一个 unique_ptr 实例指向给定对象。也就是说模板类 unique_ptr 的 copy 构造函数以及等号（“=”）操作符是无法使用的。

- 通过禁止复制和赋值可以较好的改善 auto_ptr 的所有权转移问题。下面是其禁止复制和赋值的例子：

  ```c++
  #include <iostream>
  #include <memory>
  using namespace std;

  void Fun1( unique_ptr<int> up ) {}

  int main()
  {
      unique_ptr<int> up1 = unique_ptr<int>(new int(10));

      //不允许复制，所以以下三个均错误
      unique_ptr<int> up2 = up1;    // error
      unique_ptr<int> up3(up1);     // error
      Fun1(up1);                                    // error

      //不允许赋值('=')，所以下面错误
      unique_ptr<int> up4;
      up4 = up1;                                    // error

      return 0;
  }
  ```

### 针对 auto_ptr 缺陷的改善

- 管理数组指针

  因为 unique_ptr 有 unique_ptr<X[] > 重载版本，销毁动态对象时调用 delete[]，所以可以用 unique_ptr 来管理数组指针。

  ```c++
  unique_ptr< Test[ ] > uptr1(new Test[3]);

  // 注意 unique_ptr<Test> uptr3(new Test[3]);是不对的
  unique_ptr<int[]> uptr2(new int[5]);
  ```

- 做容器 (vector, list, map) 元素

  ```c++
  vector<unique_ptr<int> > vec;
  unique_ptr<int> ptr1(new int(3));
  vec.push_back(std::move(ptr1));
  // vec.push_back(ptr1); //由于禁止复制这样不行
  ```

## `shared_ptr`

- `特点`

  shared_ptr 的实现原理是通过引用计数来实现，拷贝或赋值时将引用计数加 1，析构时只有当引用计数减到 0 才释放空间，否则只需将引用计数减 1 即可. shared_ptr 共享所有权。

- `缺点`

  相互引用   内存泄漏

如图理解引用计数和 shared_ptr 的关系：

![alt](https://img-blog.csdnimg.cn/20190811184259549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyMzg3Mg==,size_16,color_FFFFFF,t_70)

```c++
#include<memory>

class Ref_Man     //引用计数
{
public:
    static Ref_Man* getInstance()
    {
        if (prm == NULL)
        {
            prm = new Ref_Man();
        }
        return prm;
    }

    int getRef(void* ptr)
    {
        if (ptr == NULL)
        {
            return -1;
        }
        int index = find(ptr);
        if (index != -1)
        {
            return ref_count[index].count;
        }
        return -1;
    }

    void addRef(void* ptr)
    {
        if (ptr == NULL)
        {
            return;
        }
        int index = find(ptr);
        if (index != -1)
        {
            ref_count[index].count++;
        }
        else
        {
            ref_count[cursize].addr = ptr;
            ref_count[cursize++].count = 1;
        }
    }

    void delRef(void* ptr)
    {
        if (ptr == NULL)
        {
            return;
        }
        int index = find(ptr);
        if (index != -1)
        {
            if (getRef(ptr) != 0)
            {
                --ref_count[index].count;
            }
        }
    }

private:
    Ref_Man()
    {
        cursize = 0;
    }

    Ref_Man(const Ref_Man&);

    int find(void* ptr)
    {
        int index = -1;
        for (int i = 0; i < cursize; i++)
        {
            if (ref_count[i].addr == ptr)
            {
                index = i;
                break;
            }
        }
        return index;
    }

    typedef struct Ref
    {
        void* addr;        //堆内存地址
        int count;         //堆内存所对应的指针数目
    }Ref;
    Ref ref_count[10];
    int cursize;
    static Ref_Man* prm;
};
Ref_Man* Ref_Man::prm = NULL;

template<typename T>
class Shared_Ptr
{
public:
    Shared_Ptr(T* ptr = NULL)         //构造
        :mptr(ptr)
    {
        prm->addRef(mptr);
    }
    Shared_Ptr(Shared_Ptr<T>& rhs)        //拷贝构造
    {
        mptr = rhs.mptr;
        prm->addRef(mptr);
    }
    Shared_Ptr<T>& operator=(Shared_Ptr<T>&rhs)     //赋值
    {
        if (this != &rhs)
        {
            prm->delRef(mptr);
            if (prm->getRef(mptr))
            {
                delete mptr;
            }
            mptr = rhs.mptr;
            prm->addRef(mptr);
        }
        return *this;
    }
    ~Shared_Ptr()
    {
        prm->delRef(mptr);    //--引用计数
        if (prm->getRef(mptr) == 0)     //获取mptr引用计数，如果为0释放
        {
            delete mptr;
        }
        mptr = NULL;
    }
    T& operator*()        //重载*
    {
        return *mptr;
    }
    T* operator->()        //重载->
    {
        return mptr;
    }
private:
    T* mptr;
    static Ref_Man* prm;
};
template<typename T>
Ref_Man* Shared_Ptr<T>::prm = Ref_Man::getInstance();

class B;
class A
{
public:
    A()
    {
        std::cout << "A::A()" << std::endl;
    }
    ~A()
    {
        std::cout << "A::~A()" << std::endl;
    }
public:
    std::weak_ptr<B> spa;
};
class B
{
public:
    B()
    {
        std::cout << "B::B()" << std::endl;
    }
    ~B()
    {
        std::cout << "B::~B()" << std::endl;
    }
public:
    std::weak_ptr<A> spb;
};

int main()
{
    std::shared_ptr<A> pa(new A());
    std::shared_ptr<B> pb(new B());
    pa->spa = pb;     //相互引用
    pb->spb = pa;
    return 0;
}

int main()
{
    int* p = new int;                     //使用weak_ptr后解决了相互引用导致内存泄漏的问题
    Shared_Ptr<int> sp1(p);
    Shared_Ptr<double> spd = new double;
    Shared_Ptr<int> sp2(p);
    Shared_Ptr<int> sp3(p);
    return 0;
}
```

### shared_ptr 相互引用问题

![alt](https://img-blog.csdnimg.cn/20190811211303762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyMzg3Mg==,size_16,color_FFFFFF,t_70)

- pa 和 pb 两个智能指针对象分别指向 spa 和 spb，引用计数变成 1.

- pa 的 spa 指向 pb，pb 的 spb 指向 pa，引用计数变成 2。

- pa 和 pb 析构，引用计数减到 1，但是 spa 还指向 spb。但是 spb 还指向 spa。

- 也就是说 spa 析构了，pb 就释放了。

- 也就是说 spb 析构了，pa 就释放了。

- 但是 spa 属于 pa 的成员，pa 释放了，spa 才会析构，而 pa 由 spb 管理，spb 属于 pb 成员，所以这就叫循环引用，谁也不会释放。

- weak_ptr 的出现，很好的解决了这个问题

## `weak_ptr`

- `特点`

  weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它没有重载 operator \* 和 ->，故而不具有普通指针的行为。它的最大作用在于协助 shared_ptr 工作。

- weak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造，获得资源的观测权。但 weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加。

- `作用`

  解决强智能指针 **shared_ptr** 相互引用的问题。

代码如下：

```c++
​template<typename T>
Ref_Man* Shared_Ptr<T>::prm = Ref_Man::getInstance();

class B;
class A
{
public:
    A()
    {
        std::cout << "A::A()" << std::endl;
    }
    ~A()
    {
        std::cout << "A::~A()" << std::endl;
    }
public:
    std::weak_ptr<B> spa;
};

class B
{
public:
    B()
    {
        std::cout << "B::B()" << std::endl;
    }
    ~B()
    {
        std::cout << "B::~B()" << std::endl;
    }
public:
    std::weak_ptr<A> spb;
};

int main()
{
    std::shared_ptr<A> pa(new A());
    std::shared_ptr<B> pb(new B());
    pa->spa = pb;
    pb->spb = pa;
    return 0;
}


int main()
{
    int* p = new int;
    Shared_Ptr<int> sp1(p);
    Shared_Ptr<double> spd = new double;
    Shared_Ptr<int> sp2(p);
    Shared_Ptr<int> sp3(p);
    return 0;
}
```

因为在执行`pa->spa = pb;pb->spb = pa;`时 weak_ptr 的 spa 和 spb 不会增加 pa 和 pb 的引用计数，这样就保证了正常的释放。

友情链接：

[C++ 智能指针梳理](https://blog.csdn.net/shuishanga/article/details/52982102)

[C++：RAII 思想和智能指针（auto_ptr，unique_ptr，shared_ptr）](https://blog.csdn.net/ETalien_/article/details/88880324)详解了引用计数部分，并且提供了线程安全的 shared_ptr，很值得学习哦~
