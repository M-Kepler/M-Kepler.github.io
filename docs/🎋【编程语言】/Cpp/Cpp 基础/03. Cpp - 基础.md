- [语言基础](#语言基础)
  - [编译链接](#编译链接)
    - [编译过程](#编译过程)
    - [`make`](#make)
    - [`coredump`调试](#coredump调试)
  - [启动流程](#启动流程)
    - [`main` 函数和启动例程](#main-函数和启动例程)
    - [`main` 函数结束后就结束了吗](#main-函数结束后就结束了吗)
    - [`main` 函数不能被调用， 为什么还需要返回值](#main-函数不能被调用-为什么还需要返回值)
  - [`printf`](#printf)
    - [size_t、ptrdiff_t、socklen_t、uint32_t_chen_cdc](#size_tptrdiff_tsocklen_tuint32_t_chen_cdc)
    - [`printf` 函数参数](#printf-函数参数)
    - [`printf` 是怎么可以输出多个和不同类型的数据的](#printf-是怎么可以输出多个和不同类型的数据的)
    - [`printf` 为什么没有格式化字符串没有也能输出字符串](#printf-为什么没有格式化字符串没有也能输出字符串)
    - [`printf` 格式化字符串漏洞](#printf-格式化字符串漏洞)
    - [`printf` 是怎么可以输出多个和不同类型的数据的](#printf-是怎么可以输出多个和不同类型的数据的-1)
    - [为什么没有格式化字符串没有也能输出字符串](#为什么没有格式化字符串没有也能输出字符串)
    - [格式化字符串漏洞](#格式化字符串漏洞)
    - [`printf` 函数参数](#printf-函数参数-1)
  - [`main` 函数和启动例程](#main-函数和启动例程-1)
  - [`main` 函数不能被调用， 为什么还需要返回值](#main-函数不能被调用-为什么还需要返回值-1)
  - [如何获取`main`函数的返回值](#如何获取main函数的返回值)
  - [`main` 函数结束后就结束了吗](#main-函数结束后就结束了吗-1)
  - [函数调用过程](#函数调用过程)
  - [为什么要链接 `xx.so.1` 而不是直接链 `xx.so`](#为什么要链接-xxso1-而不是直接链-xxso)
  - [`__stdcall` 和 `__cdecl` 的区别](#__stdcall-和-__cdecl-的区别)
  - [函数符号生成规则](#函数符号生成规则)
  - [位操作](#位操作)
  - [两个一样的函数，一个带 const，一个不带，会有问题吗](#两个一样的函数一个带-const一个不带会有问题吗)
  - [什么技术可以代替宏定义 `#define`](#什么技术可以代替宏定义-define)
  - [`do{...}while(0)` 用过吗](#dowhile0-用过吗)
  - [`operator char()` 什么意思](#operator-char-什么意思)
  - [柔性数组](#柔性数组)
  - [可变参数](#可变参数)

# 语言基础

## 编译链接

### 编译过程

- `预处理`

  ```sh
  # 条件编译、头文件引入、注释删除、宏替换等
  gcc -E test.c -o test.i
  ```

- `编译`

  ```sh
  # 把源代码装换为汇编代码,在此过程加入调试选项 -g
  gcc -S test.i -o test.s
  ```

- `汇编`

  ```sh
  # 把汇编代码转换为机器可识别的二进制指令
  gcc -c test.s -o test.o
  ```

- `链接`

  ```sh
  # 链接器将多个源文件生成的 .o文件 捆绑在一起
  # 同时链接到程序所需要的函数的函数库，生成一个单一完整的可执行程序
  gcc test.o -o test
  ```

### `make`

- `make` 传递参数给 `makefile`

  - `makefile`：

    ```cpp
    CFLAGS=CFLAG // CFLAG相当于一个变量
    CFLAGS+=-g -Wall
    object=myprog
    all:$object
    myprog:a.c
      gcc ${CFLAGS} a.c -o ${object}
    ```

  - `make` 传递参数

    ```sh
    make CFLAG=-DDEBUG
    ```

  - make 默认寻找 makefile，也可以自己指定文件 `make -f file`

- `makefile` 传递参数到代码： `-D DEBUG`

### `coredump`调试

> 调试方法：`gdb -c core.pid program_name`

- 不用编译器，如何确定代码的错误位置，除了打日志，抛异常。
  不用编译器就是不用 assert，不用打印日志就是不用 printf，只能使用 core dump，通过 gdb 去调试，定位堆栈信息

- `coredump` 怎么打印堆栈信息

  - `gdb`命令`where 或 bt` 可查看当前 sp 指针所在的堆栈帧

- 一般生产环境上放的都是 `release` 版本，如果真的出现 `coredump` 了，需要用 `debug` 版本去调试 `gdb /path/to/exe_file -c /path/to/core_file`，因为 `release` 版本是没有符号表的

## 启动流程

### `main` 函数和启动例程

> [深度剖析 c 语言 main 函数 --- main 函数的执行顺序](https://blog.csdn.net/z_ryan/article/details/80985101)

- `main` 函数启动前，系统主要做了初始化的工作

  - `初始化静态和全局变量` + 运行`全局对象的构造函数`

  - `将未初始化部分的赋初值`

    数值型 short,int,long 等为 0,bool 为 false,指针为 NULL,等等

  - `传递参数给main函数`

    argc,argv 等传递给 main 函数，然后才真正运行 main 函数

- `main` 函数是怎么启动的
  - `main` 函数之前有启动例程 `_start`
    这个函数是 Linux 系统库的一部分，当我们的程序和 Glibc 库链接在一起形成最终的可执行文件的之后这个函数就是程序执行初始化的入口函数。
  - 编译器缺省是找 `__start` 符号, 而不是 `main`
  - `__start` 这个符号是程序的起始
  - `main` 是被标准库 `stdlib` 调用的一个符号

### `main` 函数结束后就结束了吗

- `exit(0)（相当与执行return 0;）`先是执行`atexit`注册的函数（用法和信号处理 signal 一样），然后再执行 `_exit` 函数， `_exit` 会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数

- `全局对象的析构函数`会在 main 函数之后执行；

- 获取当前执行文件路径 `argv[0]`

### `main` 函数不能被调用， 为什么还需要返回值

> 告诉内核程序的退出状态

- `return n; 其实相当于 exit(n);`
  - 当一个进程执行完毕时，该进程会调用一个名为 `atexit` 的例程来`通知内核它已经做好"消亡"的准备了`;
  - 该进程会提供一个退出码（一个整数）表明它准备退出的原因

## `printf`

### size_t、ptrdiff_t、socklen_t、uint32_t_chen_cdc

[size_t、ptrdiff_t、socklen_t、uint32_t_chen_cdc](https://blog.csdn.net/m0_38069262/article/details/99242115)

```c
size_t :
//无符号整型（unsigned int (32位机下)，在64位机下size_t为unsigned long int),size_t一般用来计数，
//它和socklen_t一样是为了增强程序的可移植性

typedef unsigned int            uint32_t;
typedef unsigned long int       uint64_t;

格式化输出：

uint16_t %hu
uint32_t %u
uint64_t %lu  //无符号长整型（unsigned long int）
uint64_t %llu  (unsigned long long int)

socklen_t:
//socklen_t必须要和当前机器的int类型具有一致的字节长度，可以看做int
//根据下面的图，不管是32/64位系统，socklen_t都是4字节
```

### `printf` 函数参数

[你可能不知道的 `printf`](https://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&mid=2649284608&idx=2&sn=3449445af2ff6db0525c78cd08a48b4e&chksm=f2f99367c58e1a719036932aac6d16c9b525060bb4662e05abec6b5961ed2253d463337080db&mpshare=1&scene=1&srcid=#%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0%E7%9A%84)

- 可变参数中的类型提升

  调用者会对每个参数执行`默认实际参数提升`，比如`%d`会从堆栈中取 4 字节，如下

  ```c++
  float将提升到double (8字节)
  char、short和其相应的signed、unsigned类型将提升到int (4字节)
  ```

- 参数入栈顺序以及计算顺序

  见 `__stdcall、__cdecl、__fastcall`

- 格式控制符是如何处理参数的

  - 根据控制字符`从堆栈中取其对应大小`
    例如，%f 期望一个 double（8 字节）类型，但是传入的参数是 int（4 字节），那么在处理这个 int 参数值会按照 double 处理，则多处理 4 个字节，会造成处理数据错误。

  - `printf("%d%d",i)`会发生什么，为什么

    ```c++
    输出 i 的值以及一个不确定的数
    会造成获取一个错误的参数，`输出数据是不确定的`
    ```

- 可变域宽和精度

  ```c++
  scanf("%3d", &i);
  // i【最多接收宽度】3位整数，如果输入多余3位后面多余部分会被舍弃, 少于3位则直接赋给i

  scanf("%3d%4d", &i, &j);
  // 如果输入1234567890，则 i=123 j=4567,剩余部分被舍弃

  printf("%07d", i);
  // 表示【最少输出宽度】为7，0表示不足7位则在前面补0, 如果没有0则以空格填补

  printf("%*d", 5, i);
  // %*d, 表示可变域宽，宽度又右面的入参控制，这里是 5
  ```

### `printf` 是怎么可以输出多个和不同类型的数据的

- `printf` 是 C 语言函数，哪来的重载，是通过变长参数来实现的

### `printf` 为什么没有格式化字符串没有也能输出字符串

- 因为 `printf(const char* formate, ...)` 使用变长参数实现的，参数列表第一个参数就是 `const char*`，所以可以直接输出字符串

  ```c++
  char* a = "huangjinjie";
  printf("%s", a);
  printf(a); // 相当于变长参数为0，只给formate入参
  ```

### `printf` 格式化字符串漏洞

> [格式化字符串漏洞简介](https://wooyun.js.org/drops/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B.html)

- 现象

  ```c++
  char * p = "huangjinjie";
  printf("%s", p); // 正常情况
  printf(p);       // 这样也可以输出
  ```

- 格式化字符串漏洞

  - 原理
    一般的函数都是固定参数个数和类型的，所以调用的时候知道从内存中读取出多少字节
    但是变长参数则是`依赖用户把参数个数和类型输进来`以保证灵活性，但如果编程者`**不加格式化字符**，就会产生后面任意地址读写的漏洞`
  - 实践
    `%n` 功能是将%n 之前 printf 已经打印的字符个数赋值给传入的指针。通过%n 我们就可以修改内存中的值了

    ```cpp
    char a;
    printf("zzzzzzz%n\n", &a);
    printf("%d\n", a); // a变为7了(刚好是z的个数)

    char b[100];
    printf(b);
    // 如果输入的b是 %010x%010x%010x%01970x%n 就可以访问后面的内存了
    ```

  - 危害
    可以通过 `%n` 来达到访问程序的任意地址，**`甚至直接访问和修改内存`**

### `printf` 是怎么可以输出多个和不同类型的数据的

- `printf` 是 C 语言函数，哪来的重载，是通过变长参数来实现的

### 为什么没有格式化字符串没有也能输出字符串

- 因为 `printf(const char* formate, ...)` 使用变长参数实现的，参数列表第一个参数就是 `const char*`，所以可以直接输出字符串

  ```c++
  char* a = "huangjinjie";
  printf("%s", a);
  printf(a); // 相当于变长参数为0，只给formate入参
  ```

### 格式化字符串漏洞

> [格式化字符串漏洞简介](https://wooyun.js.org/drops/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B.html)

- 现象

  ```c++
  char * p = "huangjinjie";
  printf("%s", p); // 正常情况
  printf(p);       // 这样也可以输出
  ```

- 格式化字符串漏洞

  - 原理
    一般的函数都是固定参数个数和类型的，所以调用的时候知道从内存中读取出多少字节
    但是变长参数则是`依赖用户把参数个数和类型输进来`以保证灵活性，但如果编程者`**不加格式化字符**，就会产生后面任意地址读写的漏洞`
  - 实践
    `%n` 功能是将%n 之前 printf 已经打印的字符个数赋值给传入的指针。通过%n 我们就可以修改内存中的值了

    ```cpp
    char a;
    printf("zzzzzzz%n\n", &a);
    printf("%d\n", a); // a变为7了(刚好是z的个数)

    char b[100];
    printf(b);
    // 如果输入的b是 %010x%010x%010x%01970x%n 就可以访问后面的内存了
    ```

  - 危害
    可以通过 `%n` 来达到访问程序的任意地址，**`甚至直接访问和修改内存`**

### `printf` 函数参数

[你可能不知道的 `printf`](https://mp.weixin.qq.com/s?__biz=MzI2OTA3NTk3Ng==&mid=2649284608&idx=2&sn=3449445af2ff6db0525c78cd08a48b4e&chksm=f2f99367c58e1a719036932aac6d16c9b525060bb4662e05abec6b5961ed2253d463337080db&mpshare=1&scene=1&srcid=#%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%8F%82%E6%95%B0%E7%9A%84)

- 可变参数中的类型提升

  调用者会对每个参数执行`默认实际参数提升`，比如`%d`会从堆栈中取 4 字节，如下

  ```c++
  float将提升到double (8字节)
  char、short和其相应的signed、unsigned类型将提升到int (4字节)
  ```

- 参数入栈顺序以及计算顺序

  见 `__stdcall、__cdecl、__fastcall`

- 格式控制符是如何处理参数的

  - 根据控制字符`从堆栈中取其对应大小`

    例如，%f 期望一个 double（8 字节）类型，但是传入的参数是 int（4 字节），那么在处理这个 int 参数值会按照 double 处理，则多处理 4 个字节，会造成处理数据错误。

  - `printf("%d%d",i)`会发生什么，为什么?

    ```c++
    输出 i 的值以及一个不确定的数
    会造成获取一个错误的参数，`输出数据是不确定的`
    ```

- 可变域宽和精度

  ```c++
  scanf("%3d", &i);
  // i【最多接收宽度】3位整数，如果输入多余3位后面多余部分会被舍弃, 少于3位则直接赋给i

  scanf("%3d%4d", &i, &j);
  // 如果输入1234567890，则 i=123 j=4567,剩余部分被舍弃

  printf("%07d", i);
  // 表示【最少输出宽度】为7，0表示不足7位则在前面补0, 如果没有0则以空格填补

  printf("%*d", 5, i);
  // %*d, 表示可变域宽，宽度又右面的入参控制，这里是 5
  ```

## `main` 函数和启动例程

> [深度剖析 c 语言 main 函数 --- main 函数的执行顺序](https://blog.csdn.net/z_ryan/article/details/80985101)

- `main` 函数启动前，系统主要做了初始化的工作

  - `初始化静态和全局变量` + 运行`全局对象的构造函数`

  - `将未初始化部分的赋初值`

    数值型 short,int,long 等为 0,bool 为 false,指针为 NULL,等等

  - `传递参数给main函数`

    argc,argv 等传递给 main 函数，然后才真正运行 main 函数

- `main` 函数是怎么启动的

  - `main` 函数之前有启动例程 `_start`

    这个函数是 Linux 系统库的一部分，当我们的程序和 Glibc 库链接在一起形成最终的可执行文件的之后这个函数就是程序执行初始化的入口函数。

  - 编译器缺省是找 `__start` 符号, 而不是 `main`

  - `__start` 这个符号是程序的起始

  - `main` 是被标准库 `stdlib` 调用的一个符号

## `main` 函数不能被调用， 为什么还需要返回值

> 告诉内核程序的退出状态

- `return n; 其实相当于 exit(n);`

  - 当一个进程执行完毕时，该进程会调用一个名为 `atexit` 的例程来`通知内核它已经做好"消亡"的准备了`;

  - 该进程会提供一个退出码（一个整数）表明它准备退出的原因

## 如何获取`main`函数的返回值

- Linux 终端可以通过 `echo $?` 查看退出码

- 在`atexit`中注册的函数中获取

  ```cpp
  int code; // 全局变量
  void my_exit(){ cout << code << endl; }
  int main()
  {
    atexit(my_exit);
    ...
    return code=0;
  }
  ```

- 在另一个程序中使用`system`来获取

  ```c++
  cout << system("/path/to/exe_file") << endl;
  // 如果可执行文件退出码为 n，则system函数输出为 n * 256
  // 因为exe_file返回值是 system 返回值的8～15位。
  ```

## `main` 函数结束后就结束了吗

- `exit(0)（相当与执行return 0;）`先是执行`atexit`注册的函数（用法和信号处理 signal 一样），然后再执行 \_exit 函数， \_exit `会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数`

- `全局对象的析构函数`会在 main 函数之后执行；

- 获取当前执行文件路径 `argv[0]`

## 函数调用过程

- 从栈空间`分配存储空间`

- 从实参的存储空间`复制实参到形参栈空间`

- 进行运算

  `形参`在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

  - `传值`
    传值，实际是把实参的值`拷贝`给形参。那么对形参的修改，不会影响实参的值 。

  - `传址`

    实际是传值的一种特殊方式，只是他传递的是地址，不是普通的赋值，那么`传地址以后实参和行参都指向同一个对象`，因此对形参的修改会影响到实参。

  - `传引用`

    引用是变量的一个别名，它不会另外分配空间，所以最终修改的还是原来的变量

  - `数组`作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

- 函数中如果有 return 返回变量时，其实所返回的也是一个拷贝。所以当使用 return 返回对象时一定要考虑所返回对象的拷贝构造函数是否能够满足要求。

## 为什么要链接 `xx.so.1` 而不是直接链 `xx.so`

[linux 动态库为啥要链接.so.1](https://bbs.csdn.net/topics/390633041)

`A --> xx.so.1 -- xx.so` 更新 `xx` 库的时候，不用重新编译 `A`

## `__stdcall` 和 `__cdecl` 的区别

- `__stdcall`c++标准调用方式，由被调用函数清理

- `__cdecl` c 和 c++默认调用方式，堆栈由函数清理

- [`__stdcall、__cdecl和__fastcall` 调用约定](https://blog.csdn.net/luoweifu/article/details/52425733)

- [`__cdecl,__stdcall,__fastcall,__pascal,thiscall` 的区别](https://www.cnblogs.com/john-h/p/6276828.html)

- 清理堆栈是什么意思

  `__cdecl`是默认的调用方式，每一个调用它的`函数都包含清空堆栈的代码`，所以产生的可执行文件大小会比调用`_stdcall`函数的大。

- 调用约定决定以下内容

  - 函数参数的`压栈顺序`

  - 由调用者还是被调用者把参数`弹出栈`

  - 以及产生`函数修饰名`的方法

- 如下表

  | 要点             | `__cdecl`                 | `__stdcall`             |
  | :--------------- | :------------------------ | :---------------------- |
  | **压栈顺序**     | 右->左                    | 右->左                  |
  | **清理栈方**     | 调用者清理                | 被调用函数清理          |
  | 适用场合         | C/C++、MFC 的【默认方式】 | Win API                 |
  | **产生的修饰名** | `_funcname`               | `_funcname@arg_bit_num` |

## 函数符号生成规则

> [C/C++函数符号生成规则](https://blog.csdn.net/Scl_Diligent/article/details/83990429)

- `_funcname@arg_bit_name` 表示函数名+@+参数字节数

  ```cpp
  sum(int x,int y) // 对应 _sum@8
  ```

## 位操作

- `& 与`（1&&0=0），如：1010 & 1100 = 1000

- `| 或`（1||0=1），如：1010 & 1100 = 1110

- `~ 非`，如：a = 1010; ~a = 0101

- `^ 异或`（同则为 0），如：1010 ^ 1100 = 0110

- `<< 左移`，如：1110 << 1 = 1100

- `>> 右移`，如：1000 >> 1 = 0100

- 把一个整型的二进制后三位清零: `n &=~7;`

## 两个一样的函数，一个带 const，一个不带，会有问题吗

> 不会，函数间是 **`重载`** 的，分别提供给 const 对象和非 const 对象进行调用的

- [C++中，经常有同名成员函数，一个 const 形式一个非 const 形式的解读](https://blog.csdn.net/ly131420/article/details/51823551)

- [C++中 const 成员函数和非 const 成员函数的重载](https://blog.csdn.net/bzhxuexi/article/details/43408015)

- 设计两个成员函数，`主要是提供给非const对象和const对象进行调用的`，只设计任何一个都无法满足全部需求。只用 A 类的 const 对象才能调用 const 版本的 function 函数，而`虽然const对象可以调用任意一种`，通常非 const 对象调用不是 const 版本的 function 函数。

- 这两个函数的定义和实现都是完全一样的，差异的地方就是一个函数名后面会跟一个 const，嫌写两边臃肿，可以用`const_cast<T>()`来转换，如果成员函数需要返回引用类型，那么设计两个相同的成员函数，一个 const 一个非 const 才是合理的

  ```c++
  class CTextBlock
  {
  public:
    // 这个版本给const对象调用，返回值加const是因为const对象是不可更改的，如果返回值是引用又不加const的话，很容易就会被更改，这就与const语义冲突了
    const char& operator[](std::size_t position) const
    {
       // ...
    }
    char& operator[](std::size_t position)
    {
      return const_cast<char&>(static_cast<const CTextBlock&>(*this)[position]);
    }
    void prepare()const;//一些准备动作
  };
  ```

## 什么技术可以代替宏定义 `#define`

> [宏在 C++中的替代解决方案](https://blog.csdn.net/github_33736971/article/details/52634191)

- const 实现常量

  ```c++
  #define N 10;     // c
  const int N = 10; // c++
  ```

- inline 内联替代宏函数

  ```c++
  #define MAX(x, y) (((x) > (y)) ? (x) : (y));   // c
  inline int max(int x, int y){ return x>y?x:y;} // c++
  ```

- typedef 替代类型定义

  ```c++
  #define DWORD unsigned int; // c
  typedef int DataType ;      // c++
  ```

- 条件编译

  ```c++
  // c语言形式
  #ifdef DDEBUG
  ...
  #else
  ...
  #endif
  // c++形式
  // 据说可以用模板 template来实现
  ```

- 防止头文件重复包含**C++暂时也只能这样做**

  ```c++
  #ifndef _TEST_H
  #define _TEST_H
  ...
  #endif
  ```

## `do{...}while(0)` 用过吗

[do{...}while(0)](https://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html)

- 避免使用 goto 语句

  ```cpp
  // 在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到错误则退出函数
  // 当然，退出前先释放资源，最大的问题就是代码的冗余
  // 而且我每增加一个操作，就需要做相应的错误处理，非常不灵活

  // 当然用 goto 可以解决冗余的问题，但是 goto 因为太过于灵活，一般不建议使用
  bool Execute()
  {
    // 分配资源
    int *p = new int;
    bool bOk(true);
    do
    {
      // 执行并进行错误处理
      bOk = func1();
      if(!bOk) break;
      bOk = func2();
      if(!bOk) break;
      bOk = func3();
      if(!bOk) break;
      // ..........
    }while(0);

    // 释放资源
    delete p;
    p = NULL;
    return bOk;
  }
  ```

- 在宏里使用，可以让宏可以放心使用分号分割的几个子句

  ```cpp
  #define SAFE_DELETE(p) do{ delete p; p = NULL;}while(0);
  // 这里带了分号，所以在某些调用这个宏的句子后面没有分号不会报错的
  ```

## `operator char()` 什么意思

[operator char() 什么意思](https://www.cnblogs.com/edwardlost/archive/2010/12/01/1887983.html)

`operator` 不仅仅用于`操作符重载`，还可用于`强制类型转换`， 即该类型可以自动转换为 char 类型。

```c++
class A
{
   ...
   operator int() {return static_cast<int>(date);}
}
...
cout << add(a1, a2) << std::endl; // a1, a2为A类对象
```

## 柔性数组

- 在结构体末尾声明`0长数组`

  对编译器来说，此时长度为 0 的数组并不占用空间，因为数组名本身不占空间，它`只是一个偏移量`

- 这个符号本身代表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ）; 但对于这个数组的大小，我们可以进行动态分配

  ```c++
  typedef struct FlexiableStruct
  {
      int a;
      char array[0]; //或char array[];
      // 定义0长数组,只是把一个符号放在结构体内, 不占用内存
  }stFlexiable, *pstFlexiable;
  char szStr[] = "huangjinjie";
  pstFlexiable p_stFlexiable = (pstFlexiable)malloc(sizeof(stFlexiable) + strlen(szStr) + 1); // 给柔性数组申请空间
  ```

- 动态申请的内存只是申请给数组拓展所用，结构体的大小在创建时已经确定了 array 明确来说不算是结构体成员，只是挂羊头卖狗肉而已

  这样的变长数组常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量

## 可变参数

三个宏 `va_start, va_arg 和 va_end`，一个类型`va_list`

- `va_list` 类型

  ```cpp
  va_list ap;
  定义 typedef char* va_list;
  只是一个指向char类型的指针。可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。
  ```

- `va_start` 宏

  ```cpp
  va_start(ap, paramN);
  初始化可变参数列表（把函数在 paramN **之后**的参数地址放到 ap 中）。
  ```

- `va_arg` 宏

  ```cpp
  va_arg(ap, arg_type);
  取类型为arg_type的下一个值
  # 但是对于参数类型不止一种的例子呢 vsprintf
  ```

- `va_end` 宏

  ```cpp
  va_end(ap);
  功能：关闭初始化列表（将 ap 置空）。
  ```
