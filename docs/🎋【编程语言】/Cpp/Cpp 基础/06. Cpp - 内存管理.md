- [内存管理](#内存管理)
  - [堆栈](#堆栈)
  - [sizeof](#sizeof)
    - [strlen / sizeof](#strlen--sizeof)
  - [内存模型和名字空间](#内存模型和名字空间)
    - [函数和链接性](#函数和链接性)
    - [存储方案和动态分配](#存储方案和动态分配)
    - [名字空间](#名字空间)
  - [类和动态内存分配](#类和动态内存分配)
  - [内存分区](#内存分区)
    - [栈区（stack）](#栈区stack)
    - [堆区（heap）](#堆区heap)
    - [全局区（global）](#全局区global)
    - [代码区（code）](#代码区code)
    - [各种情况](#各种情况)
  - [自动存储、静态存储、动态存储](#自动存储静态存储动态存储)
  - [new/delete & malloc/free](#newdelete--mallocfree)
  - [全局变量和全局常量](#全局变量和全局常量)
- [其他](#其他)
- [参考资料](#参考资料)

# 内存管理

## 堆栈

- 栈空间的生长方向是从高到低的,即先入栈的在高地址

  ```cpp
  void* memcpy(void* dst, const void* src, size_t n);
  ```

- 两种发生内存重叠的情况:

- dst 地址比 src 高, 且发生重叠

  ```sh
  dst: [1][2][3][*][*]
  src:          [1][2][3][4][5]
  # 这种情况memcpy仍能保证拷贝正确, *部分原本是1、2, 拷贝后变为4,5
  ```

- dst 地址比 src 低, 且发生重叠

  ```sh
   dst:          [*][*][3][4][5]
   src: [1][2][3][4][5]
   # 这种情况memcpy不能保证拷贝正确, *部分本应是1、2, 拷贝后变为4,5
  ```

- [Linux 里设置环境变量的方法（export PATH）](http://www.cnblogs.com/leezx/p/5589941.html)

- [Linux 下包含头文件的路径问题与动态库链接路径问题](http://www.cnblogs.com/loversinJapan/p/5058303.html)

- [★★★★★ C/C++ 内存知识](http://blog.csdn.net/noricky/article/details/15026607)

## sizeof

- [C++ 中的类所占内存空间总结](http://blog.sina.com.cn/s/blog_69c189bf0100mkeu.html)

- [关于 sizeof 的笔试面试题详解](https://blog.csdn.net/Hello_Hwc/article/details/41170719)

- 计算元素个数

  ```cpp
  char arr[20];
  int iNum = sizeof(arr)/sizeof(arr[0]);
  ```

### strlen / sizeof

- strlen 函数，求字符串开始到结束符的长度（字符串以\0 结尾）；**运行时计算值**, 参数必须是 `char *` 类型(当数组名作为参数，实际数组是退化成指针了)

- [sizeof](https://blog.csdn.net/to_xidianhph_youth/article/details/39134833)
  sizeof 运算符，求类型所占大小；**编译时计算值**, 参数可以是数组、指针、类型、对象、函数等,相当于是一个特殊点的预处理器(注意到没有, 操作符都是在编译时就确定下来了, 比如 new)

  ```cpp
  32位C++中的基本数据类型，也就是
  char,short int(short), int, long int(long), float, double, long double
  大小分别为1,2,4,4,8,10
  ```

- 函数宏定义要记得给变量加括号

- [结构体在存储变量时地址要对齐](https://zhidao.baidu.com/question/518785645911926805.html)

## 内存模型和名字空间

- 作用域

  - 名称在文件的多大范围内可用

- 链接性：

  - 名称如何在不同单元间共享

- 堆栈空间各自被哪些代码使用(好像是公众号的文章里讲到过)

- [extern](http://m.blog.csdn.net/songjinshi/article/details/6785267)

  ```cpp
  //告诉编译器 func 这个函数按照 C 的规则来翻译。由于 cpp 加入了诸如重载等新特性，所以编译出来的变量命名相对于 C 要复杂点。
  extern "C" void func(int a, int b);

  //声明变量/函数的作用范围（可在本模块或其他模块中使用），而实际上并不分配空间，只是告诉编译器 g 已经在其他文件中定义了，让它不要报错，所以，extern 要严格对应声明时的格式
  extern int g;
  ```

- mutable

  为了突破 const 的限制而设置的。被 mutable 修饰的变量，将永远处于可变的状态. 即使在一个 const 函数中。

### 函数和链接性

> 就是编译的时候怎么找到所调用的函数的问题

- 内链接、外链接

  默认情况下全局变量的链接性为外部的，但 const 全局变量的链接性为内部的

  也就是说在 C++看来，全局 const 定义就行使用了 static 说明符一样。

  在定义静态变量/函数的文件中，静态变量/函数将覆盖外部定义(即使用自己定义的函数);

  内联函数不受这项规则限制

- 内部链接性(只能在一个文件内使用)`const、static`

  每个文件都有自己的一组变量，而不是所有文件共享一组变量，每个定义都是所属文件私有的，这就是能够将

  常量定义放在头文件中的原因，这样，只要在两个源代码文件中包含同一个头文件，则他们将获得统一组常量
  `const int fingers = 10;`

- 外部链接性(即可以在文件间共享)`static`

  出于某种原因，希望某个常量的链接性为外部，可以用`extern`挂你案子来覆盖默认的内部链接性

  `extern const int states = 50;`

- 语言链接性

  链接程序寻找与 C ++ 函数调用匹配的函数时，使用的方法和 C 语言不一样。

  所以在 C ++ 程序中使用 C 库中预编译的函数最好用 extern 告诉编译器使用 C 语言的链接性

### 存储方案和动态分配

- 三块独立内存，一块用于静态变量、一块用于自动变量、另外一块用于动态存储

- new 在堆(heap)中找一个足以满足要求的内存块<见:创建类对象的三种方法的不同>

### 名字空间

1. 可以是全局的，也可以位于另一个名字空间中，但不能位于代码块中, 默认情况下，

2. 在名称空间中生命的名称的链接性为外部的（除非它引用了常量）

3. [头文件和名字空间](https://blog.csdn.net/u012234115/article/details/40019945)

## 类和动态内存分配

- 静态类成员有个特点，无论创建多少对象，程序只创建一个静态类变量副本，也就是说，

  类的所有对象共享同一个静态成员

- 不能通过对象调用静态成员函数，静态成员函数不能使用 tihs 指针

- 不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并没有

  分配内存.对于静态类成员，可以在类设个你们那个之哇使用单独的语句来进行初始化，

  因为静态类成员是单独存储的，而不是对象的组成部分,初始化语句并没有使用关键字 static,

  但如果静态成员好似整形或枚举型 const,则可以在类生命中初始化

  ```cpp
  class A{ static int s_a; }

  int A:: s_a = 10;
  ```

- 静态成员函数不与特定的对象相关联，因此，只能使用静态数据成员,即：只可访问静态成员(无论 private 还是 public)

## 内存分区

### 栈区（stack）

操作系统管理空间分配和释放

- `char str[] = "asdf"`是把全局区中的`asdf\0`拷贝到数组`str`所在的栈的空间

  ```cpp
  char * testout()
  {
      char str[] = "abc"; // 1
      return str; // 程序运行完毕，str会被释放掉
  }
  int main()
  {
      char buf[128]={ 0 };
      strcpy(buf, testout());
      printf("%s\n", buf ); // 乱码、不确定
      /*
        testout函数运行完毕后,str的空间被回收了，里面保存内容不确定的，也有可能还是原来的内容
      */
  }

  ```

### 堆区（heap）

- `free`

  - [free 之后要记得指针置空](https://blog.csdn.net/bestone0213/article/details/41121527)

  - [C 语言中 free 掉一段空间后为什么还要使用 NULL](https://zhidao.baidu.com/question/577455633.html)

  - [free 之后将指针置为 NULL](https://www.cnblogs.com/chenyang920/p/6692332.html)

free 一个空指针`free(NULL)`, 程序实际是什么也不做

**程序员** 控制，放程序局部变，如 new/malloc 出来的变量等；程序运行完就会自动释放变量了

> https://zhidao.baidu.com/question/339553907.html

```cpp
char * testout()
{
    char *tmp=(char*)malloc(100); // 堆区申请空间
    if(tmp == NULL)
    {
        return NULL;
    }
    strcpy(tmp, "asdf");
    return tmp;
}

int main()
{
    char buf[128] = {0};
    char *p = NULL;
    p = testout();
    if(p!=NULL)
    {
        printf("p=%s\n",p);
        free(p);
        p = NULL;
        /*
          释放空间（只是做个标志位，表示p所在的空间 操作系统可以用了，
          没释放之前，使用权给了p；所以把p赋值为NULL。下面这样写是错的
          ,没把指针赋值为NULL, 指针仍指向那块内存
          if(p!=NULL)
          {
            free(p);
          }
        */
    }
    return 0;
}

```

### 全局区（global）

> 静态变量、文字常量、全局常量，由操作系统管理

- 函数中`char *p = "adsf"`实际上是把放在全局区的`asdf\0`的地址`0x0011`赋值给在栈区的 p。

  如果另一个函数中也有`char *q="asdf\0"`，实际上编译器也是把`asdf`的地址`0x0011`赋值给在栈区的 q。

### 代码区（code）

操作系统管理，放函数

### 各种情况

- 函数里的变量和 main 函数里的变量虽然类型和名称一样，但实际上是完全不同的，别被忽悠了

- 变量生命周期和作用域

  ```cpp
  int main()
  {
      int a; // 栈区分配空间
      func1(a); // a还没有被释放，a会传入
      func2(a);
      a=10;
      cout<<a<<endl;
      return 0;
  }
  /* 拿到地址就可以操作他内存了，所以想让变量不被销毁的话，可以放在堆区、全局区，然后返回地址 */
  int* test()
  {
      static int a=10; // 静态变量放在全局区
      return &a; // 函数运行结束，a没释放，返回了地址
  }
  ```

- int 在 64 位操作系统中占多少位

  - sizeof 指针类型在 32 位系统(x86)中，占 4 个字节

  - sizeof 指针类型在 64 位系统(x64)中，占 8 个字节

  - 和操作系统没有关系，和编译器有关

    [C 语言 32/64 位机 数据类型字长](http://blog.csdn.net/willtin/article/details/51073855)

- 在 32 位编译器中:

  ```cpp
  unsigned int = int = 32bit
  short int = 16bit
  ```

- 在 64 位编译器中:

  ```cpp
  unsigned int = int = 32bit
  short int = 32bit
  // 都是 32bits，64 位编译器上有一个（_int64)是 64bit
  ```

## 自动存储、静态存储、动态存储

- 函数内部: 自由存储

- 函数外部: 静态存储

- new/malloc：动态存储

- 线程存储:thread_local 其生命周期与所属的线程一样

- C++ 存储方案

  C++有三种，C++11 有四种，**这些方案的区别就在于数据保留在内存中的时间。**

- `自动存储持续性`

  函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量；

- `静态存储持续性`

  函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有 3 种存储持续性为静态的变量；

- `线程存储持续性（C++11）`

  当前，多核处理器很常见，这些 CPU 可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字 thread_local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程；

- `动态存储持续性`

  用 new 运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。

## new/delete & malloc/free

- [new 与 malloc 的区别，以及内存分配浅析](https://www.cnblogs.com/huhuuu/archive/2013/11/19/3432371.html)

- [经典面试题之 new 和 malloc 的区别](https://blog.csdn.net/nie19940803/article/details/76358673)

- [new 的自由存储区和 malloc 的堆区](https://www.cnblogs.com/QG-whz/p/5060894.html)

- [new 等于 malloc 加构造函数](https://www.cnblogs.com/jiayouwyhit/p/3753909.html)

- 总结

  ```cpp
  // 从函数声明上可以看出。malloc 和 new 至少有两个不同: new 返回指定类型的指针，并且可以自动计算所需要大小。比如：
  int *p;
  p = new int;

  //返回类型为int* 类型(整数型指针)，分配大小为 sizeof(int);
  或：
  int* parr;
  parr = new int [100];

  //返回类型为 int* 类型(整数型指针)，分配大小为 sizeof(int) * 100;
  // 而 malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。

  int* p;
  p = (int *) malloc (sizeof(int)*128);

  //分配128个（可根据实际需要替换该数值）整型存储单元，
  //并将这128个连续的整型存储单元的首地址存储到指针变量p中
  // malloc返回的是void*类型，要做类型转换为int*
  double *pd=(double *) malloc (sizeof(double)*12);

  //分配12个double型存储单元，
  //并将首地址存储到指针变量pd中
  // malloc 函数返回的是 void * 类型。对于C++，如果你写成：`p = malloc (sizeof(int));` 则程序无法通过编译，报错：“不能将 void* 赋值给 int * 类型变量”。所以必须通过 (int *) 来将强制转换。而对于C，没有这个要求，但为了使C程序更方便的移植到C++中来，建议养成强制转换的习惯。
  // 函数的实参为 sizeof(int)，用于指明一个整型数据需要的大小。若你写成：1
  int* p = (int *) malloc (1);

  // 代码也能通过编译，但事实上只分配了1个字节大小的内存空间，当你往里头存入一个整数，就会有3个字节无家可归，而直接“住进邻居家”！造成的结果是后面的内存中原有数据内容被改写。
  ```

## 全局变量和全局常量

- [全局变量、全局常量](http://www.cnblogs.com/Dageking/p/3185230.html)

  ```cpp
  const int gDataSize=1000;//全局常量
  extern char gSzBuffer[];//全局变量
  //注意使用static修饰变量，就不能使用extern来修饰，即不可同时出现
  ```

- [memset](http://www.cnblogs.com/anthow/p/3392233.html)

  `void * memset(void *Dst, Val, size Size)` 参数分别是：目标起始**地址**、要赋的值、要赋值的字节数。。

  - memset 是按照字节对待初始化空间进行初始化的，也就是说，函数里面的第二个参数的那个初值（一般为 0）是按照一个一个字节往第一个参数所指区域赋值的，所以，对于单字节数据类型（char）可以初始化为任意支持的值，都没有问题，但是对于非多字节数据类型只能初始化为 0，而不能初始化成别的初值，因为对所有字节按任意顺序赋值 0 的结果都是 0，而如果初始化为其他的值，就会一个字节一个字节的进行赋值，从而出现奇怪的结果

  - memset 中的第三个参数一定要使用 sizeof 操作符，因为每个系统下对类型长度的定义可能不一样。

  - memset 中的第一个参数一定要是一个已知的、已经被分配内存的地址，否则会出错。

  - [常用于内存空间初始化](https://blog.csdn.net/dan15188387481/article/details/49621447)

  - memset 是逐字节拷贝的

    ```cpp
    char str[9];
    memset(str,0,9*sizeof(char));
    memset((void *)pszTimestamp, 0x00, sizeof(char) * pSize);

    // 将pszTimestamp的前sizeof(char)*pSize个字节设置为0x00.
    // (void *) 函数原型第一个参数需要是void *
    // 0x00和0的区别。。。。没区别
    struct sampleStruct stTest; //假设结构体sampleStruct已定义
    memset(&stTest,0,sizeof(struct sampleStruct)); //清空stTest
    ```

# 其他

# 参考资料

- [C/C++ 内存泄漏-原因、避免以及定位](https://mp.weixin.qq.com/s?__biz=MzI3ODQ3OTczMw==&mid=2247494079&idx=1&sn=d3600ae99f2faeaeebe73ab96ec8de5b&chksm=eb54ffa5dc2376b3bb01284a41ae3f4c74afba6353cfb76cba5cac8b2d81b194bedcd01236a6&scene=90&subscene=93&sessionid=1651885177&clicktime=1651885184&enterid=1651885184&ascene=56&fasttmpl_type=0&fasttmpl_fullversion=6142197-zh_CN-zip&fasttmpl_flag=0&realreporttime=1651885184722&devicetype=android-31&version=28001637&nettype=cmnet&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&session_us=gh_66162e1d5e79&exportkey=A5dwYSDvyFONML7CcdnSDQs%3D&pass_ticket=GitFQAf%2BKPMj6SMxhDojJPYpLQ3SrBrwZvVO1l6x8az5L%2F6XixvQxsGEndh5i9cZ&wx_header=3)
