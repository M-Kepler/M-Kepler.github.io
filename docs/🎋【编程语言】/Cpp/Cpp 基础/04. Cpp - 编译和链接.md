- [参考资料](#参考资料)
- [编译](#编译)
  - [configure](#configure)
  - [环境变量](#环境变量)
  - [编译参数](#编译参数)
  - [编译过程](#编译过程)
    - [静态库、动态库](#静态库动态库)
  - [静态联编、动态联编](#静态联编动态联编)
    - [动态静态库](#动态静态库)
  - [makefile](#makefile)
    - [make 错误](#make-错误)
    - [变量 宏 参数](#变量-宏-参数)
    - [规则](#规则)
    - [strip](#strip)
  - [g++](#g)
    - [静态库 .a](#静态库-a)
    - [动态库 .so](#动态库-so)
  - [gdb](#gdb)
  - [coredump](#coredump)
    - [valgrind 内存检测工具](#valgrind-内存检测工具)
    - [SIGABRT](#sigabrt)
    - [Core 文件调试](#core-文件调试)
    - [多线程多进程调试](#多线程多进程调试)
  - [编译选项](#编译选项)
- [常见编译器警告](#常见编译器警告)
- [cmake](#cmake)
  - [cmake 和 make](#cmake-和-make)
- [常见的编译问题](#常见的编译问题)
- [其他](#其他)

# 参考资料

# 编译

## configure

- [./configure 的配置和用法](https://blog.csdn.net/sunjing_/article/details/79146827)

## 环境变量

https://blog.csdn.net/zhuzitop/article/details/80388159

- `LD_LIBRARY_PATH` 等环境变量置顶的路进去查找，如果还找不到，那么编译程序提示找不到库

- `C_INCLUDE_PATH`

- `CPLUS_INCLUDE_PATH`

## 编译参数

CFLAGS

CXXFLAGS

## 编译过程

- [编译过程](https://www.cnblogs.com/mickole/articles/3659112.html)

![alt](https://images0.cnblogs.com/blog/529981/201404/111709152316188.jpg)

### 静态库、动态库

- [静态库、动态库](https://blog.csdn.net/luoweifu/article/details/48895765)

- [编译和链接](http://www.cnblogs.com/Tan-sir/p/7280776.html)

- 编译 (`.obj & .o`)

  源文件首先会生成中间目标文件（这个过程叫编译，windows 下生成.obj Unix 下为.o 文件）
  在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 Object File。

- `.lib & .a`

  - 链接器并不管函数所在的源文件，只管函数的中间目标文件

  - （Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在 Windows 下这种包叫“库文件”（Library File)，也就是 .lib 文件，在 UNIX 下，是 Archive File，也就是 .a 文件

- `链接`

  - 再由中间目标文件 Object File 生成执行文件，这个过程叫链接。

  - 在链接程序时，链接器会在所有的 Object File 中 找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）

- linux 下怎么生成 `.a 或.so` 文件

  - [静态库](http://www.cnblogs.com/jiqingwu/p/4325382.html)

  - [动态库](http://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html)

- [有个问题，编译时用的库路径和程序运行时的路径需要保持一致吗](https://www.cnblogs.com/cswuyg/p/10568945.html)

  首先我们要明确一个概念，程序动态库连接时的路径和运行时路径是不同的。现代连接器在处理动态库时将链接时路径（Link-time path）和运行时路径（Run-time path）分开, 用户可以通过 -L 指定连接时库的路径，通过 -R（或 -rpath）指定程序运行时库的路径，大大提高了库应用的灵活性。

## 静态联编、动态联编

- [静态联编、动态联编](https://www.cnblogs.com/xiaofengkang/archive/2011/10/21/2220678.html)

- [DLL 动态链接库和 LIB 静态链接库之程序员经验分析](http://www.cnblogs.com/lancidie/archive/2011/03/12/1982253.html)

- 联编(binding(捆绑)) 或者叫 静态、动态链接

  - 不管是静态链接/动态链接也好，还是先期联编/迟后联编也好，**都是描述了何时确定应用程序所调用函数的入口地址**。

  - 如果编译器在编译时或链接时确定了所有函数的入口地址，那么这种确定地址的方法称为静态链接或者先期联编。

  - 如果是在运行时确定所有函数的入口地址，那么这种确定地址的方法称为动态链接或者迟后联编。C++C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了, c++通过使用虚拟函数支持动态链接/迟后联编（也叫做动态联编），它们发生在运行时刻，这样一来，使用多重继承的程序便会有更大的灵活性。

  - C++PrimerPlus 好像是在指针那里讲有一点

  - 调用函數时，使用哪个可执行代码块呢?编译器负责回答这个问题．将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)．在 C 语言中：这非常简单；因为每个函数名都对应一个不同的函數．在 CPP 中，由于函数重载的缘故．这项任务更复杂．编译器必须看函数参数列表以及函数名才能确定使用那个函数。然而，C/C++编译器可以在编译过程完成这这种联编。在编译过程中进行联 编被称为**静态联编**。然而虚函数使这项工作变得困难。

  - 因为编译器不知道用户选择哪个类型的对象，所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为**动态联编**。

  - dll 封装了实现的方法，那我怎么知道它有哪些方法呢？

- 使用动态链接库

  使用动态链接库可以 `dlopen` 来使用，也可以直接应用头文件，编译的时候 `-lpthread` 来引用

  - 动态链接库的使用有两种方式，一种是显式调用。一种是隐式调用。

  - 显式调用

    使用 LoadLibrary 载入动态链接库、使用 GetProcAddress 获取某函数地址。

  - 隐式调用

    可以使用`#pragma comment(lib, “XX.lib”)的` 方式，直接将 XX.lib 加到工程中

  - [Windows](http://www.cnblogs.com/cswuyg/archive/2011/09/30/dll.html)

  - [Linux](https://www.cnblogs.com/xudong-bupt/p/6537689.html)

    ```cpp
    #if defined(OS_IS_WINDOWS)
      {
        HMODULE hModule = NULL;
        hModule = ::LoadLibrary("kcbpcrypt.dll");
        if (!hModule)
        {
          iRetCode = XSDK_KO - 2;
          goto __end;
        }
        pfnDecryptPassword = (fnDecryptPassword)::GetProcAddress(hModule, "DecryptPassword");
        if (!pfnDecryptPassword)
        {
          iRetCode = XSDK_KO - 3;
          goto __end;
        }
        pfnDecryptPassword(szUid, szPwd, szPlainPwd, sizeof(szPlainPwd) - 1);
        strncpy(szPwd, szPlainPwd, sizeof(szPwd));
        ::FreeLibrary(hModule);
      }
    #else
      {
        void *hModule = NULL;
        hModule = dlopen("libkcbpcrypt.so", RTLD_LAZY);
        if (!hModule)
        {
          iRetCode = XSDK_KO - 2;
          goto __end;
        }
        pfnDecryptPassword = (fnDecryptPassword)dlsym(hModule, "DecryptPassword");
        if (!pfnDecryptPassword)
        {
          iRetCode = XSDK_KO - 3;
          goto __end;
        }
        pfnDecryptPassword(szUid, szPwd, szPlainPwd, sizeof(szPlainPwd) - 1);
        strncpy(szPwd, szPlainPwd, sizeof(szPwd));
        dlclose(hModule);
      }
    #endif
    __end:
        // 这只是个label 标签，位置点，无论是否 goto 都会正常走下去
        printf("end");)
    ```

- `静态联编`

  如`int aa[11]` 即数组的长度是在编译时设置的

- `动态联编`

  - 与通过指针、引用调用方法有关

  - `int * psome = new int[3];` 即运行时为数组分配空间，`psome` 指向数组的第一个元素，`*psome/psome[0]`都是第一个元素的值,第二个元素就是 psome[1]

### 动态静态库

- 静态库是指编译连接时，把库文件的`代码全部加入到可执行文件中`

  - 静态库有更新就要重新打包

  - 生成的文件较大

  - 运行时就不再需要库文件

- 动态库只在`执行时才加载`，如果删除动态库文件，程序将会因为无法读取动态库而产生异常。

  - 程序升级简单，动态库更新，依赖动态库的程序无需重新编译

  - 没把库文件的加入到可执行文件中，生成的文件较小

  - 动态链接库可供多个程序共享

- `静态库`

  函数和数据被编译成一个二进制文件.lib，在使用静态库的情况下，在编译链接成可执行文件时，链接器会从静态库复制数据和函数，然后和应用程序的其他模块组合起来创建最终的可执行文件.exe。发布产品时，只需要发布这个.exe 文件即可。

- `动态库`

  在使用动态库的情况下，一般提供两个文件，`.lib和.dll`，这里的`.lib`文件和静态库中的是有本质区别的，这个`.lib`导入库文件包含“需要导入的 dll 文件名和该 dll 文件中导出的函数和变量的符号”，而`.dll`文件存放有函数和变量的实际定义。在编译连接时，只需将`.lib`文件链接到可执行文件中.exe，并不需要将.dll 文件链接到.exe 文件中，也就是说，将.dll 文件存放在.exe 文件外部。直到可执行程序运行时，才去加载.dll 文件，然后访问.dll 中的函数和变量

## makefile

- [跟我一起写 makefile](https://seisman.github.io/how-to-write-makefile/index.html)
- [makefile 基础](https://www.cnblogs.com/vamei/archive/2013/04/29/3051062.html)
- https://blog.csdn.net/alpha_love/article/details/62953847
- [makefile 中命令行没使用 tab 缩进导致报错](https://blog.csdn.net/limanjihe/article/details/52231243)

```makefile
CC = gcc
XX = g++
CFLAGS = -Wall -O -g
TARGET = ./main.out
###########################################################

%.o:%c
  $(CC) $(CFLAGS) -c $< -o $@

%.o:%.cpp
  $(XX) $(CFLAGS) -c $< -o $@

SOURCES = $(wildcard *.c *.cpp)

OBJS = $(patsubst %.c,%.o, $(patsubst %.cpp,%.o,$(SOURCES)))

$(TARGET):$(OBJS)
  $(XX) $(OBJS) -o $(TARGET)
  chmod a+x $(TARGET)

clean:
  rm -rf *.o main
```

- 往程序中送 `#define` 定义

  文件中没有`#define DEBUG`, 可在编译时加上参数 `-DDEBUG`

  ```cpp
  #ifdef DEBUG
  #endif
  ```

- 输出说明信息

  ```makefile
  all: desc target
  desc:
      @echo "我简单说几句"
  ```

### make 错误

- 问题 1

  ```sh
  xxx.so: file format not recognized; treating as linker script
  xxx.so:1: syntax error
  ```

- 解决 1

  对于 libhqx.so.1.0.0 或 libhqxso 来说，这是一个符号链接。在你的机器里的这个链接已经坏掉了。(至少在我们的系统中是这样的，当我们删除了 so 文件后，问题就解决了，并创建了正确的符号链接)

- 问题 2

  ```sh
  undefined reference to `pthread_mutex_unlock
  ```

- 解决 2

  ```sh
  只要在arm-linux-gcc at_main.c -static -lpthread -o test
  加上一个-lpthread 就可以解决此问题
  ```

- [【GCC】参数顺序导致的 undefined reference 问题](https://blog.csdn.net/lonfee88/article/details/6029540)
  `gcc 和 g++` 中库的链接顺序是从右往左进行，所以要**把最基础的库放在最后**，这样左边的 lib 就可以调用右边的 lib 中的代码

### 变量 宏 参数

> shell 命令: CURR_PWD = \$(shell pwd)

- gdb 编译宏

  ```makefile
  $@ 目标文件名
  $< 第一个依赖文件
  $^ 所有依赖文件
  ```

- [通配符 wildcard](https://www.cnblogs.com/haoxing990/p/4629454.html)

  ```makefile
  # whildcar后面的表示通配符
  $(wildcard L*.cpp)
  ```

- 替换通配符 `patsubst`

  ```makefile
  # 将列表中所有文件名的后缀.c替换为.o, 就可以得到在当前目录可生成的.o文件列表
  $(patsubst %.c,%.o,$(wildcard *.c))
  # 把通配符$(whildcard *c)过滤的结果中的所有.c后缀替换成.o后缀
  ```

- findstring

- `%` [Makefile 中的%标记和系统通配符\*的区别](https://www.cnblogs.com/warren-wong/p/3979270.html)

  ```makefile
  %.o:%.c
      gcc -o $@ $<
  all: test1.o

  # 编译make需要test1.o
  # makefile中没有明确的test.o:test.c规则
  # 发现通用规则 %.o:%.c
  # 套用规则: test1.o:test1.c，且发现目录中存在test1.c
  # 可成功进行

  # 规则是:我不知道目标的名字，系统该目录下中所有后缀为.c的文件都是我要找的。然后遍历目录的文件，看是否匹配。找出所有匹配的项目。
  ```

- 告诉链接器要链接那些库文件 `LIBS`

  ```makefile
  LIBS = -llibname_a -llibname_b
  ```

- gcc 编译器的优化参数 或 告诉连接器去哪里找库文件

  ```makefile
  LDFLAGS = -L/path/to/libname_a -L/path/to/libname_b
  ```

- 指定头文件路径 `CFLAGS`

  ```makefile
  I_INCLUDES = /path/to/libs/include
  L_INCLUDES = /path/to/libs/include
  CFLAGS = -I$(I_INCLUDE)
  LFLAGS= -shared$ (L_INCLUDE)
  ```

- [【伪目标 `.PHONY`】](https://blog.csdn.net/derkampf/article/details/70256891)
  拿 clean 举例，如果 make 完成后，当前文件夹下存在一个叫 clean 的文件，再执行 make clean 时，将不会执行 makefile 里的 make 命令。
  为了避免出现这个问题，需要`.PHONY: clean` clean 就是一个伪目标

### 规则

- 如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。

- 如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。

- 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。

```makefile
# target依赖于prerequisites,可以有多个前提文件，用空格分开。
target: prerequisites
(command)

hello: prerequ1.o prerequ2.o
    gcc -o hello prerequ1.o prerequ2.o

prerequ1.o: prerequ1.c prerequ1.h
    gcc -c -o prerequ1.o prerequ1.c

prerequ2.o: prerequ2.c prerequ2.h
    gcc -c -o prerequ2.o prerequ2.c
```

- 也可以直接定义一个命令

  ```makefile
  # 清除所有过程文件及最终文件
  cleanall :
    rm -f *.bnd *.lst *.C *.o *.so *.ibmcpp *.lis
  ```

- `make` 命令

  - `makefile` 第一条规则是最终文件(默认目标)，后面的是最终文件的依赖项的生成规则
  - make 会一步步检查，如果依赖文件比目标文件新，则会从后往前重新执行命令
  - make 默认会去找 makefile 或 Makefile,但也可以指定别的文件名`make -f Make.linux`

- `make` 自动推导
  只要 make 看到一个`[xxx.o]`文件，它就会自动的把`[xxx.c]`文件加在依赖关系中，如果 make 找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 编译命令 gcc -c whatever.c 也会被推导出来.

### strip

TODO

## g++

```log
预处理（处理头文件，宏替换，删除注释等）----> 编译（编译成汇编代码）----> 汇编（编译成二进制代码）----> 链接（链接程序用到的系统库，生成可执行文件）
```

- 预处理

  `gcc -E test.c -o test.i` 条件编译、头文件引入、注释删除、宏替换等

- 编译

  `gcc -S test.i -o test.s` 词法分析、语法分析、语义分析和中间代码生成、优化、目标代码生成

  - `auto` 自动类型推导

  - 打开调试选项 `-g`

- 汇编

  `gcc -c test.s -o test.o` 将汇编指令翻译成机器码

- 链接

  `gcc test.o -o test` 链接器将多个源文件生成的.o 文件捆绑在一起，同时链接到程序所需要的函数的函数库，生成一个单一完整的可执行程序

- 可以一步到位,也可以跨过几步

  ```conf
  gcc test.cpp -o test.out
  gcc -S test.cpp -o test.s # 直接由cpp生成.s
  ```

- [选项分类](https://blog.csdn.net/zhu2695/article/details/51340738)

- [调试选项](https://www.cnblogs.com/LiuYanYGZ/p/5550544.html)

  ```makefile
  -Wall    # 输出所有编译警告 warning all
  -g       # 产生调试信息
  -Dxxxx   # 向程序传入 #define
  -rdynamic
  # 指示链接器将所有非static全局变量和非static函数的符号输出到符号表中；（目的是能够通过使用 **dlopen** 或 **backtrace** 来实现向后跟踪）
  ```

- [找头文件 -L -i -I](https://blog.csdn.net/lin_008/article/details/77600483)

  ```makefile
  -L # 表示到/lib/目录下找库文件

  -i # 编译程序到系统默认路进搜索，如果找不到，到当前目录，如果当前目录找不到，则到 LD_LIBRARY_PATH  等环境变量置顶的路进去查找，如果还找不到，那么编译程序提示找不到库

  -I （大写i）：
  # 如-I ./lib/openssl/include，./表示在本目录下，后面的路径存放着头文件的地址，第一个寻找头文件的目录。
  ```

- [g++基本用法](https://blog.csdn.net/richerg85/article/details/17073805)

### 静态库 .a

- 生成

  ```makefile
  ar crv libTestApi.a TestApi.o
  ```

- 使用

  ```makefile
  g++ main.cpp -L/path/to/staticlib/ -lTestApi -o main.out
  ```

### 动态库 .so

- [linux 调用动态库](https://www.cnblogs.com/chenhuan001/p/7688731.html)

- 生成

  ```makefile
  # -fPIC 生成位置无关目标代码
  # -shared 生成动态库
  g++ -shared -fPIC -o libmyAPI.so myApi.o
  ```

- [linux 下动态链接库(.so)的显式调用和隐式调用](https://blog.csdn.net/lc_910927/article/details/42393121)

- 隐式调用

  ```makefile
  # -L 动态库搜索路径, 库名称libTestApi.so要掐头去尾
  g++ main.cpp -I/path/to/lib/include -L/path/to/dynamic/lib -lTestApi -o main.out
  ```

- 显式调用

  ```cpp
  #include <dlfcn.h>
  dlopen // 加载so到内存, 返回 void*
  dlsym // 取函数执行地址（所以要定义函数指针）
  dlclose 释放句柄
  dlerror // 获取以上dlxxx函数的错误信息，一般会在dlopen前调用一下来清楚已有错误信息
  // 编译必须加上-ldl(dynamic lib库提供 dlopen、dlsym、dlclose)
  // g++ Testdl.cpp -o Testdl.out -ldl
  ```

## gdb

```sh
gcc -g  main.c                      # 在目标文件加入源代码的信息
gdb a.out

(gdb) start                         # 开始调试
(gdb) n                             # 一条一条执行
(gdb) step/s                        # 执行下一条，如果函数进入函数
(gdb) backtrace/bt                  # 查看函数调用栈帧
(gdb) info/i locals                 # 查看当前栈帧局部变量
(gdb) frame/f                       # 选择栈帧，再查看局部变量
(gdb) print/p                       # 打印变量的值
(gdb) finish                        # 运行到当前函数返回
(gdb) set var sum=0                 # 修改变量值
(gdb) list/l 行号或函数名            # 列出源码
(gdb) display/undisplay sum         # 每次停下显示变量的值/取消跟踪
(gdb) break/b  行号或函数名          # 设置断点
(gdb) continue/c                    # 连续运行
(gdb) info/i breakpoints            # 查看已经设置的断点
(gdb) delete breakpoints 2          # 删除某个断点
(gdb) disable/enable breakpoints 3  # 禁用/启用某个断点
(gdb) break 9 if sum != 0           # 满足条件才激活断点
(gdb) run/r                         # 重新从程序开头连续执行
(gdb) watch input[4]                # 设置观察点
(gdb) info/i watchpoints            # 查看设置的观察点
(gdb) x/7b input                    # 打印存储器内容，b--每个字节一组，7--7组
(gdb) disassemble                   # 反汇编当前函数或指定函数
(gdb) si                            # 一条指令一条指令调试 而 s 是一行一行代码
(gdb) info registers                # 显示所有寄存器的当前值
(gdb) x/20 $esp                     # 查看内存中开始的20个数
```

- 进入 gdb 不显示版本等提示信息

  ```sh
  $gdb -q getlastline.out
  ```

- 加载文件

  ```sh
  $gdb
  (gdb) file getlastline.out
  ```

- gdb 给程序入参数

  ```sh
  # 编译加入调试选项
  $g++ --std=c++11 -g getlastline.cpp -o getlastline.out

  # 进入调试
  $gdb getlastline.out

  # 设置参数
  (gdb) set args runlog0.log 10
  ```

- 查看 list

  - list 默认显示行数可以用 show listsize 来查看
  - 如果感觉 10 行太多或者太少，还可以用 set listsize [count]来更改。
  - 重复执行 list 可往后继续查看代码

  ```sh
  # 某字符串所在行
  (gdb)search xxx
  (gdb)reverse-serach xxx

  # 查看当前行前面的代码
  （gdb)list -

  # 查看97行
  (gdb)l 97

  # 查看5至10行的代码
  (gdb)l 5,10

  # 查看某函数附近的代码
  (gdb)l funcName

  # 有多个源文件时，查看某文件第5到10行
  (gdb)l test.cpp:5,10
  ```

- 断点 break

  ```sh
  # 设置断点
  (gdb)b 6

  # 在当前行前/后offset处停下
  (gdb) b +/- offset

  # 在filename.c文件的第linenum行停下
  (gdb) b filename.c:linenum

  # 在filename.c文件funcname函数入口处停下
  (gdb) b filename.c:funcname

  # 条件断点; 如果n值为6, 则在第7行设置断点
  # break [location] if xxxx
  (gdb) b 97 if atoi(argv[2])==3

  # 函数处设置断点
  (gdb) b func_name

  # 列出断点信息 info breakpoints
  (gdb)i b
  Num     Type           Disp Enb Address            What

  # 断点失效
  (gdb)disable break_num

  # 删除断点
  (gdb)delete break_num
  ```

- 运行

  ```sh
  # 执行 run
  (gbd)r

  # 遇到断点后继续执行 continue
  (gdb)c

  # 逐语句执行(不进入函数内部) next
  # 将显示下一行即将执行的语句
  (gdb)n

  # 逐过程执行(进入函数内部) step in
  (gdb) s

  # 一次性执行count步，有函数进入函数
  (gdb)step count

  # 一次性执行count步，不进入函数
  (gdb)next count

  # 跳出函数，并打印出函数返回时的堆栈地址、返回值和参数信息
  (gdb)finish

  # 退出循环
  # 在循环体内最后一条语句之后执行 until, 就会执行完循环体到后面的一个语句停下。
  (gdb) util

  # 执行完当前函数 finish
  (gdb)f
  ```

- 变量

  ```sh
  # 查看变量值 print arg_name
  (gdb) p argv[0]

  # 查看变量类型 whatis arg_name
  (gdb) whatis arg_name

  # 监控变量
  (gdb) watch expr 表达式expr发生变化时，停下
  (gdb) rwatch expr 表达式expr被读时，停下
  (gdb) awatch expr 表达式expr被读/写时，停下

  * 查看在哪发生 Segmemtatin fault
  (gdb) where
  ```

## coredump

程序崩溃时保存的程序运行时的保存的内存信息的 coredump 文件，可以通过 sysctl 或者 /proc 中来设置 core 文件的文件名以及生成的路径等。一般的 coredump 文件为 ELF 格式，coredmp 包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。许多程序和操作系统出错时会自动生成一个 core 文件。coredump 可以用在很多场合，使用 Linux 系统在跑一些压力测试或者系统负载一大的话，系统就 hang 住了或者干脆 system panic。这时唯一能帮助你分析和解决问题的就是 coredump 了。通常进程或者内核收到

- `查看地址内容`

  ```sh
  (gdb) p *(struct sync_sess *)0xw241342a3
  ```

- 查看 core 文件路径 `cat /proc/sys/kernel/core_pattern`

- gdb 查看内存地址和栈中的值

  ```log
  查看当前程序栈的内容: x/10x $sp        --> 打印stack的前10个元素

  查看当前程序栈的信息: info frame       --> list general info about the frame

  查看当前程序栈的参数: info args        --> lists arguments to the function

  查看当前程序栈的局部变量: info locals  --> list variables stored in the frame

  查看当前寄存器的值：info registers(不包括浮点寄存器) info all-registers(包括浮点寄存器)

  查看当前栈帧中的异常处理器：info catch(exception handlers)

  ```

- [GDB 调试技巧：调试复杂的宏定义](http://blog.chinaunix.net/uid-29062294-id-4255572.html)

- [`<repeats 108 times>`](https://stackoverflow.com/questions/2252711/print-whole-string-verbatim-in-gdb)

  ```gdb
  set print repeats 1
  ```

- [可变参数打印](https://www.jb51.cc/c/114972.html)

  ```gdb
  (gdb) p *(char **)(((char *)v.reg_save_area) + v.gp_offset)
  ```

- 打印字符串全部内容

  ```gdb
  set print element 0
  ```

### valgrind 内存检测工具

- [安装](https://www.cnblogs.com/qujingtongxiao/p/9901213.html)

- [valgrind: failed to start tool 'memcheck' for platform 'amd64-linux](https://www.cnblogs.com/hdflzh/p/4191492.html)

### SIGABRT

- [SIGABRT 的可能原因](https://blog.csdn.net/prike/article/details/73649331)

- [double free](https://blog.csdn.net/cangyingzhijia/article/details/8613177)

- 有时候从代码中没能明显看到 `free` 了两次的地方，但是在创建任务的时候，如果多个任务用了同一个句柄，然后对每个任务进行释放的时候，就会对同一个句柄释放多次

### Core 文件调试

> Segmentation fault (core dumped)

- [样例](https://blog.csdn.net/sunxiaopengsun/article/details/72974548)

### 多线程多进程调试

- [gdb 调试多进程与多线程](https://blog.csdn.net/snow_5288/article/details/72982594)

- [GDB 调试多进程或者多线程应用](https://blog.csdn.net/gatieme/article/details/78309696)

> 在不终止正在运行的进程的情况下来对这个正在运行的进程进行调试

**多进程调试**

- 方法一：attach 多进程调试

- 方法二: follow-fork-mode、detach-on-fork

  ```sh
  set follow-fork-mode [parent|child]
      parent: fork 之后继续调试父进程，子进程不受影响。
      child:  fork 之后调试子进程，父进程不受影响。

  set detach-on-fork [on|off]
      on : 只调试 follow-fork-mode 指定的进程
      off: 调试所有进程, 当前调试的是follow-fork-mode指定的进程, 其他进程停止在fork位置
  i inferior 查看infer状态
  ```

## 编译选项

[gcc 警告选项汇总](https://blog.csdn.net/qq_17308321/article/details/79979514)

**取消编译警告 `-Wno-error=xxx`**

- [`error: invalid conversion from ‘char’ to ‘char**’ [-fpermissive]`](https://blog.csdn.net/lst227405/article/details/25975661)

  ```sh
  编译中的 -Werror 去掉，加上 -fpermissive
  ```

# 常见编译器警告

- 不允许使用类型名

- 不允许使用不完整的类型

# cmake

[关于 gcc、make 和 CMake 的区别](https://www.cnblogs.com/xuelisheng/p/9988626.html)

## cmake 和 make

就是为了编译一个大型程序，你首先编写 CMakeLists.txt。然后，通过 cmake 命令就可以生成 makefile 文件。然后通过 make 命令就可以使用这个 makefile 文件从而生成可执行文件。

- makefile 在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写 makefile 也是非常麻烦的，如果换了个平台 makefile 又要重新修改。

# 常见的编译问题

- 有可能是头文件被多次包含，[`C++ "multiple definition of .. first defined here"`](https://www.cnblogs.com/zjutzz/p/4018816.html)，也有可能是

- 头文件包含多次的问题[`previous definition of ‘struct blob_data`](https://blog.csdn.net/u011328417/article/details/98876517)

  ```cpp
  #ifndef TEST_H_
  #define TEST_H_
  #endif
  ```

- [头文件中声明的 cpp `静态数组`给出警告“defined but not used”](https://www.it1352.com/477392.html)

  ```cpp
  // test.h
  #ifndef TEST_H
  #define TEST_H
  // 定义char*的时候要注意
  extern const char *test[] = {};

  // 或者不要那么麻烦，直接define好了
  #define TEST = "teststring";

  // test.c
  #include "test.h"
  const char *test[] = {"device_id", "time"};
  ```

# 其他

- 检查二进制文件编译时是否 `strip` 了

  ```sh
  $file /usr/bin/my_app

  /usr/bin/my_app: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.26, BuildID[sha1]=0xea94ed8e6eeef13247b63a3427136b6cb013c568, not stripped

  ```
