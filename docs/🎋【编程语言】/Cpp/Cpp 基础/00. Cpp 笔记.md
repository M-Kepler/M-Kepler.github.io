- [参考链接](#参考链接)
  - [宏与内联函数](#宏与内联函数)
- [函数](#函数)
  - [参数](#参数)
  - [回调函数](#回调函数)
  - [虚函数](#虚函数)
- [`string`](#string)
- [其他](#其他)
  - [枚举 ENUM](#枚举-enum)
  - [变长参数`...`](#变长参数)

# 参考链接

- [CPP 参考手册](https://www.apiref.com/cpp-zh/index.html)

- [CPP](http://c.biancheng.net/)

- [CPP 基础知识](https://blog.csdn.net/xiongchao99/article/details/64441017)

- [CPP 全面总结](https://www.cnblogs.com/jianxinzhou/p/3994248.html)

- [深度探索 C++ 对象模型](https://www.cnblogs.com/longjiang-uestc/p/10777128.html)

## 宏与内联函数

- [宏与内联函数](https://www.cnblogs.com/yfanqiu/archive/2012/05/07/2488220.html)

- [内联函数的声明和定义](https://www.cnblogs.com/zsq1993/p/5978743.html)

- [内联函数](http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/)

- [内联函数](https://www.cnblogs.com/yfanqiu/archive/2012/05/07/2488220.html)

- `typedef` 与 `#define` 的区别

  > 类型别名与宏的三点区别，如`typedef char *String_t; 和#define String_d char *`两句

  - 前者是类型别名，要做类型检查，后者只是一个替换，不做类型检查

  - 前者编译时处理，后者预编译时处理，即预编译期间替换掉宏

  - 前者能保证定义的全都是`char*` 类型，`String_d`却不能，如`String_t a,b;String_d x,y;`其中 a、b、x 为`char*`类型，而 y 却是 char 类型，这点要注意（因为简单替换就是：`char *x,y`，y 前面没有指针符就不是指针）

- [C 中为什么要用内联函数](https://blog.csdn.net/buaa_shang/article/details/8799027)

  - 区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题

  - 内联函数和宏定义一样, 都是把代码展开, 不过宏是在预处理的时候进行替换展开
    内联函数则是在**编译**阶段展开, 减少了一次函数调用时的跳转、数据压栈等操作 比如 `#define和const` 的区别也是一样, 都是放到编译阶段, 因为编译阶段出错会报错出来

  - 那内联函数和成员函数的区别是什么？既然这样为什么不把所有都声明为内联
    如果程序在 10 个不同的地方调用同一个内联函数，则该程序将包含该函数代码的 10 个副本,会消耗更多空间,所以作为内敛函数的运行时长越短越好(因为会展开,所以含有递归调用的函数不能设置为 inline)

- 宏里面也可以使用库函数的。。。。

- [函数调用约定`__cdecl`、`__stdcall` 和`__fastcall`](https://blog.csdn.net/luoweifu/article/details/52425733)

|      要点      |                 `__cdecl`                  |      `__stdcall`       |                                          `__fastcall`                                          |
| :------------: | :----------------------------------------: | :--------------------: | :--------------------------------------------------------------------------------------------: |
|  参数传递方式  |                   右-左                    |         右->左         | 左边开始两个不大于 4 字节（DWORD）的参数分别放在 ECX 和 EDX 寄存器，其余的参数自右向左压栈传送 |
|    清理栈方    |                 调用者清理                 |     被调用函数清理     |                                         被调用函数清理                                         |
|    适用场合    | C/C++、MFC 的默认方式; 可变参数的时候使用; |        Win API         |                                           要求速度快                                           |
| C 编译修饰约定 |              `_functionname`               | `_functionname@number` |                                     `@functionname@number`                                     |

- `__declspec`: 说明 DLL 的引出函数](https://blog.csdn.net/zhaoyin214/article/details/83541613)
  使用了 def 文件，那就不需要`extern "C" **declspec(dllexport) FUNC_NAME`了, 都是定义导出函数名的

- `#pragma comment(lib, "lib_name")`

- [`# define` 和 `#define` 都可以](http://blog.chinaunix.net/uid-28458801-id-4452871.html)

- [宏拼接字符串，中间的空格会被省略掉](https://zhidao.baidu.com/question/429308831332728372.html)

  ```c++
  #define A "a123"
  #define B "b456"
  # define C A B
  cout << C << endl;
  ```

# 函数

- 值传递、引用传递、指针传递

  - 值传递和引用传递定义方式不一样

  - 引用传递和指针传递都会改变实参的值

  - 指针传递在函数中要使用变量的话要用上解除引用运算符*。即(*p)

  - 引用

    - 作为函数参数

    - 可将结构、类对象的引用作为函数的形参

    - 返回值为引用

      - 传统的返回是将结果保存在一个临时的位置然后传递给变量

      - 引用返回是直接将值复制给变量，效率更高

- 内联函数

  - ????:

    - 常规函数跳转到独立的函数去运行;内联函数用内联代码替换函数的调用。速度比常规函数快，代价是需要占用更多内存,

    - 对于内联代码,程序无需跳到另一个位置执行代码再跳回来.而是用相应的代码替换函数调用.

    - 如果程序在 10 个不同的地方调用同一个内联函数，则该程序将包含该函数代码的 10 个副本,所以作为内敛函数的运行时长越短越好(内联函数可不能递归)

    - 和常规函数一样，也是按值来传递参数的。[C++的内联？？？C 的宏]

  - 定义方法:

    - 在函数声明/定义前加上关键字 inline

      - 我们可以在类外部用 inline 来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。内联函数必须是和函数体申明在一起，才有效

      - 内联函数应该在头文件中定义

        宏占编译时间，而函数占执行时间。

    - 内联函数也可以放到头文件中

  - [内联函数和宏(#define)的联系](http://ibillxia.github.io/blog/2014/05/17/insight-into-define-and-inline-function-in-c/)

    - 宏定义是完全原封不动的替换，而内联函数则并非简单的文本替换，而是按函数调用的方式展开

    - https://www.cnblogs.com/yfanqiu/archive/2012/05/07/2488220.html

- 函数重载

  关键是函数的参数列表（参数的数目和类型、参数的排列顺序）

- 函数模板（./othser/func-template.cpp）

  - 比如我是一个接受和返回 int 类型的函数。如果数据是 double 类型的话，重复的代码就又要写一遍。用模板就可以解决这个问题

  - 使用方法和传统函数一样,模板不会减少执行程序的大小，在调用模板函数的时候，编译器都是根据调用时的参数类型进行了相应的实例化

  - 显式实例化、显式具体化

    - 显式实例化

      - 在使用模板前，编译器会根据实例化制定的类型生成模板实例。只需声明

        ```cpp
        template void swap<int>(int &a,int &b); //定义
        cout << swap<>(m,n); //<>指出编译器应选择木板函数
        cout << swap<int>(m,n); //显式实例化
        ```

    - 显式具体化

      就是在函数模板的基础上,对于某些特殊类型，可能不是和模板实现，需要重新定义实现，可以使用显式具体化（必须重新定义）

- 重载 + 模板

  调用优先级：普通函数>显示具体化>显式实例化>普通模板

- 类模板

  缺点: 编写的模板可能无法处理某些类型的运算。比如数组的大小比较

## 参数

- [默认参数](https://www.cnblogs.com/chenke1731/p/9651275.html)

  ```cpp
  void test(int position_arg, bool def_arg=false);

  void test(int position_arg, bool def_arg)
  {
      printf("do something");
  }
  ```

## 回调函数

> [回调函数](https://blog.csdn.net/clirus/article/details/50350519)

## 虚函数

- 虚函数的调用关系：`this -> vptr -> vtable ->virtual function`，所以增加一个虚函数类的大小会增加 4 个字节（指针大小）

- 由于基类函数是虚函数（派生类相应函数就自动变虚函数，所以派生类同名函数可以不指定为虚函数）

  - 即通过指针调用的方法是一样的，只要根据需要给这个指针赋值就可以实现调用基类还是派生类的同名函数了

  - 但是这样不能输出子类自己的成员，当然也可以直接用对象调用，或用指针调用来完成，但是这样就不能够用同一种方式去调用同一类族中不同类的所有的同名函数了

  ```cpp
  grad1.display();
  Graduate *ptr=&grad1;
  ptr->display();
  ```

  - 如果以一个基础类指针指向一个衍生类对象(派生类对象)，那么经由该指针只能访问基础类定义的函数（静态联翩）

  - 如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。

    [《什么是虚函数、虚函数的作用和使用方法》](http://c.biancheng.net/cpp/biancheng/view/244.html)

- [虚函数](http://blog.csdn.net/lz20120808/article/details/50461296)

  ```cpp
  class man
  {
      ...
      virtial void Eat();   // 虚函数
      ...
  };

  CMan man;
  CChild child;
  // 这才是虚函数使用的精髓，如果不定义基类的指针去使用，没有太大的意义
  CMan *p ; // 父类指针
  p = &man ; // 指针指向父类对象
  p->Eat(); // 始终调用CMan的Eat成员函数，不会调用 CChild 的

  p = &child; //指针指向子类的对象
  p->Eat(); //如果子类实现(覆盖)了该方法，则始终调用CChild的Eat函数
  //不会调用CMan 的 Eat 方法；如果子类没有实现该函数，则调用CMan的Eat函数
  p->Move(); //子类中没有该成员函数，所以调用的是基类中的
  ```

# `string`

- `char * 和 char []`的区别

- `char *s` 是指针变量, 它指向的内存区域的大小可以随时改变, 但当指针指向常量字符串时, 它的内容是不可修改的.

  `char * s = "hello";` // 会报错, 改为 `const char*` 或强转

- `char s2[]`是数组，对应着一块内存区域，其地址和容量在生命周期里不会改变,只有数组的内容可以改变

- `char*、char[]、string`转换

- `char * 转 char[]`

  如上解释, `char*`是指针，如果想要转换的话，需要使用字符串拷贝或内存拷贝

  ```cpp
  char arr[10]={0}; //数组除了初始化以外，都不能用=给数组整体赋值
  char _tmp = (char_)"ABC";
  strcpy(arr, tmp);
  // memcpy(arr, tmp, sizeof(arr));
  ```

- `string 转 char*`

  ```cpp
  string str="hello";

  // char* pstr = (char *)str.data();
  // char* pstr = (char *)str.c_str();
  // char p[50]; str.copy(p, 50,0); \*(p+50)='\0';
  ```

- `char* 转 string`

  ```cpp
  string s;
  char *p = "hello";  // 直接赋值
  s = p;
  ```

- `string 转 char[]`

  ```cpp
  string pp = "dagah";
  char p[8];
  int i;

  for (i=0; i < pp.length(); i++)
  {
      p[i] = pp[i];
  }

  p[i] = '\0'; // 末尾加上\0
  ```

- [size_t](http://blog.csdn.net/qq_30866297/article/details/51465473)

  - 是一个**与机器相关**的 `unsigned` 整型类型，其大小足以保证存储内存中对象的大小。在 C++中，设计 size_t 就是为了适应多个平台的

  - 在 32 位系统中`size_t`是 4 字节的，而在 64 位系统中，`size_t`是 8 字节的

- [string::size_type](https://blog.csdn.net/lzx_bupt/article/details/6558566)

- [`string::npos`](http://blog.csdn.net/jiejinquanil/article/details/51789682)

  - npos 是无符号数 size_t 的最大值

  - find 函数在找不到指定值的情况下会返回 `string::npos`

  - 字符串结束不是`\0`吗? FIXME

- 把负值赋值给无符号数，会得到一个很大的数，如：赋值-2 则得到`2^n-2`，n 为机器位数

- [无符号数陷阱](http://blog.chinaunix.net/uid-10014667-id-375027.html)、[负值赋值给无符号数](http://blog.csdn.net/songbai_pu/article/details/9172689)、[参考 2](https://zhidao.baidu.com/question/375476431.html)

- [npos](http://blog.csdn.net/jiejinquanil/article/details/51789682)

- `char *a / char a[] / string`

- `vsnprintf` 包含头文件`#include <stdarg.h>`将可变参数格式化到数组中

- [vsnprintf 返回值的坑](https://baijiahao.baidu.com/s?id=1661965316912686740&wfr=spider&for=pc)

  ```cpp
  /* vsnprintf example */
  #include <stdio.h>
  #include <stdarg.h>

  void PrintF( const char * format, ... )
  {
    char buffer[256];
    int length = 0;
    va_list args;
    length = snprintf(buffer,sizeof(buffer),"[RECORD]%s\t", "2021-090323 23232 232 232");
    printf("pre buffer length:%d\n", length);

    va_start (args, format);
    length += vsnprintf(&buffer[length], sizeof(buffer)-length, format, args);
    va_end (args);

    printf("length: [%d], 注意这里, length 返回的能正常插入缓存的长度，538，但当超过 buffer 的长度时， vsnprintf 会截断，只保留 sizeof(buffer) - 1 的长度，所以直接访问 buffer[length-1] 会越界: 【buffer[length-1]: [%c]】, sizeof(buffer): [%ld]\n", length, buffer[length-1], sizeof(buffer));

    printf("\nbuffer: \n%s\n", buffer);
  }

  int main ()
  {
      const char *test = "ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeedddddddddddddddddddddddddddddddddddddddddddddddddd11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111133333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333";
      PrintF(test);
     return 0;
  }

  ```

- `sprintf`

  - [snprintf 函数用法](https://blog.csdn.net/crfoxzl/article/details/2062139)

  - [为什么 snprintf 比 sprintf 更安全](https://blog.csdn.net/stpeace/article/details/23561425)

  - [snprintf 与 sprintf 的区别](https://blog.csdn.net/xp178171640/article/details/50119349)

  sprinf 返回的是实际写入的字符串长度。sprintf 进行处理时不会进行越界判断，如果欲写入的字符串长度大于等于字符数组长度,会直接对之后的内存进行覆盖，极不安全

  `int sprintf_res = sprintf(sprintf_str, "I'm %d years old!",10);`

- `snprintf`

  snprintf 返回的是欲写入的字符串长度。

  `原型：int snprintf(char *str, size_t size, const char *format, ...)`

  - snprintf 实际上会拷贝**size-1**个字符到目标串中，然后再在后面加一个'\0'表示字符串结束。所以 size 应该是目标串的大小

  - 如果传入的 size 为一个大于目标串的值，在 vs 中会产生异常，因为 snprintf 要把 20-1 个字符拷贝到目标串，但是目标串只有 10-1 个位置,所以目标串最后的字符不是`'\0'`

  - 其中 size 表示目标字符串的大小，char a[10]={0};则为 sizeof(a);char \*b = new char[10],则为 strlen(b).

  ```cpp
  char snprintf_str[10] = {0};
  int snprintf_res = snprintf(snprintf_str, sizeof(snprintf_str), "I'm %d years old!",10);

  // 相比 snprintf 多个第二个缓存的参数，返回欲写入的长度,只拷贝了 n-1 个,并在末尾自动加上'\0'
  printf("snprintf_str:%s\t snprintf_res:%d\n", snprintf_str, snprintf_res);

  // int snprintf_res = snprintf(snprintf_str, 20, "I'm %d years old!",10); Error
  ```

- 以上是用于拷贝的时候

  将可变个参数(`...`)按照 format 格式化成字符串，然后将其复制到 str 中

  所谓的格式化，就是类似`printf("asdfasdf:%02d", iAge);`这样...

- 字符串拷贝函数 `strncpy、snprintf、strlen+memmove`

# 其他

- main 函数接收命令行参数 `void main(int argc, char **argv){}`

  - `argc`表示参数个数, 其中第一个参数是可执行程序

  - `argv[]`存放的是参数，其中 argv[0]表示可执行程序

- [uint32_t](https://blog.csdn.net/Mary19920410/article/details/71518130)

> uint32_t 和 int32_t 区别就是，前一个是无符号

- [uint8_t / uint16_t / uint32_t /uint64_t](https://blog.csdn.net/Mary19920410/article/details/71518130)

- 这些数据类型中都带有`_t`, `_t` 表示这些数据类型是通过 `typedef` 定义的

  ```cpp
  //uint8_t 实际上是一个 char。所以输出 uint8_t 类型的变量实际上输出其对应的字符，
  typedef signed char int8_t;
  typedef short int int16_t;
  typedef int int32_t;

  typedef unsigned char uint8_t;
  typedef unsigned short int uint16_t;
  typedef unsigned int uint32_t;
  ```

- [string 中 c_str()、data()函数的用法](https://blog.csdn.net/yansmile1/article/details/69258390)
  `string` 和 `const char*` 转换

- [atoi/atol/atoll/atof](http://www.codeweblog.com/linux下c-中的atoi-atol-atoll-atof函数调用实例/)

  如：`123.4fff atoi/atol/atoll` 输出为 123，`atof` 输出为 123.4

- [成员初始化列表](http://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)

  - 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

  - 如果类中声明了构造函数，那么系统不再提供默认构造函数，此时用户如果还要使用无参构造函数，则需要自己重载构造函数

  ```cpp
  class A
  {
      public:
          A(int a){_num = a;}
      private:
         int _num;
  }
  A aobj; // 报错
  ```

- 类有头文件和源文件，只要在头文件将需要 include 的头文件写在头文件就行了；源文件只需要 `include "class_name.h"`

- [类名 & 方法/变量](https://zhidao.baidu.com/question/506067787.html?fr=iks&word=%C0%E0%C3%FB+%26+%B7%BD%B7%A8+c%2B%2B&ie=gbk)，类名 \* 方法名
  不就和`float b=10; int & a=b;`一样吗; 我记得引用是要初始化的啊。。。我看它的代码。是直接在头文件的类里面用了引用，然后 cpp 那里实现这个函数（这就算初始化了？）

  - 头文件写上类成员函数的声明：`CLbmPara & GetFlowCtrl(...);`。源文件类成员函数的实现`CLbmPara & CLbmPara::GetFlowCtrl(...)`。。。。`CLbmPare &` 当作 `int`就清晰了

- `this`指针

  - 成员函数中 this 就是当前对象指针，解引用 `*this` 也就是获取当前对象
  - [`return this 和 return *this`](http://blog.csdn.net/stpeace/article/details/22220777)
    `return *this` 返回的是当前对象的克隆或者本身（若返回类型为 A， 则是克隆， 若返回类型为 A&，则是本身）
    `return this` 返回当前对象的地址（指向当前对象的指针)

- [`void _ func()` 和 `void(_) ()`的区别](https://zhidao.baidu.com/question/422255015.html)
  `void* fun();` //声明一个返回值是任意类型的指针的函数 fun()

- [函数参数为`void *`](https://www.jb51.net/article/36570.htm)

- 可以把 `void*` 理解成一个泛型，当你传参的时候再传入确定的类型的指针，
  这样可以在运行时为参数指配指针的类型。

- 不允许对 void 指针进行算术运算如 pvoid++或 pvoid+=1 等

- 允许任何类型的指针对 void*指针赋值；void*指针要赋值给其他类型时要通过强制类型转换

- 指向数组的指针：`int a[2]={1,23];int(*p)[2]=&a;`

- [assert expression](http://blog.csdn.net/xiaodoubao124/article/details/46804319)
  如果表达式 expression 的值为假则整个程序将退出，并输出一条错误信息。
  如果表达式的值为真则继续执行后面的语句。

- `.hpp` 和 `.h`

  - .hpp 是讲.cpp 的实现代码混入.h 文件中（定义与实现包含在一起），无需再将实现的代码加入到工程目录，可以直接编译到调用者的 obj 文件中
  - .h 是将定义和实现分开，然后经过预处理、链接、 编译完成

- [C++作用域为类的常量](http://blog.csdn.net/xuehuafeiwu123/article/details/72991110)

  > class 专属常量，为了将常量的作用域限制在类里，必须把它定义为类的成员
  > 而为了确保只有一份实体，又必须把他声明为 static 成员

  ```cpp
  // .h
  class GamePlayer{
  private:
     static cosnt int iNumTurns; // 常量**声明式**
     // enum{iNumTurns = 5} // the enmu hack
     int scores[iNumTurns]; // 使用该常量
     ...
  }
  // .cpp
  const int GamePlayer::iNumTurns = 5; // 定义式
  ```

- 因为我们处于声明阶段，类的声明只是描述一下类的形式，并不给数据成员分配任何值（可以想象函数声明来理解，只是告诉编译器，函数名字，参数的类型，几个参数，这都是来描述形式而已，并不会给参数赋值，类也是类似），真正给数据成员分配值是在用这个类创建一个对象的时候

- [`void *`](https://zhidao.baidu.com/question/422255015.html)
  [void 和 void 指针详解](http://blog.csdn.net/geekcome/article/details/6249151)

  ```c++
  void * fun() ; //声明一个返回值是任意类型的指针的函数fun()
  void vfun( ) ; //声明一个没有返回值的函数vfun()
  void (*)( )  这是一种变量类型，可用来定义函数指针变量，如：
  void (*pfun)( ) ; //声明一个函数指针变量pfun，该类型函数就是void vfun( ) 这种类型，pfun可以指向这类函数，如：pfun=vfun ;
  void * (*) (void *);
  // http://www.cnblogs.com/TenosDoIt/p/3164081.html
  // 这个不懂的话，是不是已经忘了函数指针了？但是为什么是(*)?
  // 函数指针 & typedef ？
  ```

- [重载运算符](http://www.cnblogs.com/sexybear/p/4551742.html)
  在进行对象之间的运算时。。。

  - [double &operator[](int i)与 double operator[](int i)const 区别](https://blog.csdn.net/hemingliang1987/article/details/9401749)
  - 运算符重载函数作为类成员函数还是非成员函数（友元函数）

  ```cpp
  class T{
    ...
    T & operator+(const T&op1); //const?
    friend T operator+(const T&op1, const T&op2);
  };
  T1=T2+T3; //即：
  T1=T2.operator+(T3); //成员函数
  // 调用成员函数时，第一个操作数必须是对象，因为第一个操作数还有调用成员函数的功能
  //（其中一个参数(T2)通过this指针隐式传递）
  T1=operator+(T2,T3); //非成员函数
  ```

  - 只有有效的 C++运算符才能重载，不能重载一个虚构的运算符

  - 有的运算符比较特殊，只能有上诉两种中的其中一种来定义

  - `operator+()` 重载+运算符

- [类的自动类型转化和强制转换](http://blog.csdn.net/lishuzhai/article/details/50814855)
  在运算符重载那里遇到,
  关键字 explicit 阻止隐式转换

  ```cpp
  operator double() { ... };

  // 重载双目运算符时，定义为友元可以让程序更容易适应自动类型转换---两个操作数都成为了函数参数，因此与函数原型匹配(就是有转换函数的意思)
  // 因为，如果操作数的类型不是当前类的类型，它可以通过 “转换函数” 转换为当前类的对象，再调用重载的运算符函数。
  ```

## 枚举 ENUM

```cpp
enum EN_FLOW_CTRL
{
    FC_N_MANDFIELD = 1,
    FC_U_MANDFIELD = 2,
    FC_D_MANDFIELD = 4
} m_enFlowCtrl;
```

- 枚举类型的定义、赋值

- 没有为枚举定义算术运算

- 取值范围

  - 找上下限方法: 找到最大/小的枚举值，再找到与这个枚举值最接近的 2 的幂

  - 上限:比如最大的枚举值是 101,最接近的幂是 128,所以上限就是 127

  - 下限:比如最小的枚举值不小于 0,则取值范围的下限为 0; 如果最小枚举值是-6,最接近的幂是-8，所以下限是 -7

- 枚举类型取值：`steps(1)` 发现枚举类型的 key 对应的 values 就是数字啊。。。

- 可以作为函数的返回值类型

## 变长参数`...`

> [变长参数`...`](https://blog.csdn.net/elloop/article/details/50092631)
> VA_LIST 是在 C 语言中解决变参问题的一组宏，变参问题是指参数的个数不定，可以是传入一个参数也可以是多个;可变参数中的每个参数的类型可以不同,也可以相同;可变参数的每个参数并没有实际的名称与之相对应，用起来是很灵活。

- 其实说是变长参数, 但实际上调用含变长参数的函数时，还是必须要知道有多少个的，只是参数个数可以随意多;用处大概在于不必要针对特定数量参数做重载了。

- 重载也可以同一函数名，参数列表不同，但是不可以任意数量的参数

- 变长参数函数的解析, 用到三个宏 `va_start, va_arg 和 va_end`，和一个类型 va_list;

- va_list 类型

  ```cpp
  va_list ap;
  // 定义 typedef char* va_list;
  // 只是一个指向char类型的指针。可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。
  ```

- va_start 宏

  ```cpp
  va_start(va_list ap, paramN);
  // 初始化可变参数列表（把函数在 paramN **之后**的参数地址放到 ap 中）。
  ```

- va_arg 宏

  ```cpp
  va_arg(ap, arg_type);
  // 取类型为arg_type的下一个值
  // 但是对于参数类型不止一种的例子呢 vsprintf
  ```

- va_end 宏

  ```cpp
  va_end(va_list ap);
  // 功能：关闭初始化列表（将 ap 置空）。
  ```

- [initializer_list](https://www.cnblogs.com/Blackops/p/6232289.html)、[- -](http://blog.csdn.net/fengxinlinux/article/details/72614874)

- https://zhidao.baidu.com/question/1047232262200698979.html

```cpp
void debugLog(const char * FileName, int Line, const char * msg, ...)
{
    FILE *fp;
    char ViewStr[4096] = { 0 };
    char bufStr[10240] = { 0 };
    char szOccurTime[32 + 1] = { 0 };
    // 效果和snprintf一样...
    va_list arg_ptr;
    va_start(arg_ptr, msg); // 获取可变参数列表
    vsprintf(ViewStr, msg, arg_ptr); // 格式化, 以兼容变长参数中有多个不同类型的参数
    va_end(arg_ptr); // 释放资源

    // 获取时间
    time_t timep;
    time(&timep);
    strftime(szOccurTime, sizeof(szOccurTime), "%Y-%m-%d %H:%M:%S", localtime(&timep));

    sprintf(bufStr, "[Time:%s][File:%s][Line:%d][%s]\n", szOccurTime, FileName, Line, ViewStr);

    fp = fopen("debug.log", "a+");
    if (fp == NULL)
    {
      printf("open file error\n");
      return;
    }
    fprintf(fp, "%s\n", bufStr);
    fclose(fp);
    printf("%s", bufStr);
    return;
}
```

- 运算符优先级

- 可如下记忆：

  记住一个最高的：构造类型的元素或成员以及小括号；

  记住一个最低的：逗号运算符；

  剩余的是单目、双目、三目和赋值运算符(赋值运算符包括=、+=、-=、\*=、/=、%=、……)。

  注意若有逗号表达式的是：a=(表达式 1，表达式 2，……，表达式 n)

- 一元运算符 `_` 和 自增运算符 `++` 结合时

  - 具有相等的优先级别，但是在运算时它是从右向左顺序进行的，即在 \_++p 中，++ 应用于 p 而不是应用于*p，实现的是指针自增 1，而非数据自增 1；后置自增++的优先级实际上比*高，但使用右结合方式得到的结果与之一致，故为了统一表述，都可以直接使用右结合方式。如*p++，使用优先级是先++后*，右结合也是先++后\*

- 为什么前缀自增自减运算符比后缀自增自减运算符效率高？
  答、：以自增运算为例，因为前缀运算符进行运算时是将值加 1，然后返回结果即可；但后缀版本首先复制一个副本作为返回值，然后才是原值加 1。因此，前缀版本的效率比后缀版本高。

- 系统调用和函数调用

- 运算符优先级

- 自增++

  ```cpp
  int a = 5; ++(a++) 值是多少?
  // ++ 是一目运算符，自增运算，它只能用于一个变量，不能用于表达式。
     ++(a++) 里，小括号优先; (a++) 是表达式，按运算规则，不能对表达式作自增运算.
  ```

- `"%02d"`

  ```cpp
  scanf("%02d, &a") // 只接受两位整数
  printf("%02d") // %2d要求输出数据为两位，大于两位则原样输出
  ```

- `system` 调用系统命令，返回码为 256 的倍数

  ```cpp
  cout << system("/path/to/exe_file") << endl;
  // 如果可执行文件退出码为 n，则system函数输出为 n * 256
  // 因为exe_file返回值是 system 返回值的8～15位
  // https://www.169it.com/tech-qa-linux/article-16068724669684610662.html
  ```

- 打印

  ```cpp
  #include<stdio.h>
  int main()
  {
      // 打印布尔
      bool a = true;
      printf("a is  %d\n", a);

      // 输出 `uint64_t` 变量
      uint64_t id;
      printf("% PRIu64", id);

      // 打印地址
      int i = 0;
      printf("add is  %p\n", &i);
      printf("test is %p\n", 0x00);
  }
  ```

- 除法

  ```cpp
  double a = 10;
  double b = 2;
  // 浮点数才有精度，如果是整形，只会得到商
  cout << a / b << endl;
  ```

- 火焰图

- `double free` 的危害

  程序中释放已经不属于自己的空间，而是非常危险的，比起内存泄露，重复释放是一个更加严重的问题。有可能你第二次释放的空间已经被别的程序所使用，所以 C/C++ 中视这种错误为致命错误，也就是说，我容许你局部的浪费，但绝对不容许你释放（使用）别人的东西

- `typedef`

  - [关于 typedef 的用法总结](http://blog.csdn.net/wangqiulin123456/article/details/8284939)

  - [typedef 与 指针连用](https://blog.csdn.net/zhanghaotian2011/article/details/7765650)`typedef int *ptf;` 指向 int 类型的指针

  ```cpp
  原：
  struct tagPOINT1
  {
    int x;
    int y;
  };
  struct tagPOINT1 p1;

  现：
  typedef struct tagPOINT1
  {
    int x;
    int y;
  }Point, *pPoint;
  Point p1; // 对比上面的写法简化了
  pPoint p2; // 表示所有指向该 struct 的指针
  ```

- 结构体

  ```cpp
  struct cl_ev_loop *loop;
  // 也可以不写 struct 关键字
  cl_ev_loop *loop;

  ```

- 结构体成员初始化

  ```cpp
  struct thread_notify_ops
  {
    void (*on_connect)(struct thread_notify *notify, int err, void *data);
    void (*on_recv)(struct thread_notify *notify, int err, int cnt, void *data);
  };

  /////////////////////////////////////////////////////////////////

  #if __cplusplus >= 201103L  //above C++11
  static struct thread_notify_ops worker_notify_ops =
  {
    .on_connect = on_worker_connection,
    .on_recv = on_recv_worker_notify,
  };
  #else
  static struct thread_notify_ops worker_notify_ops =
  {
    /*.on_connect = */on_worker_connection,
    /*.on_recv = */on_recv_worker_notify,
  };
  #endif
  ```
