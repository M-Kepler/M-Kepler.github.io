- [参考资料](#参考资料)
- [`CPP`](#cpp)
  - [语言基础](#语言基础)
    - [引用和指针的区别](#引用和指针的区别)
    - [`i++ / ++i` 是否为原子操作](#i--i-是否为原子操作)
    - [为什么浮点数有误差](#为什么浮点数有误差)
    - [为什么不用等于判断两个浮点数是否相等](#为什么不用等于判断两个浮点数是否相等)
    - [四种类型转换方式](#四种类型转换方式)
      - [`static_cast`](#static_cast)
      - [`const_cast`](#const_cast)
      - [`dynamic_cast`](#dynamic_cast)
      - [`reinterpret_cast`](#reinterpret_cast)
  - [结构体](#结构体)
    - [比较结构体是否相等](#比较结构体是否相等)
    - [结构体与联合体的区别](#结构体与联合体的区别)
    - [结构体和类的区别](#结构体和类的区别)
    - [结构体对齐 `sizeof`](#结构体对齐-sizeof)
    - [结构体为什么要对齐字节](#结构体为什么要对齐字节)
    - [柔性数组](#柔性数组)
  - [★ 关键字](#-关键字)
    - [说一说 `const`](#说一说-const)
    - [说一说 `constexpr`](#说一说-constexpr)
    - [说一说 `static`](#说一说-static)
      - [全局静态变量](#全局静态变量)
      - [局部静态变量](#局部静态变量)
      - [静态函数](#静态函数)
      - [类的静态成员](#类的静态成员)
      - [类静态成员函数](#类静态成员函数)
      - [隐藏](#隐藏)
    - [说一说 `extern`](#说一说-extern)
    - [说一说 `explicit`](#说一说-explicit)
    - [说一说 `mutable`](#说一说-mutable)
    - [说一说 `volatile`](#说一说-volatile)
      - [`volatile`能保证线程安全吗](#volatile能保证线程安全吗)
      - [`volatile` 内存屏障](#volatile-内存屏障)
    - [`const` 和 `#define` 的区别](#const-和-define-的区别)
    - [`typedef`和`#define`的区别](#typedef和define的区别)
    - [`inline`和`#define`的区别](#inline和define的区别)
    - [★ `new` 和 `malloc`](#-new-和-malloc)
      - [`new` 和 `malloc` 的区别](#new-和-malloc-的区别)
      - [`new` 和 `delete` 的原理分析](#new-和-delete-的原理分析)
      - [`malloc` 分配内存过程中什么时候是虚拟内存，什么时候是物理内存](#malloc-分配内存过程中什么时候是虚拟内存什么时候是物理内存)
      - [`malloc` 是怎么分配内存的](#malloc-是怎么分配内存的)
      - [`free` 怎么知道要释放多少内存](#free-怎么知道要释放多少内存)
      - [`free` 到底释放了什么](#free-到底释放了什么)
  - [★ 面向对象](#-面向对象)
    - [类](#类)
      - [类里面`static`和`const`可以同时修饰成员函数吗](#类里面static和const可以同时修饰成员函数吗)
      - [定义一个空类编译器做了哪些操作](#定义一个空类编译器做了哪些操作)
      - [哪些自动生成的构造函数需要禁止，为什么](#哪些自动生成的构造函数需要禁止为什么)
      - [★ 抽象类和纯虚函数](#-抽象类和纯虚函数)
    - [类的构造](#类的构造)
      - [拷贝构造函数的参数不是引用可以吗](#拷贝构造函数的参数不是引用可以吗)
      - [哪些情况用到拷贝构造函数](#哪些情况用到拷贝构造函数)
      - [深拷贝在哪些场景下用到](#深拷贝在哪些场景下用到)
      - [析构函数的作用](#析构函数的作用)
      - [内联函数和成员函数的区别](#内联函数和成员函数的区别)
      - [对象三种创建方式](#对象三种创建方式)
    - [权限](#权限)
      - [访问权限和继承权限](#访问权限和继承权限)
      - [友元](#友元)
    - [多态](#多态)
      - [★ 多态实现方式](#-多态实现方式)
      - [编译时多态](#编译时多态)
      - [运行时多态](#运行时多态)
      - [引用是否能实现动态绑定，为什么引用可以实现](#引用是否能实现动态绑定为什么引用可以实现)
    - [虚函数](#虚函数)
      - [虚函数的作用是什么，虚函数的实现原理是什么](#虚函数的作用是什么虚函数的实现原理是什么)
      - [★ 什么是虚函数表，虚函数表的内存结构布局如何](#-什么是虚函数表虚函数表的内存结构布局如何)
        - [虚函数表存在哪里](#虚函数表存在哪里)
        - [单继承、多继承下的虚函数表](#单继承多继承下的虚函数表)
        - [为什么说虚函数表并不安全](#为什么说虚函数表并不安全)
      - [哪些函数不可以作为虚函数](#哪些函数不可以作为虚函数)
      - [父类指针子类指针关系](#父类指针子类指针关系)
        - [★ 子类指针可不可以指向父类对象呢](#-子类指针可不可以指向父类对象呢)
        - [父类指针怎么调用子类的虚函数，调用流程是什么](#父类指针怎么调用子类的虚函数调用流程是什么)
        - [父类指针指向子类对象，指向的是哪张虚函数表](#父类指针指向子类对象指向的是哪张虚函数表)
      - [虚函数的入口地址和普通函数有什么不同](#虚函数的入口地址和普通函数有什么不同)
      - [纯虚函数](#纯虚函数)
      - [★ 虚函数和纯虚函数的区别](#-虚函数和纯虚函数的区别)
      - [为什么父类析构函数要声明为虚函数](#为什么父类析构函数要声明为虚函数)
      - [为什么默认的析构函数不是虚析构](#为什么默认的析构函数不是虚析构)
      - [为什么构造函数不声明为虚函数](#为什么构造函数不声明为虚函数)
    - [虚父类的作用，可以不要虚父类吗](#虚父类的作用可以不要虚父类吗)
  - [内存](#内存)
  - [其他](#其他)

# 参考资料

- [C++ 后台开发面试时一般考察什么](https://mp.weixin.qq.com/s/Mes6E_eA5ffBjnrXAEXvgw)

- [C++11 常用新特性快速一览](https://blog.csdn.net/jiange_zh/article/details/79356417)

- [C/C++ 面试基础知识总结](https://github.com/huihut/interview)

- [剑指 Offer ——名企面试官精讲典型编程题](https://github.com/gatieme/CodingInterviews)

- [CS-Notes`](https://cyc2018.github.io/CS-Notes/#/README)

- [Skill-Tree](https://github.com/linw7/Skill-Tree)

- [C++基础（笔记）](https://blog.csdn.net/xiongchao99/article/details/64441017)

- [C++面试常见问题](https://blog.csdn.net/u012864854/article/details/79777991)

- [常见 C++面试题及基本知识点总结（一）](https://www.cnblogs.com/LUO77/p/5771237.html)

- [轻松搞定面试中的链表题目](https://blog.csdn.net/luckyxiaoqiang/article/details/7393134)

- [轻松搞定面试中的二叉树题目](https://blog.csdn.net/luckyxiaoqiang/article/details/7518888)

- [C/C++内存管理详解](https://chenqx.github.io/2014/09/25/Cpp-Memory-Management)

- [大数据算法](https://www.cnblogs.com/xzwblog/p/7127362.html)

- [海量数据处理之经典实例分析](https://segmentfault.com/a/1190000000510258)

# `CPP`

## 语言基础

### 引用和指针的区别

- `内存`

  引用只是个符号，不占用空间，指针则要分配空间

  ```cpp
  // 占内存大小

  sizeof(引用) = sizeof(原变量);

  sizeof(指针) = 4 (32位机器上)
  ```

- `初始化`

  指针可以为空，但是引用不可以为空

- `使用`

  引用在定义的时候必须初始化，而且初始化之后就不许修改了，指针则可以随时改变指向

### `i++ / ++i` 是否为原子操作

> 都不是

- 操作系统原子操作是不可分割的，在执行完毕不会被任何其它任务或事件中断，分为两种情况（两种都应该满足）

  - 在单线程中， 能够在单条指令中完成的操作都可以认为是" 原子操作"，因为中断只能发生于指令之间。
  - 在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。

- `i++`

  ```
  // 分为三个阶段, 这三个阶段中间都可以被中断分离开
  1. 内存加载到寄存器
  2. 寄存器自增
  3. 写回内存
  ```

- `++i`

  在多核的机器上，cpu 在读取内存 i 时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。

### 为什么浮点数有误差

> 十进制小数转换为二进制过程中出现了误差
> 对于小数部分转换后出现无限循环的部分，计算机只保存了有限位

- 十进制小数转化为二进制方法

  整数部分 `连除2取余，倒序排列`，小数部分`连乘2取整，正序排列`

  ```
  例如：将十进制数值`42.65`转换为二进制数值，步骤如下：
  42(整数部分)
  42/2=21......0
  21/2=10......1
  10/2=5 ......0
  5/2=2  ......1
  2/2=1  ......0
  1/2=1  ......1
  (42) 10=(101010) 2
  // 10进制42用2进制，连除取余结果倒序排列

  0.65(小数部分)
  0.65*2=1.3......1
  0.3*2=0.6 ......0
  0.6*2=1.2 ......1
  0.2*2=0.4 ......0
  0.4*2=0.8 ......0
  0.8*2=1.6 ......1
  0.6*2=(重复上述循环了)
  (0.65) 10=(0.101001...) 2

  (42.65) 10=(101010) 2+(0.101001...) 2=(101010.101001...) 2
  ```

- `IEEE`标准

  `IEEE`标准规定，单精度浮点数共 32 位，`23位小数f`，8 位偏置指数 e，1 位符号 s；同理，`double类型有52位`可以存放小数

- 总结

  上面将 0.65 转换出的二进制代码，计算机只能存储 23 位，所以后面`超出23位以后的都被忽略掉了`的

### 为什么不用等于判断两个浮点数是否相等

> `计算机本质是二进制，通过浮点表示小数，都是模拟出来的`， `float` 和 `double` 都不能保证可以把所有实数都准确的保存在计算机中，采用`==`运算符是不可行的

- 浮点数大小比较为什么不能用 `==`

  - 浮点数精度不同，同一小数，但用不同精度表示时，结果不一样

    ```cpp
    float a = (float) 0.1;
    float b = (double) 0.1;
    ```

- 可以通过求绝对值的差值和精度作比较来判断是否相等

  ```cpp
  const double eps = 1e-6;
  if (fabs(double_a - double_b) < eps)
  {
    ...
  }
  ```

### 四种类型转换方式

> - [C++中的四种类型转换方式](https://www.cnblogs.com/carsonzhu/p/5251012.html) > `const_cast`、`static_cast`、`dynamic_cast`、`reinterpret_cast`

- C 风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：`TYPE b = (TYPE)a`

  常见的(type)类型转换是 C 语言中的类型转换方式，其有很多缺陷如：容易产生两个不可互相转换的类型被转换，从而引发错误等等

- 有的时候用 c 风格的转换是不合适的，因为它可以在任意类型之间转换

  - 比如你可以把一个指向 const 对象的指针转换成指向非 const 对象的指针; 比如：`char* test = (char*) string.c_str();`

  - 把一个指向父类对象的指针转换成指向一个子类对象的指针，这两种转换之间的差别是巨大的; 但是传统的 c 语言风格的类型转换没有区分这些

#### `static_cast`

C++ 内置数据类型转换，如把 int 转换为 float

```cpp
int i;
float f;
// C 语言的方式
f = (float) i;

// 或者用 C++ 类型转换模式：
f = static_cast<float>(i);
```

#### `const_cast`

去掉 const 属性，把 const 类型的指针变为非 const 类型的指针，只能作用于引用或指针; 编译器执行

```cpp
const int *fun(int x,int y){};

int *ptr = const_cast<int *>(fun(2, 3));
```

#### `dynamic_cast`

含虚函数的`【类】`，主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换，`有【类型检查】功能`

- 父类中`一定要有虚函数`(因为是运行时转换，没有虚函数就是静态绑定了)，否则编译不通过

- 其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查；不能用于内置的基本数据类型的强制转换

- 转换如果成功的话返回的是 `指向类的指针或引用`，转换失败的话则会返回 `NULL`

- 通常在它被用于安全地沿着类的继承关系向下进行类型转换，但是被转换类必须是多态的，即必须含有虚函数

- 在进行`上 / 下行转换`时（如父类指针转为子类指针），`dynamic_cast` 具有`【类型检查】`功能，比 static_cast 更安全，如：父类指针转子类指针正常，反过来则异常

  ```cpp
  Base* pb = new Driver;   // 父类指针指向子类对象
  Driver* pd = dynamic_cast<Driver*>(pb); // 下行转换，父类指针转为子类指针
  Base* pb2 = new Base;
  Driver* pd2 = dynamic_cast<Driver*>(pb2); // error 上行转换，不能把子类指针转成父类对象
  ```

  如：`dynamic_cast<T*> (new C);`其中类 C 必须含有虚函数，否则转换就是错误的；

#### `reinterpret_cast`

> interpret 是解释的意思，reinterpret 即为重新解释

可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针

```cpp
int i;
char *ptr = "hello freind!";
i = reinterpret_cast<int>(ptr);
```

## 结构体

### 比较结构体是否相等

- 不能直接用 `==` , 该操作符不能比较自建类型

- 不能用 `memcpy` , 因为 `memcpy` 是逐字节比较的, 而结构体对齐时，`填充的字节是随机的`

- 可以通过重载 `==` 来实现，或者写一个成员函数

  ```c++
  struct s
  {
      int a;
      int b;
      bool operator == (const s &rhs);
  };

  bool s::operator == (const s &rhs)
  {
      // 这里并不像类那样，用 this.a
      return ((a == rhs.a) && (b == rhs.b));
  }
  ```

### 结构体与联合体的区别

> 联合体所有成员共用一块内存、结构体为所有成员都分配内存

- 结构和联合都是由多个不同的数据类型成员组成

  在任何同一时刻, `联合中只存放了一个被选中的成员（所有成员共用一块地址空间）`,结构的所有成员都分配空间（不同成员的存放地址不同）。

- 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

### 结构体和类的区别

[C 语言中的结构体和 C++ 中的结构体以及 C++ 中类的区别](https://www.cnblogs.com/cheng-ming/p/5036611.html)

> 默认【访问权限、继承权限】不同，类默认是 `private`， 结构体则是 `public`

- C++ 中的 struct 对 C 中的 struct 进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能

  - struct 能包含成员函数吗？ 能

  - struct 能继承吗？ 能

  - struct 能实现多态吗？ 能

- 既然这些它都能实现，那它和 class 还能有什么区别

  - 若不指明，结构体成员的默认属性是 `public` 的，类成员的默认属性是 `private` 的

  - 若不指明，结构体成员的默认继承权限是 `public` 的，类成员的默认继承权限是 `private`的

### 结构体对齐 `sizeof`

> 静态成员、成员函数不计入类大小

- 结构体大小计算

- 位域

  ```cpp
  struct s
  {
      // 表示 char a 只占一个字节中的低 3 位
      char a:3;
      int b;
  };
  ```

- 类的大小计算

  - 类的存储大小 `sizeof` 运算也可以当做结构体来计算

  - 注意函数声明不占内存; 静态成员分配在全局区, 也`不计入类大小`，`this` 指针不是对象本身的一部分，也不计入

  - `空类`会有一个字节做标记

  - 有虚函数的类, 会包含一个虚函数指针的大小；不论这个类有多少个虚函数都是只有一个虚函数指针

  - 如果父类有虚函数, 子类也有虚函数, 则子类大小 = 父类大小 + 子类大小 + `一个虚函数指针`(因为子类的虚函数被放到了第一个父类的虚函数表表中, 在没有重写的情况下）

  - 要注意继承问题：比如子类继承父类，那么： 子类大小=父类成员（不包括静态成员）+自己本身

- 修改默认对齐数 `#param pack(4)`

### 结构体为什么要对齐字节

> - 平台移植、访问效率、节省空间
> - [结构体为什么要 4 字节对齐？](https://blog.csdn.net/yilese/article/details/76199869?locationNum=9&fps=1)
> - [C/C++字节对齐，以及为什么要对齐？](http://blog.sina.com.cn/s/blog_455b20c10100g01z.html)

- `提高访问效率`

  如果不对齐，一个变量可能一部分在前一个字节，后一部分在后一字节；所以对齐可以避免一个变量要读两次

- `平台移植`

  就像上面说的，如果分在两个字节中，`cpu要读取两次，但是不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址(如偶数地址)处取某些特定类型的数据`，否则抛出硬件异常

- `节省存储空间`

  因为要对齐，编程时可以合理安排成员的顺序达到节省空间的目的

### 柔性数组

- 在结构体末尾声明`零长数组`

  - 对编译器来说，此时长度为零的数组并不占用空间，因为数组名本身不占空间，它`只是一个偏移量`

  - 数组名这个符号本身`代表一个不可修改的地址常量` （注意：数组名永远都不会是指针！）；但对于这个数组的大小，我们可以进行动态分配

  ```cpp
  typedef struct FlexiableStruct
  {
      int a;
      // 或 char array[];
      char array[0];
      // 定义零长数组,只是把一个符号放在结构体内, 不占用内存
  }stFlexiable, *pstFlexiable;

  // 给柔性数组申请空间
  char szStr[] = "huangjinjie";
  pstFlexiable p_stFlexiable = (pstFlexiable)malloc(sizeof(stFlexiable) + strlen(szStr) + 1);
  ```

- 动态申请的内存只是申请给数组拓展所用，结构体的大小在创建时已经确定了；零长数组 array 明确来说不算是结构体成员，只是挂羊头卖狗肉而已，这样的变长数组常用于网络通信中构造不定长数据包，不会浪费空间浪费网络流量

## ★ 关键字

### 说一说 `const`

> 变量、函数名前、函数名后、函数参数

- `const 修饰变量(包括指针)`

  **把 `*` 到 `p` 用括号括起来就清楚了，括号外是变量类型，星号内是变量（存的是地址），星号 + 变量 = 取地址的值**

  ```cpp
  const int a = 10;

  /* 表示 *p 的值不允许改变*/

  // *p = 100; // error;
  // int b = 20; p = &b; // ok
  // const int *p = 10;
  const int (*p) = 10;

  /* p 存放的地址不允许改变 */

  // 所以初始化的时候要给他一个初值，表示p的地址不允许改变
  // int d = 20; p = &d // error;
  // c = 20; //ok
  int c = 10;
  // int * const p = &c;
  int (* const p) = &c;
  ```

- `const 修饰函数参数`

  ```cpp
  // const char* ptr;  --> const char (*ptr); // 指针指向的变量为常量
  // char *const ptr;  --> char (* const ptr); // 指针本身是常量
  char* strcpy(char* dst, const char* src); // 防止src在strcpy函数内部被改变
  ```

- `const 修饰函数返回值`

  ```cpp
  // 防止函数返回值被改变
  const int get();
  ```

- `const 修饰类成员函数`

  ```cpp
  /* 只可以用于类成员函数, 表示get()函数仅可访问类成员变量, 但是不可以改变类成员变量 */

  // 非const对象也可以调用const成员函数
  // 常对象（如 const A a(10);）,只能调用const 成员函数，因为get()函数隐含了一个const this*指针
  int get() const;
  ```

- `const 修饰类对象`

  ```cpp
  /* 类对象只能调用该对象的 const 成员函数 */

  class A
  {
      void func() const;
  };
  const A a;
  a.func();
  ```

### 说一说 `constexpr`

> c++11 新引入的关键字，用于编译时的常量和常量函数

- `const` 和 `constexpr` 都代表只读；`const` 只表示 `read only` 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量；`constexpr` 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变

- `constexpr` 可以用于修饰函数，`这个函数的返回值会尽可能在编译期间被计算出来当作一个常量`，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理

  ```cpp
  #include<iostream>
  using namespace std;

  constexpr int func(int i)
  {
    return i + 1;
  }

  int main()
  {
    int i = 2;
    func(i);  // 普通函数
    func(2);  // 编译期间就会被计算出来
  }
  ```

### 说一说 `static`

> 存储在哪、生命周期、作用域

说到底还是 **作用域** 的问题，类内的静态成员，和类外没啥区别，只是说作用域在类内而已，就像 Python 的静态类成员

#### 全局静态变量

- 全局变量存储在静态区，整个程序运行期间都一直存在；生命周期随程序。

- 未经初始化的全局静态变量会被自动初始化为 0

- 被 static 修饰的全局变量作用域 `只能被该包含该定义的文件访问`

#### 局部静态变量

- 作用域只限制于`其所在的函数中`

- 和全局静态变量一样，存储在静态区，生命周期与程序相同

  当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。

#### 静态函数

- 使函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。

- 静态函数的定义和声明在默认情况下都是 extern 的，但 `静态函数只是在声明他的文件当中可见`，不能被其他文件所用，也不会与其他 cpp 文件中的同名函数引起冲突

#### 类的静态成员

- 使成员成为类的全局变量，会 `被类的所有对象共享（包括子类的对象）, 所有的对象都只维持同一个实例，只存储一份`

- static 成员必须在类外进行初始化（初始化格式：`int Test::var=10;`），而不能在构造函数内进行初始化

- 也可以用 const 修饰 static 数据成员在类内初始化。 静态成员变量在构造类之前就存在了，所有类对象只有一份拷贝

#### 类静态成员函数

- 和类的静态成员一样；使类内只存在这一份函数，所有对象共享该函数，不含 this 指针，因而只能访问类的 static 成员变量

- 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名

- 只可以访问 static 成员，因为没有 this 指针（所以也不能声明为虚函数）

#### 隐藏

用 static 修饰的变量或函数仅在本文件内有效，所以用 static 可以在不同文件中定义相同名称的变量或函数

### 说一说 `extern`

- `extern int g_Int;` 作用是声明函数或全局变量的作用范围的关键字，`声明的函数和变量可以在本模块或其他模块中使用，不能重复初始化`

- 声明函数的时候使用 `extern "C" {void fun(int a,int b);}` 可以让编译器按照 C 语言的方式生成函数的符号

### 说一说 `explicit`

[explicit 关键字](https://blog.csdn.net/qq_35524916/article/details/58178072)

[C++中`explicit`关键字的使用](https://www.cnblogs.com/gklovexixi/p/5622681.html)

> - 防止隐性转换和拷贝初始化
> - 自动转换的隐式转换，有时候会带来一些难以发现的问题。为了保险，可以使用显式转换，比如通过 explicit 来限定转换函数。
> - 类构造函数默认情况下声明为隐式的即 `implicit`（英语隐式的意思，explicit 是显式的意思）

- 用来修饰类的构造函数，`被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换`

- 只能用于修饰`只有一个参数的类构造函数`或者，有 n 个参数，n-1 个是默认参数的情况

- 如 AAA = xxx，这样的代码，且恰好 xxx 的类型正好是 AAA 单参数构造的参数类型，这时候编译器就自动调用这个构造器，创建一个 AAA 的对象． 使用 explicit 声明构造函数，则可防止隐式转换，避免上述情况的发生

  ```cpp
  Class A
  {
     A(int a);
     // explicit A(int a);
  }

  A a;
  a = 10; // 会默认构造
          // 带explicit关键字则会无效，必须要显示做转换
          // A = A(10); 或者 a = (A)10;
  ```

### 说一说 `mutable`

> 如果某成员变量允许在 `const成员函数内更改`，可用 `mutable` 修饰

- mutable 也是为了突破 const 的限制而设置的，二者作用相反

- 被 mutable 修饰的变量(mutable 只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个 const 函数中。

### 说一说 `volatile`

`volatile int test;` 指每次都强制从内存中读取数据，而不是从编译器优化后的缓存中读取数据，`简单来讲就是防止编译器优化`。

- 如果不用该关键字修饰，编译器有可能会`先把数据从内存加载到寄存器，然后再到用户空间`，而用它声明的类型变量，编译器对访问该变量的代码就不再进行优化，`当使用 volatile 时系统总是重新从它所在的内存读取数据`。

- volatile 关键字保证了在多线程环境下，被修饰的变量在别修改后会马上同步到主存，这样`该线程对这个变量的修改就是对所有其他线程可见的`；其他线程能够马上读到这个修改后值

#### `volatile`能保证线程安全吗

[`volatile` 能保证线程安全吗](https://blog.csdn.net/qq_43401808/article/details/86540962)

- `volatile` 解决的是多线程间共享变量的`可见性`问题，而`保证不了多线程间共享变量原子性问题`

- 在单任务环境中，如果在两次读取变量之间不改变变量的值

  编译器就会发生优化，会将 RAM 中的值赋值到寄存器中；由于访问寄存器的效率要高于 RAM，所以在需要读取变量时，直接寄存器中获取变量的值，而不是从 RAM 中。

- 在多任务环境中，虽然在两次读取变量之间不改变变量的值

  在一些情况下变量的值还是会发生改变，比如在发生中断程序或者有其他的线程。这时候如果编译器优化，依旧从寄存器中获取变量的值，修改的值就得不到及时的响应（在 RAM 还未将新的值赋值给寄存器，就已经获取到寄存器的值）。

#### `volatile` 内存屏障

- CPU 有可能会把响应代码的 CPU 指令进行一次`重排序`，这虽然能提高运行的效率；但是也可能会影响一些数据的可见性

- volatile 关键字通过`内存屏障` 这个指令，来保证响应代码块的执行顺序。

- 内存屏障还会强制更新一次 CPU 缓存，加载最新内容

### `const` 和 `#define` 的区别

- const 常量有数据类型, 而宏常量没有数据类型。编译器可以对前者进行`类型安全检查`。 而 define 只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

- 有些集成化的调试工具可以对 `const 常量进行调试`，但是不能对宏常量进行调试。

- `#define` 是在`预处理`阶段进行替换，const 会在`编译阶段`替换, 会做安全检查, define 只是简单地做替换;

### `typedef`和`#define`的区别

> 类型别名与宏的三点区别，如`typedef char* MYTYPE; 和#define MYTYPE char *`两句：

- 前者是类型别名，要做`类型检查`，后者只是一个替换，不做类型检查；
- `前者编译时处理，后者预编译时处理`，即预编译期间替换掉宏；
- 前者能保证定义的全都是 char\* 类型，String_d 却不能;

### `inline`和`#define`的区别

- 区别在于，宏是由`预处理器`对宏进行替代，而内联函数是通过`编译器`控制来实现的
- 内联函数是真正的函数，只是在需要用到的时候，`内联函数像宏一样的展开`，所以取消了函数的参数压栈，`减少了调用的开销`。你可以像调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题

### ★ `new` 和 `malloc`

#### `new` 和 `malloc` 的区别

[细说 new 与 malloc 的 10 点区别](https://www.cnblogs.com/QG-whz/p/5140930.html)

**性质**

- `new` 是操作符，操作符可以进行重载

- `malloc` 是库函数

**使用方法**

`new = malloc + 构造函数`

- `new` 在对象创建的同时会`【自动计算大小、自动执行构造函数】`做初始化，在对象在消亡时会自动执行析构函数；在自由存储区分配内存。

- `malloc` 只管分配内存，`需要指定申请空间的大小`，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的；在栈区分配内存。

**申请成功时**

new 成功后返回对象类型的指针，`malloc` 返回 `void *` 指针，需要自己做类型转换

**申请失败时**

[处理 new 分配内存失败情况](http://blog.chinaunix.net/uid-24517549-id-4080530.html)

`new` 抛出异常，`malloc` 返回 `NULL`，所以用 `new` 之后在判断是否为 `NULL` 没什么意义

- `nothrow` 强制 new 不抛出异常，此时会返回空指针

  ```cpp
  int *p = new (std::nothrow) int[1000000000];
  if (p == NULL)
  {
      cout << "bad alloc" << endl;
  }
  ```

**扩容**

- `new` 不支持扩容

- `malloc` 在使用过程中发现内存不够可以使用 `realloc` 来进行扩容

#### `new` 和 `delete` 的原理分析

- [NEW/DELETE 与 NEW[]/DELETE[] 实现机制](https://blog.csdn.net/zpznba/article/details/89676271)

- [new[]和 delete[]一定要配对使用吗](https://mp.weixin.qq.com/s/4zqDOvhnnNKlqNhNrCX0WA)

**`new`**

- 先底层调用 `malloc` 分了配内存，然后调用`构造函数`创建一个对象

- 简单类型直接调用操作符 new `分配内存`；而对于复杂结构，先调用操作符 new 分配内存，然后在分配的内存上`调用构造函数`

**`new[]`**

- 对于简单类型，`new[]` 计算好大小后调用操作符 new

- 对于复杂类型，先调用操作符 `new[]` 分配内存，然后在 `p` 的`【前 4 个字节写入数组大小 n，然后调用 n 次构造函数】`，针对复杂类型，会额外存储数组大小；

**`delete`**

- `先调用析构函数`（清理资源），然后底层调用 `free` 释放空间

- 简单数据类型默认只是调用 `free` 函数

- 复杂数据类型`先调用析构函数再调用操作符 delete`

**`delete[]`**

- 针对简单类型，`delete` 和 `delete[]` 等同

- 指针 `p` 指向 `new[]` 分配的内存。因为要 `4` 字节存储数组大小，实际分配的内存地址为 `[p-4]`，系统记录的也是这个地址，所以 `delete[]` 实际释放的就是 `p-4` 指向的内存。

- 而 `delete` 会直接释放 `p` 指向的内存，这个内存根本没有被系统记录，所以用 `delete` 释放 `new[]` 申请的内存时会崩溃

**`new[]` 和 `delete[]` 一定要配对使用吗**

- 对于内置类型，`new、delete、new[]、delete[]` 可以不配对使用

- 对于自定义类型，`new、delete 和 new[]、delete[]` 需要配对使用

- 当然为了避免出问题，最好配对使用 `new/delete`，`new[]/delete[]`，`malloc/free`

#### `malloc` 分配内存过程中什么时候是虚拟内存，什么时候是物理内存

[动态内存申请（malloc, calloc, new）之分配虚拟内存空间和物理内存空间](https://blog.csdn.net/weixin_36623563/article/details/107346381)

用 `malloc` 或 `new` 申请较大动态分配堆内存时（没有初始化操作），**仅仅申请到虚拟地址空间，并不实际获得物理内存空间**，因此实际的物理内存并没有消耗，

只有应用进程 **访问虚拟地址空间时**，才会触发【缺页异常】，才会导致内核实际去分配物理内存`，并更新页表映射关系

#### `malloc` 是怎么分配内存的

- [malloc 是如何分配内存的](https://www.cnblogs.com/ysdu/p/4763077.html#_labelTop)

- 从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存

- 操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就 `【寻找第一个空间 大于 所申请空间的堆结点】，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序`

#### `free` 怎么知道要释放多少内存

> - 现在的编译器大多使用两种方法，
>   - `一种是 cookie`, 一个记录分配空间大小的内存小块绑定在分配内存的地址头部
>   - 二是`使用表来对分配了的指针进行管理`，每一个分配了空间的指针都在表中对应着分配空间的大小
> - malloc 申请的时候`【除了需要申请的内存大小外，还会申请一个空间来管理这块内存】`，这个空间就包含了内存的大小

[C 语言中 free 函数是如何确定要释放多少内存空间的](https://www.cnblogs.com/hezhixiong/p/4535534.html)

- Linux 里面 glibc 在分配内存的时候`会在内存块的地址前面的 4 个字节出存放内存块的大小`，这里面存放了申请的空间大小

- 系统在分配内存时除了分配指定的内存空间外，`还有分配用于保存内存空间大小等信息`。所以内存释放时不再需要再指定释放多大的内存空间，只需要指定该块内存空间的首地址即可。

#### `free` 到底释放了什么

[FREE 之后将指针置为 NULL](https://www.cnblogs.com/chenyang920/p/6692332.html)

`free(p) 释放的是指针指向的内存空间，原来指向这块空间的指针还是存在的`（指针是变量，程序结束时才会被销毁）！此时原本指向刚刚释放掉了空间的指针 p 仍然指向了该内存空间，这样一旦这段内存已经被别的变量使用的话，就可能误用 p 来修改这里的值，这不是我们所期望的，所以 `free(p)` 之后一定要将 `p = NULL;`，这样就万无一失了。因此，释放内存后把指针指向 NULL，防止指针在后面不小心又被引用了。非常重要啊这一点！

```cpp
/**
 * 释放空间（只是做个标志位，表示p所在的空间 操作系统可以用了，
 * 没释放之前，使用权给了p；所以把p赋值为NULL。
 * 没把指针赋值为NULL, 指针仍指向那块内存
 */
free(p);

// 悬空指针：当所指向的对象被释放或者收回，但是没有让指针指向 NULL
p = nullptr;
```

## ★ 面向对象

### 类

#### 类里面`static`和`const`可以同时修饰成员函数吗

- 不可以同时用 const 和 static 修饰成员函数

- C++编译器在实现 const 的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数`const this*`。但当一个成员为 static 的时候，该 `static函数是没有this指针`的。也就是说此时 const 的用法和 static 是冲突的。

#### 定义一个空类编译器做了哪些操作

如果只是声明一个空类，不做任何事情的话，编译器会自动为你生成 `默认构造函数、默认拷贝构造函数、默认拷贝赋值操作符和默认析构函数`。这些函数只有在第一次被调用时，才会被编译器创建。所有这些函数都是 inline 和 public 的。

#### 哪些自动生成的构造函数需要禁止，为什么

> **拷贝构造函数 和 赋值构造函数**，因为这些都是【浅拷贝】；cpp11 中提供了移动构造和移动赋值来优化这个问题

```cpp
A();

// 拷贝构造函数
A(const A&);

// 赋值构造函数
A& operator = (const A& a);

~A();
```

**为什么**

因为默认生成的这两个函数进行拷贝的时候都是进行`浅拷贝`, 如果类的成员中有指针的话，`浅拷贝方式的结果是只拷贝了变量, 没有重新分配内存`，导致两个不同对象的指针指向同一块内存区域，容易出现访问冲突，比如多次 delete 等错误

**怎么禁止**

- `A(const A&) = delete;` 表示删除默认拷贝构造函数，即不能进行默认拷贝

- 自定义拷贝构造函数，会覆盖自动生成的那个

#### ★ 抽象类和纯虚函数

> 带有纯虚函数的类为抽象类，它不能实例化；如果实现了纯虚函数，就不再是抽象类。

- 如果一个类中`含有纯虚函数则称为抽象类`，而只含有虚函数的类不能被称为抽象类

- 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类是必须用作派生其他类的父类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

- 定义纯虚函数是为了 `继承体系定义一个统一的接口，起到一个规范的作用，为子类提供操作接口的通用语义`，规范继承这个类的程序员必须实现这个函数

  比如动物类，它是一个类别的抽象（`抽象类`），没有实际意义；而像马、牛这样实实在在的生物，他们属于动物这个类别。这些动物都有一个属性就是[会动]，那这个属性就可以看成是动物这个类的纯虚函数，但不同的动物动的方式不一样，所以这个属性应该由马、牛这些子类去做具体的实现

  在很多情况下，父类本身生成对象是不合情理的。为了解决这个问题，方便使用类的多态性，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：`virtual ReturnType Function()= 0;`）`纯虚函数不能在父类中实现`，编译器要求在子类中必须予以重写以实现多态性。

- 抽象类只能作为父类来使用(`比如动物不是实实在在的一个实体`)，而继承了抽象类的子类如果没有实现纯虚函数，而只是继承纯虚函数，那么该类仍旧是一个抽象类(`比如马是动物的一种, 但马还可以分不同品种`)，抽象类不能生成对象(`比如动物, 只知道它会动, 但不知道怎么动, 这个对象也就没实际意义`)

### 类的构造

#### 拷贝构造函数的参数不是引用可以吗

不可以，`参数【默认传递方式是值传递(拷贝)】`，所以调用拷贝构造的时候又去找拷贝构造函数，造成循环调用，直至函数栈溢出，编译是编译不通过的。

```cpp
A a1(1);

// 这里传参调用了拷贝构造
A a2(a1);
```

#### 哪些情况用到拷贝构造函数

> 对象初始化、函数参数的传递、函数的返回值

- `用一个对象来【初始化】另一个对象`

  ```cpp
  Account ac2(ac1);
  ```

- `当对象作为 【函数实参】传递给函数形参`

  ```cpp
  fun(Account ac1) {}
  ```

- `当对象作为函数的【返回值】，创建一个临时对象`

  ```cpp
  Account add(Account &x) {}
  ```

#### 深拷贝在哪些场景下用到

深浅拷贝函数定义都一样，实际区分深浅拷贝的是这个拷贝函数的实现

如果实现中只是赋值的操作，没有出现 **`内存的拷贝`** 的话，那就是浅拷贝。

对于深拷贝，针对成员变量存在指针的情况，**不仅仅是简单的指针赋值，而是分配新的内存空间**

#### 析构函数的作用

用来 `释放所定义的对象中使用的指针、或者做一些事后的清理工作`，默认的析构函数不用显示调用，自建的析构函数要在程序末尾调用。

**默认析构**

- 如果类里面只用到的基本类型，如 int char double 等，系统的默认析构函数其实什么都没有做

- `如果使用了其他的类如 vector，string 等，系统的默认析构函数就会调用这些类对象的析构函数`

**自定义的析构**

- 如果 `动态申请了内存`，析构函数中需要进行释放

- 如果 `打开了文件`，析构函数中也要进行关闭

#### 内联函数和成员函数的区别

既然内联函数可以节省函数调用的开销, 为什么不把所有的函数都声明为内联函数

如果程序在 10 个不同的地方调用同一个内联函数，则该程序将包含该函数代码的 10 个副本，会`消耗更多空间`，所以作为内敛函数的`运行时长越短越好`（因为会展开，所以`【含有递归调用的函数不能设置为内联函数】`）

#### 对象三种创建方式

[C++用 new 创建对象和不用 new 创建对象的区别解析](http://www.cnblogs.com/GODYCA/archive/2013/01/10/2854777.html)

```cpp
// 方式一：栈中分配
A a(1);

// 方式二：栈中分配
A b = A(1);

// 方式三：堆中分配 1. 内存分配在堆中; 2. 用new会自动调用构造函数
A* c = new A(1);
```

### 权限

#### 访问权限和继承权限

- 三种继承方式`不影响子类对父类的访问权限`，子类对父类只看父类的访问控制权

- 继承方式是 `为了控制子类的调用方对父类的访问权限`

  - 相当于控制怎么继承父类的成员后，子类对这些成员的访问权限

  - 如果不想让任何人（包括外人和自己的亲子）知道自己继承了什么，这就叫 private 基础

  - 如果不想让`外人`知道继承了什么，但可以让自己的`儿子`知道，这就叫 protected 方式

  - 如果你大大方方地继承你父类的东西，不怕被外人看到，这就叫 public 继承

#### 友元

`friend int func(int arg);` 友元函数；`friend class CA;` 友元类

- 通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员（那也就是说可以访问所有成员了）。

- 友元函数是可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，`不属于任何类`，但是需要在类的定义中加以声明。

- 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。

- 友元关系`不能被继承`。

- 友元关系是`单向`的，不具有交换性

- 友元关系`不具有传递性`。若类 B 是类 A 的友元，类 C 是 B 的友元，类 C 不一定是类 A 的友元，同样要看类中是否有相应的申明

- 友元破坏了类的封装性，数据的隐藏性

### 多态

多种形态，是对于不同对象接收相同消息时产生不同的动作。

#### ★ 多态实现方式

- 父类指针指向子类对象，然后通过父类指针调用实际子类的成员函数

- 虚函数技术可以让父类的指针有 `多种形态`，这是一种泛型技术。所谓泛型技术，说白了就是`试图使用不变的代码来实现可变的算法`。比如：模板技术，RTTI 技术，虚函数技术，要么是试图做到在编译时决议

- `函数特征`：函数返回值、函数名、函数参数个数和类型

#### 编译时多态

编译的时候就知道它要干什么了，编译出来的函数符号也不一样

**`overload 重载`**

`【同一类中的同名函数是重载】`, 这些方法的名称相同, 但是参数类型或个数不同, virtual 关键字可有可无

```c++
class Test
{
public:
    // 参数不同，参数类型不同，参数排列顺序不同，
    // const 函数与非 const 函数为重载
    void overload(std::string str) {}
    void overload(std::string str, std::string str1) {}
    void overload(std::string str) const {}
    void overload(std::string str, double i) {}
    void overload(double i, std::string str) {}
};
```

**`隐藏`**

子类的函数屏蔽了与其 `【同名】` 的父类函数，子类对象调用该同名函数的时候，调用的是子类函数，即隐藏了父类的同名函数

隐藏规则的底层原因其实是 C++ 的名字解析过程。在继承机制下，子类的类域被嵌套在父类的类域中。子类的名字解析过程如下（作用域？感觉有点闭包的意思）：

- 首先在派生类类域中查找该名字

- 如果第一步中没有成功查找到该名字，即在派生类的类域中无法对该名字进行解析，则编译器在外围父类类域对查找该名字的定义

呃，除了重载、重写以外的同名函数就是隐藏

| 参数 | 父类函数是否是虚函数 | 类型 |
| ---- | :------------------: | ---- |
| 相同 |          否          | 隐藏 |
| 不同 |        是或否        | 隐藏 |
|      |                      |      |
| 相同 |          是          | 重写 |

```c++
class Base
{
public:
    void f1(float x)
    {
        cout << "Base::f1(float) " << x << endl;
    }
    void f2(float x)
    {
        cout << "Base::f2(float) " << x << endl;
    }
};

class Derived : public Base
{
public:
    // 函数 Derived::g(int) 隐藏了 Base::g(float)，而不是重载
    void f1(int x)
    {
        cout << "Derived::f1(int) " << x << endl;
    }

    // 函数 Derived::h(float) 隐藏了 Base::h(float)，而不是覆盖
    void f2(float x)
    {
        cout << "Derived::f2(float) " << x << endl;
    }
};
```

#### 运行时多态

运行的时候才知道具体的行为是什么，比如 `父类指针指向子类对象 + 虚函数`

**`overwrite 重写 (或称为 覆盖）`**

是指子类重新定义父类虚函数的方法，达到实现不同的功能的目的

`函数体【特征相同】(函数名、参数类型个数)，父类函数有 virtual 关键字（是虚函数）`

```c++
class A
{
public:
    virtual void test_override(std::string str) {}
};

class B : public A
{
public:
    // 覆盖了父类的虚函数，子类的 virual 可不写
    virtual void test_override(std::string str) {}
};

int main(int argc, char* argv[])
{
    // 父类指针指向子类对象
    A * p_a = new B();
    p_a->test_override("test");
}

```

#### 引用是否能实现动态绑定，为什么引用可以实现

> 可以

因为 `引用（或指针）【既可以指向父类对象，也可以指向子类对象】，这一事实是动态绑定的关键`。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。

### 虚函数

核心就是类的`虚函数表`和对象的`虚函数指针`

- [深入理解虚函数 - 虚函数表解析](https://blog.csdn.net/xkdzhangchao/article/details/44966053)

- [什么是 C++虚函数、虚函数的作用和使用方法](http://c.biancheng.net/cpp/biancheng/view/244.html)

#### 虚函数的作用是什么，虚函数的实现原理是什么

- 虚函数的作用主要是`实现了多态的机制`

- 实现机制是：`虚函数表 + 虚函数表指针`

#### ★ 什么是虚函数表，虚函数表的内存结构布局如何

> 每个类维护一个虚函数表，每个类对象维护一个指向虚函数表的指针 `vptr`

- 编译器为`每个【类】维护一个【虚函数表】`，本质是一个函数指针数组，数组里面存放着该类所有虚函数的地址，`所有类对象共享这个虚函数表；每个【类对象】添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为【虚表指针（vptr）】`

  - 每个对象的**首地址保存着各自**指向该虚函数表的指针, 同一个类的不同对象实际上指向同一张虚函数表。

  - `_vptr 存在于对象实例中最前面的位置`是为了保证取到虚函数表有最高的性能——如果有多层继承或是多重继承的情况下

- 在单继承形式下, 子类完全获得父类的虚函数表和数据；`子类的虚函数表包含父类的虚函数地址，且子类虚函数地址在后面`

  子类如果重写了父类的虚函数 fun；就会把子类虚函数表中原本父类的虚函数 fun 对应的记录（内容 BaseClass::fun）覆盖为子类的 fun 函数地址（内容 SonClass::fun）

- `【到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定】`

  即：指针是什么类型，就调用什么类型的函数

  这就解释了为什么无法通过父类指针指向子类对象来访问子类特有的成员或虚函数，因为这些成员不是父类的（虽然继承之后父类虚函数了子类虚函数放在同一张表里）

##### 虚函数表存在哪里

[虚函数表存在哪里](https://blog.csdn.net/fw72fw72/article/details/68488739)

虚函数表由编译器在编译时生成，保存在 `.rdata 只读数据段`

##### 单继承、多继承下的虚函数表

[★ 单继承、多继承下的虚函数表](https://blog.csdn.net/qq_20309055/article/details/79298593)

[C++ 之虚函数和虚函数表](https://mp.weixin.qq.com/s/BPyNrU_FCOa9ClomxXeGEA)

- `单继承无重写`

  父类虚函数地址排列在子类虚函数地址前面

  虚函数表中的指针顺序，按照虚函数声明的顺序。

  ![alt](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable2.JPG)

  ![alt](https://mmbiz.qpic.cn/mmbiz_png/1RFyozRxKsfsI67UtwGPS1C6UIx0Ja3uaRdAcl7J3erhwCqXsROs4l4BQDXVMshPmSMoW4oyd2xcOqUdcl7oMA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `单继承有重写`

  父类虚函数地址排列在子类虚函数地址前面，父类中被重写的虚函数换成了子类对应的虚函数地址

  ![alt](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG)

  ![alt](https://mmbiz.qpic.cn/mmbiz_png/1RFyozRxKsfsI67UtwGPS1C6UIx0Ja3uyffialt5aOHfEtboETezoRmmedNKJNRTiaoSEib6MiayDOcvJGhFLZEfNg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `多继承无重写`

  - 每个父类都有自己的虚表（所以对应每个父类，子类对象中就多一个指针所占的空间）。

  - 多个父类之间的虚函数，按照继承的顺序，存放虚函数指针

  - 父父类内部的虚函数，按照虚函数内部声明的顺序存放。

  - `子类的虚函数被放到了第一个父类的表中(在没有重写的情况下)。（所谓的第一个父类是按照声明顺序来判断的）`估计也是为了寻址快才放到第一位

  - 第一个虚表就是`Base1的虚函数加上子类的虚函数`

  ![alt](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable4.JPG)

  ![alt](https://mmbiz.qpic.cn/mmbiz_png/1RFyozRxKsfsI67UtwGPS1C6UIx0Ja3u3kODXjlscBX5EnDfNaY35YfCAvJpgdhWCvh95x6vaOicoFRYLiclBBxQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- `多继承有重写`

  - 多个父类之间的虚函数，按照继承的顺序，存放虚函数指针。

  - 父类内部的虚函数，按照虚函数内部声明的顺序存放。

  - 虚函数表中，派生类重写的虚函数替换了父类虚函数指针，并指向了派生类的函数实现。

  ![alt](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable5.jpg)

  三个父类都有 f 函数, 子类重写了 f 函数； 三个父类虚函数表中的 f() 的位置被替换成了子类的函数指针。我们就可以用任一静态类型的父类来指向子类，并调用子类的 f() 了

  ![alt](https://mmbiz.qpic.cn/mmbiz_png/1RFyozRxKsfsI67UtwGPS1C6UIx0Ja3uAlMx68tyZGGTZsYot3Y2Qds1mGuYdiaQXwQz6RR3CPHYJ8IaT6Kcsbw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

##### 为什么说虚函数表并不安全

> 虽然任何妄图`【使用父类指针想调用子类中的未覆盖父类的成员函数】`的行为都会被编译器视为非法，这样的程序根本无法编译通过，`【但是，运行时却可以通过指针的方式访问虚函数表】`来达到违反 C++语义的行为

- 对象的地址就是虚函数的地址，对于没有重写的虚函数，无法通过指向子类的父类指针来调用 `Base b = new Driver();` 但是却可以通过对象的`地址计算来访问其他未重写的虚函数`

- 如果父类的虚函数是 private 或是 protected 的，但这些非 public 的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些 non-public 的虚函数

#### 哪些函数不可以作为虚函数

> - [哪些函数不能声明成虚函数](https://blog.csdn.net/weixin_41469381/article/details/88855775)
> - `【实例化】`后调用的函数，即要用对象才可以
> - `【可继承】`的函数才可以
> - `【动态绑定】`的函数才可以

- **非成员函数（只能重载，不能继承）**

  > 虚函数主要的作用是在继承中实现多态

  非成员函数早`在编译期间就已经绑定函数了`，无法实现多态

- **构造函数（虚函数需要实例化后才能调用）**

  > 要想调用虚函数必须要通过 `虚函数表` 来进行的

  - 虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数了

- **静态成员函数（属于类）**

  > 虚函数是动态绑定的，静态函数必然不可

  - 静态成员函数对于每个类来说只有一份，所有的对象都共享这一份代码，它是属于类的而不是属于对象

  - 虚函数必须根据对象类型才能知道调用哪一个虚函数，故`虚函数是一定要在对象的基础上才可以`的，两者一个是与实例相关，一个是与类相关

- **内联成员函数**

  > 虚函数在调用中需要从虚函数表中取`地址`的，而内联函数是没有指定地址的

  - 虚函数是为了在继承后对象能够准确的执行自己的动作

  - 内联函数在编译时被展开，虚函数在运行时才能动态地绑定函数

- **友元函数**

  - C++ 不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法

  - 友元函数不属于类的成员函数，不能被继承

#### 父类指针子类指针关系

##### ★ 子类指针可不可以指向父类对象呢

不可以，因为子类`【包含了父类没有的方法】`

- 子类总是含有一些父类没有的成员变量，或者方法函数。而子类肯定含有父类所有的成员变量和方法函数。所以用父类指针指向子类时，没有问题，因为父类有的，子类都有，不会出现非法访问问题。

- 用子类指针指向父类的话，`一旦访问子类特有的方法函数或者成员变量，就会出现非法`，因为被子类指针指向的由父类创建的对象，根本没有要访问的那些内容，那些是子类特有的，只有用子类初始化对象时才会有

##### 父类指针怎么调用子类的虚函数，调用流程是什么

- [C++父类指针指向子类对象的实现原理](https://blog.csdn.net/FX677588/article/details/77727110)

- [父类指针指向子类对象](https://www.cnblogs.com/zhangbaochong/p/5380016.html)

**父类指针指向子类对象，通过该指针只能访问父类的成员**，但为了访问子类成员引入虚函数，而且只能访问重写了该父类的虚函数的函数；依据的是【继承】+【重写】

- 父类指针指向子类对象时，由于子类【继承】了父类，因此内存中的子类里包含父类的所有成员。但 `【由于声明的是父类指针，因此该指针不能够访问子类的成员，而只能访问父类的成员】`

- 在父类里可以声明纯虚函数和定义虚函数，使用 `父类指针访问虚函数或纯虚函数的时候，访问到的是子类里【重写】的函数`。当然，对于虚函数，如果子类里没有对其重写的话，仍然访问到父类里定义的虚函数

##### 父类指针指向子类对象，指向的是哪张虚函数表

子类对象继承了父类的虚函数表（父类虚函数表是公用的啊），`重写也是重写子类的虚函数表，所以指向的是【子类的虚函数表】`

- 如果子类重写父类的虚方法，该子类虚函数表将保存重写的虚函数的地址，而不是父的虚函数地址。

- 如果父类中的虚方法没有在子类中重写，那子类将继承父类中的虚方法，而且子类中虚函数表将保存父类中未被重写的虚函数的地址。注意，如果子类中定义了新的虚方法，则该虚函数的地址也将被添加到子类虚函数表中

- 虽然子类继承父类后包含了父类的虚函数表，但无法通过父类指针指向子类对象来访问子类自己定义的的虚函数（除非是重写父类的虚函数），父类指针指向子类对象，指向的虚函数表应该是子类的虚函数表

#### 虚函数的入口地址和普通函数有什么不同

多了从虚函数表找虚函数地址后，再进行调用的过程

- 调用虚函数的时候，不管用什么方式调用，它`先根据虚函数表找到虚函数的入口地址，再执行。从而实现了 动态联编。而不像普通函数那样简单地跳转到一个固定地址`。

- 每个虚函数在虚函数表中占了一个表项，保存了它的入口地址。当一个包含虚函数的对象被创建的时候，它在头部附加一个指针，指向虚函数表中的相应位置

#### 纯虚函数

声明: `virtual void func()=0;` 和虚函数相比，后面多了`=0`

- 纯虚函数在父类中是只定义了函数体，没有写实现，必须在子类中加以实现

  `virtual void func(...)=0;`；告诉编译器，函数没有主体(和空函数是不同的, 空函数是有大括号, 但没有写实现)

- 纯虚函数的作用：在父类中为其子类保留一个函数的名字，以便子类根据需要对它进行定义。作为接口而存在的纯虚函数不具备函数的功能，一般不能直接被调用。

#### ★ 虚函数和纯虚函数的区别

> - `纯虚函数没有定义，只有声明，子类必须实现纯虚函数` ，目的是提供一个统一的接口
> - 包含纯虚函数的类是抽象类，不能实例化；子类必须定义父类的纯虚函数
> - 纯虚函数相当于占位符, 先在`虚函数表`中占一个位置由子类实现后再把真正的函数指针填进去；除此之外和普通的虚函数没什么区别

- 虚函数和纯虚函数都可以在子类(subclass)中被覆盖（重写），以多态的形式被调用。

- 虚函数可以被直接使用，也可以被子类覆盖（重写）以后以多态的形式调用，而`纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在父类只有声明而没有定义`

- 实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定

- 子类可以不实现纯虚函数，但是需要通过虚继承的方式，子类不能实例化

#### 为什么父类析构函数要声明为虚函数

> 虚函数是动态绑定的基础。假如析构函数不是虚函数，就不会发生动态绑定，而是**静态绑定，指针的静态类型为父类指针**，因此在 `delete 时候只会调用父类的析构函数，而不会调用子类的析构函数`。这样，在子类中申请的资源就不会得到释放，就会造成内存泄漏

- 父类定义析构函数为虚函数，`子类都要实现这个虚函数`。其实就是为了实现子类时，防止忘了释放内存的一个编码习惯

- **防止内存泄漏**

  - 借助`父类指针去销毁子类对象的时候`。假如没有虚析构函数，释放一个由父类指针指向的子类对象时，不会触发动态绑定，则只会调用父类的析构函数，不会调用子类的。子类中申请的空间则得不到释放导致内存泄漏

  - 假如析构函数不是`virtual`的，就`【不会发生动态绑定，而是静态绑定，指针的静态类型为父类指针】`；父类指针指向子类时，在释放内存时候`只会调用父类的析构函数，而不会调用子类的析构函数`

- **如果声明为虚析构**，子类的析构函数会【重写】父类的析构函数，所以析构的时候调用的是重写后的也即是子类的析构函数，`由于存在【继承】关系，所以会继续运行父类的析构函数`

- 由于父类函数是虚函数，子类相同函数就自动变虚函数，所以子类同名函数可以不指定为虚函数，如果父类的析构函数是虚函数, 那么子类的析构函数也是虚函数（即使不加 virtual 关键字）

#### 为什么默认的析构函数不是虚析构

- 因为如果析构函数为虚函数就需要编译器在`类中增加虚函数表来实现虚函数机制，这样【所需内存空间就更大了】`，因此没有必要默认为虚析构函数。

- 析构函数不一定必须是虚函数，是否为虚函数`取决于该类的使用，一般该类为父类产生继承和多态时`，才会是虚函数，单独使用可以不是虚函数。

#### 为什么构造函数不声明为虚函数

虚函数要有 `_vptr 虚函数指针` 才能访问，`虚函数指针存放在对象中，在实例化之后才有的`

- 虚函数相应一个指向 vtable 虚函数表的指针，但是这个指向 vtable 的指针事实上是存储在对象的内存空间的。

- 假设构造函数是虚的，就须要通过 vtable 来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找 vtable 呢？所以构造函数不能是虚函数。

- 虚函数相应一个指向虚函数表的指针，但是 `这个指针是存储在对象的内存空间`

- 如果构造函数是虚的，就须要通过 vtable 来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找 vtable 呢？所以构造函数不能是虚函数。

### 虚父类的作用，可以不要虚父类吗

虚父类是为了解决 `多重继承` 造成的二义性问题

## 内存

[[06. Cpp - 内存管理]]

## 其他
