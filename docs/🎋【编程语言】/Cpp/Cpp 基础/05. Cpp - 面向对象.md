- [参考资料](#参考资料)
- [OOP](#oop)
  - [this 指针](#this-指针)
    - [`this` 指针调用成员函数时的压栈和相关寄存器使用](#this-指针调用成员函数时的压栈和相关寄存器使用)
  - [类对象作为成员（类的组合）](#类对象作为成员类的组合)
- [类和对象](#类和对象)
  - [创建对象的三种方式](#创建对象的三种方式)
  - [访问权限和继承方式](#访问权限和继承方式)
    - [访问权限](#访问权限)
    - [继承方式](#继承方式)
    - [友元函数、友元类](#友元函数友元类)
    - [静态成员 **static**](#静态成员-static)
  - [构造函数](#构造函数)
    - [拷贝构造函数和赋值运算符](#拷贝构造函数和赋值运算符)
    - [构造函数和列表初始化](#构造函数和列表初始化)
      - [哪些情况一定要使用初始化成员列表](#哪些情况一定要使用初始化成员列表)
    - [初始化与赋值](#初始化与赋值)
    - [显式调用、隐式调用](#显式调用隐式调用)
    - [深浅拷贝构造函数](#深浅拷贝构造函数)
  - [析构函数](#析构函数)
  - [其他](#其他)
- [类和继承](#类和继承)
  - [抽象基类](#抽象基类)
  - [派生类和基类](#派生类和基类)
- [类的使用](#类的使用)
  - [`RTTI`](#rtti)

# 参考资料

# OOP

## this 指针

- [C++中 this 指针的用法详解](http://blog.chinaunix.net/uid-21411227-id-1826942.html)

### `this` 指针调用成员函数时的压栈和相关寄存器使用

`this`指针默认通过`ECX寄存器`传递给调用者，其参数`从右到左入栈`，是 `C++ 类成员函数缺省的调用约定`

- `thiscall`是唯一一个`不能明确指明的函数修饰`，因为 `thiscall` 不是关键字。

- 如果参数个数确定，this 指针通过 ecx 传递给被调用者；如果参数个数不确定，this 指针在所有参数压栈后被压入堆栈；

- 对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。

## 类对象作为成员（类的组合）

- 初始化问题

  在 c++中是通过构造函数的初始化表为内嵌对象初始化，组合类带有初始化表的构造函数定义格式为：

  ```cpp
  类名::构造函数（参数表）:内嵌对象1（参数表1）,内嵌对象2(参数表2),..........
  {
    构造函数体
  }
  ```

- 组合类构造对象的声明顺序依次执行顺序如下

  - 按照内嵌对象的声明顺序依次调用内嵌对象的构造函数；

  - 然后执行组合类本身的构造函数

# 类和对象

## 创建对象的三种方式

[C++ 创建对象的三种方法](https://www.cnblogs.com/spring-hailong/p/6106105.html)

[C++ 用 new 创建对象和不用 new 创建对象的区别解析](http://www.cnblogs.com/GODYCA/archive/2013/01/10/2854777.html)

```c++
/* 都是在栈中分配内存，且内存的分配和释放都是由系统管理的 */

// 隐式调用
A a(1);

// 显示调用
A b = A(1);

// 在堆中分配内存，且内存的分配和释放由程序员管理的,
A *c = new A(1);
```

## 访问权限和继承方式

[C++ 三种继承方式下的访问权限控制](http://blog.csdn.net/casky237/article/details/54766881)

[C++ 的三种访问权限与三种继承方式](http://blog.csdn.net/luoweifu/article/details/46953343)

### 访问权限

构造的对象属于外部

| 访问权限       | public | protected | private |
| :------------- | :----: | :-------: | :-----: |
| 对本类         |  可见  |   可见    |  可见   |
| 对子类         |  可见  |   可见    | 不可见  |
| 对外部(调用方) |  可见  |  不可见   | 不可见  |

- `public`

  类内外都可以访问

- `private`

  仅在自己类内可以被访问

- [`protected`](http://blog.csdn.net/luoruiyi2008/article/details/7179788)

  - `没有继承的情况下`，protected 和 private 相同，基类对象不能访问基类的 protected 成员, 派生类可以访问基类的 protected 成员, 但不能访问 private 成员。所以想要让子类看到又不想公开的就用 protected

  - `继承的情况下`，派生类的对象仅能访问 public 成员；只有在**派生类**内部才可以通过派生类对象访问基类的 protected 成员。

### 继承方式

[控制基类在派生类中的可见性](https://www.cnblogs.com/33debug/p/6666939.html)

[C++中的三种继承 public，protected，private](http://www.cnblogs.com/bizhu/archive/2012/07/20/2601303.html)

- **三种继承方式**

- 继承方式是为了控制子类的调用方(也叫用户)对父类的访问权限。

- 意思就相当于你怎么继承你祖先的东西,想把父类的东西变为自己的东西，你要给这些东西加个属性啊

- 比如你不想让所有人知道，私下继承，那你祖先原本公开（public 属性)或者只允许子孙知道的(protected)东西到了你这儿就都变成私有的了。

- 如果你继承了你祖先的东西，而这些你继承来的东西你不想别人知道，但你的子孙可以知道，那就用 protected 方式，这样的话，你祖先原本公开的物资, 到了你这儿也都变成自由子孙可以知道了

- 如果你大大方方地继承你父类的东西，父类是怎么样的别人看到的就是怎么样

- 继承方式不影响子类对父类的访问权限

- 子类对父类只看父类的访问控制权，即不可能通过 public 继承来让子类看到父类的 private 变量；子类仍然能访问 public 和 protected 权限的父类成员

- `class A：B` 默认的继承方式是 `private`

- 对于 c++ 类的成员默认是私有的、结构体成员默认是公有的

> 对派生类外部来说

| 继承方式  | 基类的 public  | 基类的 protected | 基类的 private |                 继承后权限变化                 |
| :-------: | :------------: | :--------------: | :------------: | :--------------------------------------------: |
|  public   |  仍为 public   |  仍为 protected  |     不可见     | 基类的**非 private 成员**在子类中访问属性不变  |
| protected | 变为 protected |  变为 protected  |     不可见     | 基类的非 private 成员变为子类的 protected 成员 |
|  private  |  变为 private  |   变为 private   |     不可见     |  基类的非 private 成员变为子类的 private 成员  |

### 友元函数、友元类

- 友元函数

  - 借助友元（`friend`），可以使得其他类中的成员函数或全局范围内的函数访问当前类的 `private` 成员,其实就是**开后门**，这个友元比亲儿子还亲啊

  - 将其原型放在类声明中，并在原型声明前加关键字`friend`

  - 友元不是成员函数，没有 this 指针,必需借助对象调用，且不能用成员运算符`->`调用；**但它与成员函数的访问权限相同。**

  ```cpp
  // 我想一个普通函数，传入类对象也可以啊。但是访问不了类的私有函数，所以要把他在类声明中声明为友元
  void friend_func(Student* pstu)
  {
      cout << "I'm friend func:\t"
           << "private_age: " << pstu->_age << "\tprotected_num: " << pstu->_num << endl;
  }
  ```

- [友元类](http://www.cnblogs.com/uniqueliu/archive/2011/08/02/2125590.html)

  - 把类 B 声明为类 A 的友元类，这样类 B 的所有函数都可以入侵访问类 A 的**所有成员**

  - 声明/定义,要提前声明：`friend class Tele;`

### 静态成员 **static**

[静态成员详解](https://blog.csdn.net/morewindows/article/details/6721430)

[静态成员函数和普通成员函数的区别](https://blog.csdn.net/liujianfei526/article/details/50562881)

[c++-静态成员函数和非静态成员函数的区别](https://blog.csdn.net/qq_30968657/article/details/69226931?utm_source=blogxgwz8)

[C++类中的静态成员变量与静态成员函数](http://www.cnblogs.com/ayanamistltz/archive/2012/11/22/2783033.html)

- 类的静态成员属于整个类 而不是某个对象，可以被类的所有方法访问，子类当然可以使用父类静态成员；静态成员无多态性！静态方法属于整个类，在对象创建之前就已经分配空间，类的非静态成员要在对象创建后才有内存,所有静态方法只能访问静态成员，不能直接访问非静态成员；静态成员可以被任一对象修改，修改后的值可以被所有对象共享。

- 静态成员可以实现多个对象之间的数据共享。静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。**因此，对静态成员的引用不需要用对象名。**(所以用类名加域作用符 A::iStatic, 这个::表示作用域而已）

- 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

- 调用静态成员函数使用如下格式

  ```cpp
  <类名>::<静态成员函数名>(<参数表>);
  ```

- 类非静态成员函数调用类静态成员变量

  报错：非静态成员引用必须与特定对象相对

  ```cpp
  解决:
  CClass * p_cClass = (CClass*) xxx;
  ...
  p_cClass->staticPar;
  ```

- 静态成员函数中不能直接调用非静态成员变量，因为非静态成员变量只有在对象创建时才分配内存

- 静态成员函数不需要类的实例就可以调用，即通过 `class name::`调用，但可以通过形参传递进来的具体对象来调用非静态成员变量

- [**静态成员函数不能被声明为`virtual`, 也不能被声明为`const和volatile`**](https://blog.csdn.net/qq_30968657/article/details/69226931?utm_source=blogxgwz8)

- static 成员不属于任何类对象或类实例，所以即使给此函数加上 virutal 也是没有任何意义的。

- 静态成员函数不像普通成员函数那样有 this 指针

- 当声明一个非静态成员函数为 const 时，对 this 指针会有影响。对于一个 Test 类中的 const 修饰的成员函数`int get() const;`，this 指针相当于 Test const , 而对于非 const 成员函数，this 指针相当于 Test . 而 static 成员函数没有 this 指针，所以使用 const 来修饰 static 成员函数没有任何意义。

- 不能在类声明中初始化静态成员变量，因为声明知识描述了如何分配内存，但并不实际分配内存。但是如果静态类成员是 int 整形或枚举型 const 则可以在声明中初始化。。。

- 初始化是在源文件中，而不是头文件中，因为类定义位于头文件中，程序可能在几个文件中包含该头文件，可能会出现多个初始化语句，会引发错误。

  ```cpp
  class A
  {
      static int iStatic; // 声明
      const int iConst;
      ...
  }
  A::A()::iConst(0) // 只能在构造函数初始化列表初始化
  {};
  int A::iSttatic = 0; // 初始化不需要static关键字
  ```

- 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数**没有 this 指针**

- [静态成员函数和静态成员变量](http://www.cnblogs.com/ayanamistltz/archive/2012/11/22/2783033.html)

- 静态类成员函数有一个特点：**无论创建多少个对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享一个静态成员**。静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。可以使用静态成员变量实现多个对象之间的数据共享, 程序运行结束时自动释放

- 和静态成员变量一样，在类内部可以被直接调用，在类外部可以通过作用域操作符

  ```cpp
  className:: 或 object. 和 *object-> 调用
  ```

- static 声明和初始化

  ```cpp
  // 静态成员的初始化指出了类型，并使用了类作用域符号，但是并没有关键字static
  Class A{
      // 不能在类声明中初始化静态成员变量，因为声明只是描述了如何分配内存
      // 静态类成员是单独存储的，而不是对象的组成部分。
      static int num_strings; //声明
      const static int iNum = 5; // 有的编译器不支持static变量类内初始化
      static const int iStaticConst;
      // 同 const static int iStaticConst;
      const int iConst; // 只能在构造函数初始化列表初始化
    ...
  };

  A::A():iConst(10)
  {
      iConst = 10;
  }

  int A::num_strings=0; //初始化
  int A::const int iStaticConst = 10;
  ```

## 构造函数

- [构造函数与初始化](https://www.cnblogs.com/niuxichuan/p/5396935.html)

- [C++中构造函数，拷贝构造函数和赋值函数的区别和实现](http://blog.csdn.net/zcyzsy/article/details/52132936)

> 构造函数的作用：初始化对象的数据成员

- 构造函数: `class_name::class_name(...){...}`

  - 为了让类对象在创造时就初始化其成员,不用构造函数的话就只是创建对象，没有初始化

  - 成员变量构造函数名和类名一样,没有返回值，不用声明返回类型,

  - 构造函数参数表示的是赋给类成员的值，参数名不能和类的成员名相同,可在类成员加个后缀 `_` 来区分

- 构造函数的声明和定义，构造函数的变量返回值

  ```cpp
  class Graduate:public Student
  {
  public:
      Graduate(int, string, float, float);
  private:
      float pay;
  };

  /**
   * 派生类的构造函数
   *
   * 冒号后面的 Student 表示派生类的，n、name、s 这几个参数是给基类的
   * pay(p) 表示这个p是派生类的 【成员变量 pay 的值】
   */
  Graduate::Graduate(int n, string nam, float s, float p) : Student(n, nam, s), pay(p){}
  ```

- 构造函数的声明（无参、带参)

  - 系统默认的构造函数就是不带参的构造函数, 用户自定义了构造函数后，就会调用自

  - 定义的这个构造函数，不管这个构造函数带不带参数

- 如果类的声明中没有构造函数，那么系统自动为类提供一个默认构造函数。这是个浅拷贝，可以通过 [`=delete` 来禁用](http://blog.csdn.net/u013652425/article/details/47416381)

- 如果类中声明了构造函数，那么系统不再提供默认构造函数，此时用户如果还要使用无参构造函数，则需要自己重载构造函数

- 派生类的构造函数

  派生类的构造函数的 **参数列表** 需要包含基类的构造函数的参数列表; 或者传入一个基类对象的引用；

  除非要使用默认构造函数，否则应显式调用正确的基类基类构造函数

### 拷贝构造函数和赋值运算符

[拷贝构造函数和赋值运算符](http://www.cnblogs.com/wangguchangqing/p/6141743.html)

```cpp
class Person{
  public:
    Person(){};

    /* 拷贝构造函数 */
    Person(const Person& p)
    {
        cout << "Copy Constructor" << endl;
    }

    /* 重载赋值运算符 */
    Person& operator = (const Person& p)
    {
        cout << "Assign" << endl;
        return *this;
        // this 是一个指针啊

        // int *ptr; ptr是指针；*ptr取ptr指向的内容; &ptr取存放指针ptr的地址

        // Person * func(){... return this};  // 返回当前对象地址
        // Person & func(){... return * this};  // 返回当前对象本身
        // Person func(){... return * this};  // 返回当前对象的拷贝
        /*这里返回的是当前对象的拷贝，你看这个函数的返回类型*/
    }
  private:
      ...
};
```

- [为什么要用引用？为什么要用 const?](https://blog.csdn.net/sinat_36053757/article/details/70597567)，知道 const 的意义和应用传参就懂为什么了

  如果是值传递的话，调用拷贝构造函数时会进行拷贝（`函数参数默认是通过值传递），然后编译器又去找拷贝构造函数，于是会造成无限的调用，[直至函数栈溢出]`。编译是编译不通过的

### 构造函数和列表初始化

[列表初始化](https://blog.csdn.net/fengxinlinux/article/details/70146347)

```cpp
/* 初始化成员方式一: 赋值初始化 */
CSomeClass::CSomeClass()
{
    x=0;
    y=1;
}

/* 初始化成员方式二: 初始化列表 */
CSomeClass::CSomeClass() : x(0), y(1)
{
}
```

- 对于在函数体中初始化, 是在所有的数据成员被分配内存空间后才进行的。**在大多数情况下，使用两者并没有什么太大区别。但是，第二种方式会更快**

- 列表初始化是给数据成员分配内存空间时就进行初始化, 就是说分配一个数据, 成员只要冒号后有此数据成员的赋值表达式 (此表达式必须是括号赋值表达式), 那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。

#### 哪些情况一定要使用初始化成员列表

> - `const` 常量只能初始化，不能赋值
> - `& 引用`也是只能初始化，不能赋值

[初始化列表](https://www.cnblogs.com/weizhixiang/p/6374430.html)

- `常量成员 const`

  因为常量只能初始化不能赋值，所以必须放在初始化列表里面

- `引用类型 &`

  引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面

- 没有对应的默认构造函数的类成员，因为`使用初始化列表可以不必调用默认构造函数来初始化`，而是直接调用拷贝构造函数初始化

  **如果类中声明了构造函数，那么系统不再提供默认构造函数，此时用户如果还要使用无参构造函数，则需要自己重载构造函数**

  ```cpp
  class A
  {
  public:
      A(int a){_num = a;}
  private:
      int _num;
  }
  A aobj; // 报错
  ```

### 初始化与赋值

初始化不是赋值，初始化的含义是创建一个变量时赋予其一个初始值，而赋值的含义是把对象当前的值擦除，而以一个新值来替代。

### 显式调用、隐式调用

- 显式调用构造函数

  ```cpp
  Stock food = Stock("Wrold", 240, 2.31);
  ```

- 隐式调用

  ```cpp
  Stock grament("Furry", 40, 2.1);
  ```

- 两种都不是的话就调用默认构造函数:`Stock fully_the_cat;`

  - 肯定不能通过对象调用构造函数啊，因为构造函数调用前，对象是不存在的

  - 如果只初始化了部分元素，则剩下的元素将使用默认构造函数进行初始化

### 深浅拷贝构造函数

[深/浅拷贝构造函数的区别](http://blog.csdn.net/u011420067/article/details/52460183)

构造函数是从无创建一个对象；拷贝构造函数使用一个对象去初始化另一个对象，所以入参是一个对象的引用

```cpp
// 深浅拷贝的语法都是一样的
Example(const CExample & clCExample);  // 拷贝构造函数（系统默认的是浅拷贝）
```

实际区分深浅拷贝的是这个拷贝函数的实现，如果实现中只是赋值的操作，没有出现**内存的拷贝**的话，那就是浅拷贝。对于深拷贝，针对成员变量存在指针的情况，不仅仅是简单的指针赋值，而是**分配新的内存空间**

- `浅拷贝`

  - 是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。**对其中任何一个对象的改动都会影响另外一个对象。**

  - 比如拷贝类对象时，对象含有指针成员，只是拷贝指针变量自身，这样新旧对象的指针还是指向同一内存区域；

- `深拷贝`

  - 就像复制了一份文件，两个文件间改动互不影响。浅拷贝就像创建快捷方式，共用一份文件，从哪边改动都会影响到这个文件。(当类成员有指针时)

  - 对象含有指针成员，拷贝时不仅拷贝指针变量，还重新在内存中为新对象开辟一块内存区域，将原对象次指针成员所指向的内存数据都拷贝到新开辟的内存区域。

## 析构函数

析构函数: `class_name::~class_name(...){...}`

用来完成清理释放资源工作的，如果构造函数是 new 分配内存，析构函数将使用 delete 来释放这些内存

## 其他

- [怎么在 A 类中调用 B 类的成员函数?](https://bbs.csdn.net/topics/390859834)

- [联系一下当类成员函数作为线程的入口函数](https://blog.csdn.net/qingzai_/article/details/50685169)

# 类和继承

- [类继承、基类、派生类、多态继承、虚函数](http://blog.sina.com.cn/s/blog_14eb2bead0102vrdf.html)

## 抽象基类

- 定义了纯虚函数的类称为抽象基类

- 派生类需要通过基类的方法对基类的私有成员进行访问

- 在公有继承中派生类保留了基类中除了构造和析构之外的所有成员，基类的公有或保护成员的访问权限都按原样保留下来，在派生类外可以调用基类的公有函数来访问基类的私有成员。因此基类能实现的功能，派生类也可以。

- [类继承 is-a 和 have-a](http://blog.csdn.net/my_heart_/article/details/52400419)

- public 继承是一个接口继承，保持 is-a 原则，每个父类可用的成员对子类也可用，因为每个子类对象也都是一个父类对象。（子类 is a 父类）

- `protetced/private` 继承是一个实现继承，基类的部分成员并非完全成为子类接口的一部分，是 has-a 的关系原则。（子类 has a 父类）

## 派生类和基类

- 基类和派生类有类型、名称一样的成员 `m_strName;`

  ```cpp
  class B
  {
  public:
      string m_strName;
  }
  class A:B
  {
  public:
      string m_strName;
  }

  A a;
  cout << a.m_strName << endl; // 这里访问的是子类的成员
  cout << a.B::m_strName << endl; // 这样才能访问到父类的成员
  ```

- 创建派生类对象时，程序首先创建基类对象，这意味着，基类对象应当在进入派生类构造函数之前被创建

- 释放对象的顺序和创建对象的顺序相反，先执行派生类的析构，然后自动调用基类的析构

- 基类指针(或引用）可以在不进行显式类型转换的情况下指向(或引用)派生类的对象；

  也就是一个[指向子类对象的父类指针](http://blog.csdn.net/chaoshui7758/article/details/49643867)，但这个指针或引用只能调用父类的方法(是不是想到了虚函数)

# 类的使用

> 本来是按照 C 的风格来写的:引入头文件，构建类对象，调用类成员函数
> 现在要把这个 cpp 文件封装起来，而引发的一些问题

- 在类 A 中使用类 B 的成员函数

  直接在了类 A 的成员函数中对创建 B 的对象

- 在类中构造另一个类的对象

- 内联函数怎么成类成员函数

- 类 A 成员函数 a 中使用多线程, 多线程任务函数是类 A 的成员函数 b

```cpp
// 改造成类之前：
threads[i] = thread(ParseMsgLine, vecThreadLines, i, strMsgKey);

// 改造成类之后: https://www.cnblogs.com/c4isr/p/9205164.html
```

## `RTTI`

`Runtime Type Information` 的缩写，运行时类型鉴定，如 `dynamic_cast<>()`，适用于使用基类的指针或引用转换为派生类并调用非虚函数方法
