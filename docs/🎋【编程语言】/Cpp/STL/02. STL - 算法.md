- [参考资料](#参考资料)
- [算法](#算法)
  - [`sort`](#sort)
  - [`count`](#count)
  - [`count_if`](#count_if)
  - [`fill`](#fill)
  - [`find`](#find)
  - [`reverse`](#reverse)
  - [`copy`](#copy)
  - [`unique`](#unique)
  - [`max_element`](#max_element)
  - [`distance`](#distance)
  - [`accumulate`](#accumulate)
- [模板函数](#模板函数)
  - [`lower_bound` 和 `upper_bound`](#lower_bound-和-upper_bound)
  - [`emplace`](#emplace)
  - [`emplace_front`](#emplace_front)
  - [`emplace_back`](#emplace_back)
  - [`erase`](#erase)
  - [`pop_back`](#pop_back)
- [`pair` 与 `tuple`](#pair-与-tuple)
  - [`pair`](#pair)
  - [`tuple`](#tuple)
- [其他](#其他)

# 参考资料

# 算法

> `#include <algorithm>` 一些常用来配合容器使用的算法

- `end()` 指向 `【最后一个字符的下一个位置】`

  - STL 算法等适配容器的函数都是直接传入 `end()`，比如 `reverse(s.begin(), s.end());`，是一个 `[first, last)` 左闭右开的区间范围

  - 如果自己想用迭代器指向最后一个元素，需要 `auto end = s.end() -1;`

## `sort`

- 排序

  ```cpp
  vector<int> vec{11, 2, 31, 4, 15};
  sort(vec.begin(), vec.end());


  // `[[11, 2], [31, 4], [15, 6]]`
  vector<vector<int>> vec2;
  vec2.push_back({11, 2});
  vec2.push_back({31, 4});
  vec2.push_back({15, 6});

  // 按照每个vector 的第一个元素排序
  sort(vec.begin(), vec.end());
  ```

- 可以自定义比较函数

  ```cpp
  int cmd(int a,int b) {
      return a > b;
  }
  // 按从大到小排序
  sort(nums.begin(), nums.end(), cmd);
  ```

- 逆序

  ```cpp
  // 正序后翻转
  sort(vec.begin(), vec.end());     // 默认的为升序  0 1 2 3 4 5 6 7 8 9
  reverse(vec.begin(), vec.end());  // 反向排列从头到尾部的元素

  // 用 greater
  sort(vec.begin(), vec.end(), greater<int>());

  // 用反向迭代器
  sort(vec.rbegin(), vec.rend());
  ```

## `count`

[C++ STL 算法系列 1 - count 函数](https://www.cnblogs.com/heyonggang/p/3240889.html)

```cpp
/* in string */
string arr = "adsf adf asdf asdf dfsd ";
// 最后一个参数类型为容器的元素
count(arr.begin(), arr.end(), ' ');

/* in vector */
vector<int> nums = {1, 2, 3, 4, 5, 4};
count(nums.begin(), nums.end(), 4);
```

## `count_if`

返回在 `[first, last)` 范围内满足特定条件的 `元素的个数`

```c++
bool greater10(int value) {
    return value > 10;
}

int main() {
    vector<int> vec{ 1, 23, 12, 32, 3, 9, 6, 8, 0, 4};
    vector<int>::iterator::difference_type result = count_if(vec.begin(), vec.end(), greater10);

    cout << result << endl;
}
```

## `fill`

在范围区间内填充值

```cpp
fill(nums.begin(), nums.begin() + 4, 1);

fill(nums.begin(), nums.end(), 0);

```

## `find`

[C++ STL 算法系列 2 - find，find_first_of，find_if，adjacent_find 的使用](https://www.cnblogs.com/heyonggang/p/3241789.html)

- `find`

  ```c++
  /* in vector */
  vector<int> nums{1, 2, 3, 4, 5, 6};
  int search_val = 6;
  // 在区间内查找
  vector<int>::iterator iter = find(nums.begin(), nums.end(), search_val);
  if (iter != nums.end())
      cout << "found: " << *iter << endl;
  else
      cout << "nount found" << endl;

  /* in array */
  int ia[6] = {27 , 210 , 12 , 47 , 109 , 83};
  int search_val = 88, begin = 0, end = 6;
  int *result = find(ia + begin, ia + end, search_val);
  cout << "The value "<< search_val
       << (result == ia + 6 ? " is not present" : "is present")
       << endl;
  ```

- `find_if`

  在序列中找符合某谓词的第一个元素。

  ```c++
  //谓词判断函数 divbyfive : 判断x是否能5整除
  bool divbyfive(int x)
  {
      return x % 5 ? 0 : 1;
  }
  auto iLocation = find_if(iVect.begin(), iVect.end(), divbyfive);

  if (iLocation != iVect.end())
  {
      cout << "第一个能被5整除的元素为："
           << *iLocation << endl                  //打印元素：15
           << "元素的索引位置为："
           << iLocation - iVect.begin() << endl;  //打印索引位置：2
  }
  ```

- `find_first_of`

  - 两对迭代器参数来标记两端元素范围：第一段范围内查找与第二段范围中任意元素匹配的元素

  - 然后返回一个迭代器，指向第一个匹配的元素

  - 如果找不到匹配元素，则返回第一个范围的 end 迭代器

  ```c++
  /* in string */
  // string 中也有一个 find_first_of
  string arr = "dasdfasd adsfa asdfa";
  char search_val = 'a';
  int begin_pos = 4;
  arr.find_first_of(search_val, begin_pos);

  size_t cnt = 0;
  list<string>::iterator it = roster1.begin();

  while((it = find_first_of(it, roster1.end(), roster2.begin(), roster2.end())) != roster1.end())
  {
      ++cnt;
      ++it;
  }
  cout << "Found " << cnt
       << " names on both rosters "<<endl;
  ```

## `reverse`

```cpp
string str = "huagn jin jie";
reverse(str.begin(), str.end());
cout << str << endl;

// eij nij ngauh
```

## `copy`

- [C++ STL 算法系列 6---copy 函数](https://www.cnblogs.com/heyonggang/p/3265142.html)

- 该算法主要用于容器之间元素的拷贝，即将迭代器区间 `[first，last)` 的元素复制到由复制目标给定的区间 `[result，result + (last - first))` 中

- `copy`

  ```c++
  /* in vector */
  vector<int> vect5;
  copy(vect1.begin(), vect1.end(), back_inserter(vect5));

  myvector.resize(7);
  // copy用法一
  // 将数组 myints 中的七个元素复制到 myvector 容器中
  copy ( myints, myints + 7, myvector.begin());

  // copy用法二
  // 将数组myints中的元素向左移动一位
  copy(myints + 1, myints + 7, myints);
  ```

## `unique`

[C++ STL 算法系列 4 -unique , unique_copy 函数](https://www.cnblogs.com/heyonggang/p/3243477.html)

> 作用是从输入序列中 "删除" 所有相邻的重复元素

- `unique`

  ```c++
  /* in vector */
  // 先排序
  sort(vec2.begin(), vec2.end());
  // 删除相邻的重复元素
  vec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());
  ```

- `unique_copy`

## `max_element`

```c++
/* in vector */
std::vector<int>::iterator max_item = max_element(nums.begin(), nums.end());

// 返回最大元素
cout << *max_item << endl;

// 返回最大值下标
cout << max_item - nums.begin();
```

## `distance`

## `accumulate`

[C++ STL 算法系列 3 - 求和：accumulate](https://www.cnblogs.com/heyonggang/p/3241878.html)

```cpp
#include <numeric>
// 两个形参指定要累加的元素范围，第三个形参则是累加的初值
sum = accumulate(nums.begin(), nums.end(), 0);

// 结果溢出的问题 https://blog.csdn.net/grllery/article/details/97612908
// accumulate 函数累加和的结果和第三个参数的类型有关
// 如果 initial_val 的类型为 int(默认)，那么如果和超过了 INT_MAX，结果会溢出，因此就将初始值类型设置为了long即0L
sum = accumulate(nums.begin(), nums.end(), 0L);
```

# 模板函数

> 几乎所有的容器都可以使用这些函数

## `lower_bound` 和 `upper_bound`

[关于 lower_bound() 和 upper_bound() 的常见用法](https://blog.csdn.net/qq_40160605/article/details/80150252)

> lower_bound 和 upper_bound 严格也算是查询函数，只不过它们查询的范围不同；都是利用二分查找的方法在一个【有序数组】中进行查找

- `lower_bound` 返回第一个 `大于等于 val` 的迭代器

- `upper_bound` 返回第一个 `严格大于 val` 的迭代器

- vector 中使用

  ```c++
  // ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)

  vector<int> vec{ 1, 23, 12, 32, 3, 9, 6, 8, 0, 4, 7};
  sort(vec.begin(), vec.end());

  int key = 7;

  vector<int>::iterator it_low = lower_bound(vec.begin(), vec.end(), key);
  vector<int>::iterator it_up = upper_bound(vec.begin(), vec.end(), key);

  ```

- set 中使用

  ```cpp
  // 如果set存在比某个数大的数， 输出的是set中的数
  set<int> s{2, 4, 10};
  set<int>::iterator it = s.lower_bound(9);
  // 输出 10
  cout << *it << endl;
  ```

## `emplace`

> - `emplace（安置）` 函数的功能和 insert 一样，可以往 set 当中插入元素。它和 insert 最大的区别在于 emplace 传入的参数并不是要插入的元素，而是`构造元素`需要的参。
> - emplace 函数返回的结果是一个 `pair`，第一个元素是 set 的迭代器，表示插入的元素的位置，第二个值是一个 bool，表示是否插入成功。

```cpp
// 假设我们有一个 set 它的类型是结构体 P，当中我们重载了它的比较算子

#include <set>
struct P {
  int x, y;
    P(int x, int y) : x(x), y(y){};
    bool operator<(const P b) const  {
         return this->x < b.x;
    }
};

set<P> st;

// 如果我们要使用insert应该这样
P p{0, 3};
st.insert(p);

// 如果使用emplace函数呢，则是这样
// emplace 的内部会`替我们去调用结构体P的构造函数`，
// 使用 1 和 23 这两个参数构造出一个 P 的实例来存入 set 当中。

st.emplace(1, 23);
```

## `emplace_front`

`emplace_front` 在开头添加元素；C++11 新增，可以减少内存拷贝和移动

```cpp
list<pair<int, char>> mylist;
// 和 emplace 一样，内部会 【自动构造一个元素出来】
mylist.emplace_front(10, 'a');

list<int> test;
test.emplace_front(10);
```

## `emplace_back`

`emplace_back()` 调用的是移动构造函数，`push_back()` 调用的是拷贝构造函数；移动构造函数不需要分配新的内存空间，所以更快一些。避免了无谓的拷贝

```c++
#include <iostream>
#include <vector>

using namespace std;

class A {
public:
    A(int i)
    {
        // cout << "A()" << endl;
        str = to_string(i);
    }
    ~A(){}
    A(const A& other): str(other.str)
    {
        cout << "A&" << endl;
    }

public:
    string str;
};

int main()
{
    vector<A> vec;
    vec.reserve(10);

    for(int i = 0; i < 10; i++)
    {
        // 调用了10次拷贝构造函数
        vec.push_back(A(i));

        // 一次拷贝构造函数都没有调用过
        // vec.emplace_back(i);
    }

    for(int i = 0; i < 10; i++)
    {
        cout << vec[i].str << ' ';
    }
    cout << endl;
}
```

## `erase`

`erase` 移除元素

```cpp
list<pair<int, int>> m_lru;
unordered_map<int, list<pair<int, int>>::iterator> m_table;
m_table.erase(m_lru.back().first);
```

## `pop_back`

`pop_back` 删除最后一个元素

```cpp
m_lru.pop_back();
```

# `pair` 与 `tuple`

- [pair 的基本用法总结](https://blog.csdn.net/sevenjoin/article/details/81937695)

- [pair 和 tuple](https://blog.csdn.net/xiaoguyin_/article/details/79788027)

## `pair`

> `pair`：一组、一对；可以两个元素当成一个元素

- `pair` 实现是一个结构体，主要的两个成员变量是 `first、second`；因为是使用 struct 不是 class，所以可以直接使用 pair 的成员变量

- `适用场景`

  - 函数需要返回两个元素时

  - 容器中两个元素作为一个节点，其实就是一种新的类型了，比如 `list<pair<int, int>> l;`

- `make_pair(v1, v2);` 以 v1 和 v2 的值创建一个新的 pair 对象，其元素类型分别是 v1 和 v2 的类型

  ```cpp
  map<string, int> m1;

  // 用 make_pair 直接初始化成员就行了
  m1.insert(make_pair("huangjinjie", 1));

  // 用 pair 要声明 pair 的成员类型
  m1.insert(pair<string, int>("huagnjinjie3", 3));
  ```

- 函数返回 pair 对象时，要用 `std::tie` 来接收，需要引入 `#include <tuple>` 头文件

## `tuple`

`pair` 只有两个成员，`tuple` 和 Python 中的元组一样，可以有无数个成员变量；tuple 需要通过 `std::get<N>(tuple_arg)` 来访问成员，N 表示第 n 个成员

# 其他

- `value_type`
