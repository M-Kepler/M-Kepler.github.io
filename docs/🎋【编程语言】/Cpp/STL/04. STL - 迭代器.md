- [参考资料](#参考资料)
- [迭代器](#迭代器)
  - [迭代器和指针的关系](#迭代器和指针的关系)
  - [★ 迭代器失效有哪几种情况](#-迭代器失效有哪几种情况)
    - [`序列型容器`](#序列型容器)
      - [`vector`](#vector)
      - [`deque`](#deque)
    - [`链式容器`](#链式容器)
    - [`关联型容器`](#关联型容器)
  - [迭代器类型](#迭代器类型)
    - [输入输出迭代器](#输入输出迭代器)
    - [插入迭代器](#插入迭代器)
    - [迭代器取值](#迭代器取值)
    - [位置迭代器](#位置迭代器)
- [其他](#其他)

# 参考资料

> 设计模式里有个迭代器模式

# 迭代器

> 迭代器是`连接容器和算法`的一种重要桥梁，通过迭代器可以在不了解容器内部原理的情况下遍历容器。它的底层实现包含两个重要的部分：萃取技术和模板偏特化

- `iterator` 迭代器

  [迭代器和容器](https://www.cnblogs.com/zoe-mine/p/6753792.html)

  迭代器提供了对对象的间接访问，可以从一个元素移动到下一个元素, 看到很多迭代器都放在 for 循环里，所以 for 循环和迭代器的关系是什么；迭代器是容器的一个成员函数吧，用域操作符`::`调用

  ```cpp
  for (map<int, string>::iterator iter = mapStudent.begin(); iter != mapStudent.end(); ++iter)
  {
      cout<<iter->first<< ' ' << iter->second <<endl;
  }
  ```

- `移动迭代器`

  ```cpp
  vector<int> vec_test;
  vector<int>::iterator t_iter = vec_test.begin();
  auto tt = t_iter + 2;

  // list 的迭代器就不能直接用加号
  list<int> list_test;
  list<int>::iterator list_ter = list_test.begin();
  advance(list_ter, 2);
  ```

## 迭代器和指针的关系

迭代器不适指针，而是 `类模板`

它封装了指针，并重载了指针的一些运算符，比如 `++、--、*` 等，所以能够遍历部分或全部访问容器元素的对象。

迭代器 `返回的是对象的引用`，所以不能直接访问，而需要 `用 * 解引用` 后再访问

## ★ 迭代器失效有哪几种情况

> - 迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构
> - 迭代器是否失效，说到底就是看其指向的内存有没有变化

- [C++ 迭代器失效的几种情况总结](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)

- [各类容器迭代器失效的场景](https://blog.csdn.net/yusiguyuan/article/details/42079977)

- [关于迭代器失效的几种情况](https://blog.csdn.net/qq_37964547/article/details/81160505)

### `序列型容器`

`vector`，`deque` 使用了`连续分配的内存`，删除一个元素导致`【后面所有的元素会向前移动一个位置，即其后的所有元素的迭代器都会失效】`。所以不能使用 `erase(iter++)` 的方式， `erase` 方法可以返回下一个有效的迭代器

```cpp
it = vec.erase(it);
```

#### `vector`

- 对于 `vector` 当插入 (`push_back`) 一个元素时

  > [1, 2, 3, 4, 【9】,5, 6, 7, 8]

  - `end` 迭代器肯定失效

  - 如果 `capacity` 返回值与没有插入元素之前相比有改变（即：进行了扩容），则需要重新加载整个容器，此时 `first` 和 `end` 操作返回的迭代器都会失效

  - 如果 `capacity` 没有改变（即：空间未重新分配），指向插入位置`之前的元素的迭代器仍然有效`，但指向插入位置`之后元素的迭代器全部失效`

#### `deque`

> 双端对列，首和尾都可以入队

- 如果`在首尾之外添加`元素，都会导致迭代器、指针和引用都会失效

- 如果`在首尾位置添加`元素，迭代器会失效，但是指针和引用不会失效

- 如果`在首尾之外删除`元素，那么指向被删除元素外其他元素的`迭代器全部失效`

- 在其`首部或尾部删除`元素，则只会使指向被删除元素的迭代器失效

### `链式容器`

对于链表式容器 (如 list)，删除当前的 iterator，`仅仅会使【当前】的迭代器失效`，这是因为 list 之类的容器，使用了链表来实现，插入、删除一个结点不会对其他结点造成影响。只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator

```cpp
// 通过递增的方式
list_test.erase(iter++);

// 或者，删除元素时，返回下一个有效的迭代器
iter = list_test.erase(iter);
```

### `关联型容器`

关联容器 (如 map, set,multimap,multiset)，删除当前的迭代器，`仅仅会使【当前】的迭代器失效`，单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系，`只要在 erase 时，递增当前 iterator 即可`

```cpp
// 把 iter 传值到 erase 里面，然后 iter 自增，然后执行 erase,
// 所以 iter 在失效前已经自增了
test_map.erase(iter++);
```

## 迭代器类型

### 输入输出迭代器

```c++
typedef istream_iterator<int> IstreamItr;
typedef ostream_iterator<int> OstreamItr;
```

### 插入迭代器

[插入迭代器](https://blog.csdn.net/github_35681219/article/details/52564780)

```c++
list<int> lst = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
list<int> lst2 = {10}, lst3 = {10}, lst4 = {10};

//lst2包含10,1,2,3,4,5,6,7,8,9
copy(lst.cbegin(), lst.cend(), back_inserter(lst2));

//lst3包含1,2,3,4,5,6,7,8,9,10
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));

//lst4包含9,8,7,6,5,4,3,2,1,10
copy(lst.cbegin(), lst.cend(), front_inserter(lst4));
```

### 迭代器取值

```c++
vector<int> nums(0);
for (auto iter = nums.begin(); iter != nums.end(); iter++)
    cout << *iter << endl;
```

### 位置迭代器

![alt](https://img-blog.csdn.net/20180518122234389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lzcTk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- `begin`

  返回一个正向迭代器，从前面往末尾迭代，指向字符串的第一个元素。

- `end()`

  返回一个正向迭代器，指向字符串的末尾 (`【最后一个字符的下一个位置】`)

  STL 算法等适配容器的函数都是直接传入 `end()`，比如 `reverse(s.begin(), s.end());`，如果自己想用迭代器指向最后一个元素，需要 `auto end = s.end() -1;`

- `rbegin`

  返回一个逆向迭代器，从末尾往前面迭代，`【指向字符串的最后一个字符】`

- `rend`

  返回一个逆向迭代器，指向字符串的开头（`【第一个字符的前一个位置】`）

# 其他

- `for_each`

  ```cpp
  // 对ret的每个元素执行out 函数
  for_each(InputIterator first, InputIterator last, Function functor);

  // for_each()对当前 [begin, end) 范围内的所有成员进行访问;

  // 用上lambda后, 相当于依次把ret元素传入lambda表达式
  for_each(begin(ret), end(ret), [](int elem) {
      cout << elem << " ";
  });

  // 旧用法
  int total = 0;
  auto func = [&total](int i ){total+=i;};
  for(int i = 0; i < vecRet.size(), i++)
  {
      func(i);
  }
  cout << total;
  ```

- `forrange` 范围迭代

  ```cpp

  // 注意写使用 auto &i: nums，读的时候用 auto i: nums
  vector<int> vec;
  // 可以修改 i 的值
  for (int &i : vec)
  // 只是读取 i 的值
  for (int &&i : vec)
  // 只是读取 i 的值
  for (int i : vec)
  {
      ...
      // * 解引用，获取值
      cout << *i << endl;
  }
  ```
