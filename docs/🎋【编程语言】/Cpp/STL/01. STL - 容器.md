- [参考资料](#参考资料)
- [容器](#容器)
  - [`string` 字符串](#string-字符串)
    - [C++ 的 string 和 C 语言的 `char *` 有什么区别](#c-的-string-和-c-语言的-char--有什么区别)
    - [STL 的 `COW（copy on write）` 技术](#stl-的-cowcopy-on-write-技术)
  - [`vector`](#vector)
    - [vector 和数组的区别](#vector-和数组的区别)
    - [`vector` 缩容](#vector-缩容)
    - [★ `vector` 扩容](#-vector-扩容)
    - [★ 如何尽量减少扩容带来的拷贝开销，又能增加存储的数据](#-如何尽量减少扩容带来的拷贝开销又能增加存储的数据)
    - [`reserve` 和 `resize` 的区别](#reserve-和-resize-的区别)
    - [`erase` 和 `remove` 的区别](#erase-和-remove-的区别)
    - [`size` 和 `capacity` 的区别](#size-和-capacity-的区别)
  - [`list` 双向链表](#list-双向链表)
    - [`vector` 与 `list` 的区别](#vector-与-list-的区别)
  - [`deque` 双端队列](#deque-双端队列)
  - [`map`](#map)
    - [`map`](#map-1)
      - [map 底层解决哈希冲突的方法是什么](#map-底层解决哈希冲突的方法是什么)
      - [拉链法的链表越来越长时，如何优化](#拉链法的链表越来越长时如何优化)
    - [`unordered_map`](#unordered_map)
    - [`multimap`](#multimap)
    - [★ `unordered_map` 和 `map` 的区别是什么](#-unordered_map-和-map-的区别是什么)
    - [map 底层实现是什么，为什么要用红黑树](#map-底层实现是什么为什么要用红黑树)
  - [`set` 集合](#set-集合)
  - [`priority_queue` 优先队列](#priority_queue-优先队列)

# 参考资料

- [★★★★★ STL 详解及常见面试题](https://blog.csdn.net/daaikuaichuan/article/details/80717222)

- [全面的 STL 总结与常见面试题](https://blog.csdn.net/qq_45662588/article/details/118367662)

- [★ C++ 进阶 - STL 容器](https://www.jianshu.com/p/497843e403b4)

- [基本数据结构的比较](https://www.cnblogs.com/xzwblog/p/7197871.html)

- [《C++ Primer》读书笔记第十一章 - 2 - 关联容器操作](https://blog.csdn.net/billcyj/article/details/78065438)

- [C++ 标准模板库 STL【快速查找】【最全】【常用】【语法】](https://blog.csdn.net/sinat_25721683/article/details/79073336)

- [深入探索 STL](https://blog.csdn.net/yeswenqian/category_9264158.html)

- [list, vector, map, set 区别与用法比较](https://www.cnblogs.com/virusolf/p/4323940.html)

- [unordeded_map 和 unordeded_set 的底层实现](https://blog.csdn.net/turn__back/article/details/56005723)

# 容器

> 为什么被称作容器，因为容器实际上是一种类模板，可以存放大多数类型的对象, 就像是一个容器一样。

- 顺序容器

- 关联容器

  - `set、map` 类似于集合，底层都是采用红黑树来实现。

  - `map` 使用键值对的方式来储存数据，键不能有重复的，值可以重复，map 使用键来存储数据，系统会根据键来自动将数据排序；

  - `set` 键不能有重复，使用键来存储数据，系统会根据该值来自动将数据排序。

  - `map` 和 `set` 是稳定排序(排序前后元素相对位置不变)，`multimap` 和 `multiset` 是不稳定排序。

## `string` 字符串

- [实现一些字符串操作标准库函数](https://mp.weixin.qq.com/s/tsCeMcdtvyuJJ1uFjnjnDg)

- `string` 是 `STL` 的字符串类型，在 C 语言中，我们通常用 `char *` 或者 `char[]` 字符数组来表示字符串

- [`find_first_not_of`](https://blog.csdn.net/ffjbq/article/details/7611255)

  ```cpp
  size_type find_first_not_of( const basic_string &str, size_type index = 0 );
  size_type find_first_not_of( const char *str, size_type index = 0 );
  size_type find_first_not_of( const char *str, size_type index, size_type num );
  size_type find_first_not_of( char ch, size_type index = 0 );
  ```

- `capacity` 和 `size` 的区别

  ```cpp
  int size()const;              // 返回当前字符串的大小
  int capacity()const;          // 返回当前容量（即string中不必增加内存即可存放的元素个数）

  int max_size()const;          // 返回string对象中可存放的最大字符串的长度
  int length()const;            // 返回当前字符串的长度
  bool empty()const;            // 当前字符串是否为空
  void resize(int len, char c);  // 把字符串当前大小置为len，并用字符c填充不足的部分
  ```

### C++ 的 string 和 C 语言的 `char *` 有什么区别

- `string` 是一个类，`char *` 是指向字符的指针

- `string` 封装了 `char *`, 管理这个字符串，是一个 `char *` 类型的容器

- `string` 不用考虑内存释放和数组越界

- `string` 提供了一些列的字符串操作函数

### STL 的 `COW（copy on write）` 技术

> - 用`引用计数`来实现内存共享
> - [因为`非线程安全`在 C++11 中已经废除](https://blog.csdn.net/x670127565/article/details/114241693)
> - [STL 的写时拷贝（Copy-On-Write）](https://blog.csdn.net/iteye_18039/article/details/81895269)
> - [标准 C++ 类 string 的 Copy-On-Write 技术](https://coolshell.cn/articles/12199.html)

```cpp
string s1 = "abcd";
string s2 = s1;

/**
   当 string s2 = s1; 其内部内存大概为这样：

      _Ptr1、 _Ptr2
             ↓
[Refcnt = 2][a][b][c][d][\0][U]……
*/

```

![alt](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_string.jpg)

- s2 并没有另外开辟内存，只是引用了 s1 的内存，并`【把引用计数增加 1】`，达到内存共享，以便减少内存和时间的开销

- 也就是 `_Ptr1`、 `_Ptr2` 指向了同一块内存地址，只是把 `Refcnt` 增加 1 引用计数而已

## `vector`

[C++ vector 用法](http://www.cnblogs.com/wang7/archive/2012/04/27/2474138.html)

### vector 和数组的区别

> [c++有了向量（vector）为什么还要用数组](https://zhidao.baidu.com/question/986352083658004539.html)

- vector 向量 相当于一个数组

  在内存中分配一块连续的内存空间进行存储。支持不指定 vector 大小的存储。STL 内部实现时，首先分配一个非常大的内存空间预备进行存储，即 capacituy()函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以 vector 可以不指定 vector 即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。

  感觉 vector 就是数组的上一层封装。vector 能做的，数组也能实现。

  ![alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy8wbTRZWDU5NUZva0R2ZnNhWWVsejVLbUxsV2N2d3FXWkl2c0FPdVljaWJvTzg3UTdDQTYwZzBvSms2cmgxeGV5Szd6aWNFVHVFOU16SDc2aWNkMXJMUDVEQS82NDA?x-oss-process=image/format,png)

**优点**

- 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在 push_back() pop_back()

- 随机访问方便，即支持 `[ ]` 操作符和 `vector.at()`

- 节省空间

**缺点**

- 在内部进行插入删除操作效率低

- 只能在 vector 的最后进行 push 和 pop，不能在 vector 的头部进行 push 和 pop

- 当动态添加的数据超过 vector 默认分配的大小时要进行整体的重新分配、拷贝与释放

- 数组长度：`int a[10]; int len = sizeof(a)/sizeof(a[0]);`

### `vector` 缩容

[如何避免 vector 容器进行不必要的扩容](http://c.biancheng.net/view/7397.html)

`vector` 中删除元素的话，会自动缩容吗？删除大量元素的时候呢

- 在 C++ 标准库容器 vector 的容量是`不会自动的缩减的`，也就是说删除元素操作，其引用、指针、迭代器也会继续有效

- 当在一个较大的 vector 中删除了大量的元素之后，实际的 size 比较小，而 capacity 比较大，可以使用 `swap` 来进行调整收缩

  ```cpp
  // swap 操作的时间复杂度是 O(n)

  // step1. 产生一个和 v 内容一模一样的 vector，且容量恰好满足其大小的 size
  std::vector<T> tmp(v);

  // step2. v 和 tmp 交换 ，然后 tmp 就自动解析掉了
  tmp.swap(v);

  // 或者写成一句：
  std::vector<T>(v1).swap(v1);
  ```

- 当然在实际场景中，我们可能并不知道 vector 容器到底要存储多少个元素。这种情况下，可以先预留出足够大的空间，当所有元素都存储到 vector 容器中之后，再去除多余的容量

- 关于怎样去除 vector 容器多余的容量，可以借助该容器模板类提供的 `shrink_to_fit() shrink 收缩、缩小` 成员方法；该请求不具有约束力，容器可以自由地去执行其他的优化方案（capacity 可以大于 size）。该方法由编译器决定是否真正释放多余的内存，只是提出请求，是否要实现由编译器说了算。

### ★ `vector` 扩容

- 底层数据结构是一个`动态数组`，如果动态数组的大小不够用就需要动态地重新分配，gcc 编译器按照 2，4，8，16 进行而被扩容（不同编译器会有差异，vs 中是以 1.5 倍扩容，原因可以考虑`内存碎片`，内存的浪费）

- 扩容后是一片新的内存，`需要把旧内存空间的所有元素都拷贝到新内存空间去`（以后再在新内存空间中的原数据后面进行插入），并且同时释放旧内存空间，并且由于`vector`内存空间进行了重新配置，`旧空间中所有的迭代器都会失效`

### ★ 如何尽量减少扩容带来的拷贝开销，又能增加存储的数据

[如何避免 vector 容器进行不必要的扩容](http://c.biancheng.net/view/7397.html)

- 可以用 vector 存一些结构体指针，这样在相同数量的 vector 前提下，可以通过这种方式组织更多的数据进去

  这显然不是面试官想听到的。。。这个问题遇到两次了

- 实际就是结合 数组 和 vector 的特性，用 ==`reserve`== 固定申请很大的一块内存，可以存更多数据，而且超过的话也还会自动进行扩容

  ```cpp
  vector<int>myvector;
  myvector.reserve(1000);
  cout << myvector.capacity();
  for (int i = 1; i <= 1000; i++)
  {
      myvector.push_back(i);
  }

  // 整段程序在运行过程中，vector 容器的容量仅扩充了 1 次，执行效率大大提高
  ```

### `reserve` 和 `resize` 的区别

> `reverse` 翻转；`reserve` 预留

- `reserve 是直接扩充到已经确定的大小`，可以减少多次开辟、释放空间的问题（优化 push_back），提高效率，其次`还可以减少多次要拷贝数据的问题`

- `reserve` 只是保证 `vector` 中的空间大小（`capacity`）最少达到参数所指定的大小 n

- `resize 可以改变有效空间的大小，也有改变默认值的功能`。capacity 的大小也会随着改变

### `erase` 和 `remove` 的区别

[erase 和 remove 的区别](https://blog.csdn.net/xzymmd/article/details/83652726)

- `remove()` 只是将待删除元素之后的元素移动到 vector 的前端，而不是删除

- 要真正移除，需要搭配使用 `erase()`

### `size` 和 `capacity` 的区别

- `size` 表示当前有多少个元素 `(finish - start);`

- `capacity` 表示它已经分配的内存中可以容纳多少元素 `(end_of_storage - start);`

## `list` 双向链表

[list 中常用函数总结一](https://blog.csdn.net/qq_40889820/article/details/84872884)

**优点**

- 不使用连续内存完成动态操作

- 在内部方便的进行插入和删除操作

- 可在两端进行 push、pop

**缺点**

- 不能进行内部的随机访问，即不支持 `[ ]` 操作符和 vector.at()

- 相对于 verctor 占用内存多

### `vector` 与 `list` 的区别

- `vector` 和数组类似，拥有连续的内存空间，支持随机的存取，在中间进行元素的插入和删除的操作时间复杂度是 O(n)

- `list` 是由双向链表实现的，只能通过数组指针来进行数据访问，遍历中间的元素，时间的复杂度是 O(n)

## `deque` 双端队列

- [抛砖引玉 | 图解双端队列 Deque](https://mp.weixin.qq.com/s/Flc5gWWJjpz2rbzLQnxC0A)

- [STL 之 deque 实现详解](https://www.kanzhun.com/jiaocheng/531548.html)

![alt](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F10998555-81a3183bbc1f8fa0.png%3FimageMogr2%2Fauto-orient%2Fstrip%257CimageView2%2F2%2Fw%2F1240&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639126022&t=73eef36694294ef52ff6519b270512ec)

- 双端队列的概念

  - 队列（queue）是限定在表的一端进行插入，表的另一端进行删除的数据结构

  - 栈（stack）是限定仅在表的一端进行操作的数据结构，且栈是一种先进后出 (FIFO) 的数据结构

  - 双端队列（double ended queue），简称 deque，`双端队列没有队列和栈这样的限制级，它允许两端进行入队和出队操作`，也就是说元素可以从队头出队和入队，也可以从队尾出队和入队

- deque 是双向开口的连续线性空间（动态将多个连续空间通过指针数组接合在一起），随时可以增加一段新的空间，所以数据像 vector 里面的分配，复制，释放操作不会发生

- deque 头尾两端分别做插入和删除操作都是常数时间。能用 vector 尽量使用 vector，通过 deque 用来做队列即可

- deque 容器类与 vector 类似，支持随机访问和快速插入删除，它在容器中某一位置上的操作所花费的是线性时间。与 vector 不同的是，deque 还支持从开始端插入数据：push_front()

- `优点`

  - 随机访问方便，即支持 `[]` 操作符和 `vector.at()`

  - 在内部方便的进行插入和删除操作

  - 可在两端进行 push、pop

- `缺点`

  占用内存多

## `map`

| 映射                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率  | 增删效率  |
| :------------------- | :------- | :------- | :--------------- | :----------- | :-------- | :-------- |
| `std::map`           | 红黑树   | key 有序 | key 不可重复     | key 不可修改 | `O(logn)` | `O(logn)` |
| `std::multimap`      | 红黑树   | key 有序 | key 可重复       | key 不可修改 | `O(logn)` | `O(logn)` |
| `std::unordered_map` | 哈希表   | key 无序 | key 不可重复     | key 不可修改 | `O(1)`    | `O(1)`    |

### `map`

#### map 底层解决哈希冲突的方法是什么

拉链法

#### 拉链法的链表越来越长时，如何优化

> 可以考虑用跳表来解决链表查找数据慢的问题

- [`unordered_map` 防止大量哈希冲突](https://blog.csdn.net/aoying6521/article/details/101785669)：基于一个随机时间的种子再配上一些奇怪的数字让你的程序抖动得更强

- `负载因子（load factor）`

  - 负载因子就是哈希桶平均存储的节点数量

  - 用于衡量容器存储键值对的空 / 满程序，`负载因子越大，意味着容器越【满】`，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率，反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少

- 选取负载因子的时候，应该考虑什么

  负载因子小，内存浪费高；负载因子大，查询速度慢，做不到 o(1)

- 如何保证负载因子一直处于很小的值

  通过 rehash（即重新计算哈希），当表的负载因子过高的时候，增加桶数来降低负载因子

- 当单个桶负载的节点数量很高的时候，增加桶一定可以降低负载因子吗

  不一定，当所有的节点都负载到同一个桶上时，说明 hash 算法冲突率过高。

- `用红黑树`

  自平衡的二叉查找树。这个自平衡的特性就是对 HashMap 中链表可能会很长做出的优化

### `unordered_map`

- [map 和 unordered_map 比较](https://blog.csdn.net/BillCYJ/article/details/78985895)

- [map 和 unordered_map 以 `char *` 为 key](https://www.xuebuyuan.com/1321846.html)

- 对于自定义的类型, 需要确定 hash 函数和 cmp 函数

- 可以使用方括号访问键对应的值 `map[key]`，如果该 `key` 不存在，C++ 会自动创建这个 `key`，并把 `map[key]` 赋值为 0

### `multimap`

- [multimap 中一个 key 对应多个键值的查询处理](https://blog.csdn.net/u013427969/article/details/52675992)

### ★ `unordered_map` 和 `map` 的区别是什么

- `存储结构`

  - unordered_map 采用哈希表存储

  - map 一般采用红黑树实现

- `查询速度`

  - unordered_map 查找速度会比 map 快，而且查找速度基本和数据数据量大小，属于常数级别 `O(1)`

  - map 的查找速度是 `O(log(n))` 级别。并不一定常数就比 log(n) 小，hash 还有 hash 函数的耗时

- `内存占用`

  unordered_map 占用的内存会更多，且 unordered_map 的构造速度较慢

- `构造函数`

  - unordered_map 需要哈希函数

  - map 只需要比较函数

### map 底层实现是什么，为什么要用红黑树

- 红黑树插入和删除的效率要比 AVL 高，因为 `红黑节点比平衡二叉树节点的旋转次数要少点`

- AVL 为了保证平衡状态，会经过多次旋转

- AVL 的查找效率高，是因为 AVL 树是完全平衡的，他的查找效率就要高点

## `set` 集合

| 集合                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率  | 增删效率  |
| :------------------- | :------- | :------- | :--------------- | :----------- | :-------- | :-------- |
| `std::set`           | 红黑树   | 有序     | 否               | 否           | `O(logn)` | `O(logn)` |
| `std::multiset`      | 红黑树   | 有序     | 是               | 否           | `O(logn)` | `O(logn)` |
| `std::unordered_set` | 哈希表   | 无序     | 否               | 否           | `O(1)`    | `O(1)`    |

## `priority_queue` 优先队列

- [STL - 优先队列](https://www.cnblogs.com/xzxl/p/7266404.html)

- [heap](https://www.cnblogs.com/woxiaosade/p/10628388.html)
