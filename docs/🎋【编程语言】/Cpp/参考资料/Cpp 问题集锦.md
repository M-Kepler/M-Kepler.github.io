- [前言](#前言)
- [1：内存对齐的原则以及作用](#1内存对齐的原则以及作用)
- [2：变量的声明和定义有什么区别](#2变量的声明和定义有什么区别)
- [3：explicit 关键字的作用](#3explicit-关键字的作用)
- [4：写出 bool 、int、 float、指针变量与 “零值” 比较的 if 语句](#4写出-bool-int-float指针变量与-零值-比较的-if-语句)
- [5：内存溢出，内存泄漏的原因？](#5内存溢出内存泄漏的原因)
- [6：sizeof 和 strlen 的区别](#6sizeof-和-strlen-的区别)
- [7：Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别](#7ｃ中的-malloc-和ｃ中的-new-有什么区别)
- [8：写一个 “标准” 宏 MIN](#8写一个-标准-宏-min)
- [9：一个指针可以是 volatile 吗](#9一个指针可以是-volatile-吗)
- [10：a 和 & a 有什么区别](#10a-和--a-有什么区别)
- [11：简述 C、C++ 程序编译的内存分配情况](#11简述-cc-程序编译的内存分配情况)
- [12：STL 中 map 和 set 的原理（关联式容器）](#12stl-中-map-和-set-的原理关联式容器)
- [13：C++ 文件编译与执行的四个阶段](#13c-文件编译与执行的四个阶段)
- [14：面向对象的三大特征](#14面向对象的三大特征)
- [15：C++ 的空类有哪些成员函数](#15c-的空类有哪些成员函数)
- [16：谈谈你对拷贝构造函数和赋值运算符的认识](#16谈谈你对拷贝构造函数和赋值运算符的认识)
- [17：STL 中的 vector 的实现，是怎么扩容的](#17stl-中的-vector-的实现是怎么扩容的)
- [18：用 C++ 设计一个不能被继承的类](#18用-c-设计一个不能被继承的类)
- [19：STL 中 unordered_map 和 map 的区别](#19stl-中-unordered_map-和-map-的区别)
- [20：简述类成员函数的重写、重载和隐藏的区别](#20简述类成员函数的重写重载和隐藏的区别)
- [21：简述多态实现的原理](#21简述多态实现的原理)
- [22：C++ 的内存管理](#22c-的内存管理)
- [23：简述一下 C++ 编译过程](#23简述一下-c-编译过程)
- [24：构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因](#24构造函数为什么一般不定义为虚函数而析构函数一般写成虚函数的原因)
- [25：简述大端、小端模式](#25简述大端小端模式)
- [26：.i++ 是否为原子操作](#26i-是否为原子操作)
- [27：指针与引用的区别](#27指针与引用的区别)
- [28：new 与 malloc 的区别](#28new-与-malloc-的区别)
- [29：写一个 “标准” 宏 MIN](#29写一个-标准-宏-min)
- [30：typedef 和 define 有什么区别](#30typedef-和-define-有什么区别)
- [31：关键字 const 的作用](#31关键字-const-的作用)
- [32：关键字 static 的作用](#32关键字-static-的作用)
- [33：extern 关键字的作用](#33extern-关键字的作用)
- [34：流操作符重载为什么返回引用](#34流操作符重载为什么返回引用)
- [35：什么情况下会调用拷贝构造函数（三种情况）](#35什么情况下会调用拷贝构造函数三种情况)
- [36：类型安全以及 C++ 中的类型转换？](#36类型安全以及-c-中的类型转换)
- [37：如何避免 “野指针”](#37如何避免-野指针)
- [38：typdef 和 define 区别](#38typdef-和-define-区别)
- [39：动态绑定与静态绑定](#39动态绑定与静态绑定)
- [40：智能指针怎么实现？什么时候改变引用计数？](#40智能指针怎么实现什么时候改变引用计数)
- [41：栈溢出的原因以及解决方法](#41栈溢出的原因以及解决方法)
- [42：构造函数能否为虚函数](#42构造函数能否为虚函数)
- [43：谈谈你对面向对象的认识](#43谈谈你对面向对象的认识)
- [44：引用作为函数参数以及返回值的好处](#44引用作为函数参数以及返回值的好处)

---

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/EhpFOHVPH1O-zjLKbU9TqQ)

### 前言

经常回顾 C/C++ 面试题和笔试题，有助于我们对 C/C++ 基础有一个新的认识和记忆。在实际工作中，大部分人会被业务缠身，基础慢慢的遗忘了，对很多基础知识欲言又止！回顾笔试面试题目，会让我们对基础知识掌握更加牢固，同时笔试题也有助于我们开阔思路，提高编程能力，还有就是开源代码阅读，只有不断的回顾和学习，才能不断的进步。

加油吧！打工人！~

### 1：内存对齐的原则以及作用

- 结构体内的成员按自身长度自对齐

  32 位机器上，如 `char=1，short=2，int=4，double=8`，所谓自对齐是指该成员的起始地址必须是它自身长度的整数倍。如 int 只能以 0,4,8 这类地址开始。

- 结构体的总大小为结构体的有效对齐值的整数倍（默认以结构体中最长的成员长度为有效值的整数倍，当用 `#pragrma pack(n)` 指定时，以 n 和结构体中最长的成员的长度中较小者为其值）。即 sizeof 的值，必须是其内部最大成员的整数倍，不足的要补齐。

```c++
class A
{
    char c;
    int a;
    char d;
};

cout << sizeof(A) << endl;

class B
{
    char c;
    char d;
    int a;
};

cout << sizeof(B) << endl;
sizeof（A）=12，sizeof（B）=8；

// 因为左边是 1 +(3)+4+1+(3)=12，而右边是 1+1+(2)+4=8。括号中为补齐的字节。
```

- `内存对齐的作用`

  - 平台原因 (移植原因)

    不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

  - `性能原因`

    经过内存对齐后，CPU 的内存访问速度大大提升。

### 2：变量的声明和定义有什么区别

为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间， 如外部变量。

### 3：explicit 关键字的作用

C++ 中， 一个参数的 构造函数 (或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。1 是个 构造器 ，2 是个默认且隐含的类型转换操作符。
所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好 XXX 的类型正好是 AAA 单参数构造器的参数类型， 这时候 编译器就自动调用这个构造器， 创建一个 AAA 的对象。
这样看起来好象很酷， 很方便。但在某些情况下（见下面权威的例子）， 却违背了我们（程序员）的本意。这时候就要在这个构造器前面加上 explicit 修饰， 指定这个构造器只能被明确的调用 / 使用， 不能作为类型转换操作符被隐含的使用。

```c++
class Test1
{
public:
    Test1(int n)
    {
        num=n;
    }//普通构造函数
private:
    int num;
};
class Test2
{
public:
    explicit Test2(int n)
    {
        num=n;
    }//explicit(显式)构造函数
private:
    int num;
};
int main()
{
    Test1 t1=12;//隐式调用其构造函数,成功
    Test2 t2=12;//编译错误,不能隐式调用其构造函数
    Test2 t2(12);//显式调用成功
    return 0;
}
```

Test1 的 构造函数带一个 int 型的参数，代码 23 行会隐式转换成调用 Test1 的这个构造函数。而 Test2 的构造函数被声明为 explicit（显式），这表示不能通过隐式转换来调用这个构造函数，因此代码 24 行会出现编译错误。
普通构造函数能够被 隐式调用。而 explicit 构造函数只能被显式调用。

### 4：写出 bool 、int、 float、指针变量与 “零值” 比较的 if 语句

```c++
bool 型数据：
if( flag )
{
  A;
}
else
{
  B；
}
int 型数据：
if( 0 != flag )
{
  A;
}
else {
  B；
}
指针型数：
if( NULL == flag )
{
  A;
}
else {
  B；
}
float 型数据：
if ( ( flag >= NORM ) && ( flag <= NORM ) )
{
  A；
}
```

注意：应特别注意在 int、指针型变量和 “零值” 比较的时候，把 “零值” 放在左边，这样当把 “==” 误写成“=” 时，编译器可以报错，否则这种逻辑错误不容易发现，并且可能导致很严重的后果。

### 5：内存溢出，内存泄漏的原因？

内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。原因可能如下：

内存中加载的数据量过于庞大，如一次从数据库取出过多数据
代码中存在死循环或循环产生过多重复的对象实体
递归调用太深，导致堆栈溢出等
内存泄漏最终导致内存溢出
内存泄漏是指向系统申请分配内存进行使用（new），但是用完后不归还（delete），导致占用有效内存。常见的几种情况：

（1） 在类的构造函数和析构函数中没有匹配的调用 new 和 delete 函数

```c++
两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构 函数中没有释放内存或者没有正确的释放内存</br>
```

（2） 在释放对象数组时在 delete 中没有使用方括号

```
方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值病调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。</br>
```

（3）没有将基类的析构函数定义为虚函数

```
当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</br>

 参考链接：https://blog.csdn.net/hyqwmxsh/article/details/52813307

 缓冲区溢出（栈溢出）</br>
 程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。</br>
```

### 6：sizeof 和 strlen 的区别

sizeof 和 strlen 有以下区别：
1 sizeof 是一个操作符，strlen 是库函数。
2 sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
3 编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。
4 数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。
注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是 sizeof。

### 7：Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别

malloc 和 new 有以下不同

- new、delete 是操作符，可以重载，只能在 C++ 中使用。

- malloc、free 是函数，可以覆盖，C、C++ 中都可以使用。

- new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

- malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

- new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。

### 8：写一个 “标准” 宏 MIN

```c++
#define min(a,b)((a)<=(b)?(a):(b))
注意：在调用时一定要注意这个宏定义的副作用，如下调用：
((++*p)<=(x)?(++*p):(x)。
p 指针就自加了两次，违背了 MIN 的本意。
```

### 9：一个指针可以是 volatile 吗

可以，因为指针和普通变量一样，有时也有变化程序的不可控性。常见例：子中断服务子程序修改一个指向一个 buffer 的指针时，必须用 volatile 来修饰这个指针。
说明：指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型数据，和整型变量不同的是，这个整型数据指向的是一段内存地址。

### 10：a 和 & a 有什么区别

请写出以下代码的打印结果，主要目的是考察 a 和 & a 的区别。

```c++
#include<stdio.h>
void main( void )
{
    int a[5]={1,2,3,4,5};
    int *ptr=(int *)(&a+1);
    printf("%d,%d",*(a+1),*(ptr-1));   return;
}

/**
 * 输出结果：2，5。
 * 数组名 a 可以作数组的首地址，而 &a 是数组的指针
 * 思考，将原式的 int _ptr=(int _)(&a+1); 改为 int _ptr=(int _)(a+1); 时输出结果将是什么呢？
 */
```

### 11：简述 C、C++ 程序编译的内存分配情况

C、C++ 中内存分配方式可以分为三种：

- 从静态存储区域分配：

  内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static 变量等。

- 在栈上分配：

  在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

- 从堆上分配：

  即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个 C、C++ 程序编译时内存分为 5 大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

### 12：STL 中 map 和 set 的原理（关联式容器）

map 和 set 的底层实现主要通过`红黑树`来实现

- 红黑树是一种特殊的二叉查找树

  - 每个节点或者是黑色，或者是红色

  - 根节点是黑色

  - 每个叶子节点（NIL）是黑色。[注意：这里叶子节点，是指为空 (NIL 或 NULL) 的叶子节点！]

  - 如果一个节点是红色的，则它的子节点必须是黑色的

  - 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

  - 特性 4）5）决定了没有一条路径会比其他路径长出 2 倍，因此红黑树是接近平衡的二叉树。

### 13：C++ 文件编译与执行的四个阶段

- 预处理：根据文件中的预处理指令来修改源文件的内容

- 编译：编译成汇编代码

- 汇编：把汇编代码翻译成目标机器指令

- 链接：链接目标代码生成可执行程序

### 14：面向对象的三大特征

面向对象的三大特征是封装性、继承性和多态性：

- 封装性

  将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected， public）。

- 继承性

  广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承 (子窗体使用父窗体的外观和实现代码)、接口继承 (仅使用属性和方法, 实现滞后到子类实现)。

- 多态性

  是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

说明：面向对象的三个特征是实现面向对象技术的关键，每一个特征的相关技术都非常的复杂，程序员应该多看、多练。

### 15：C++ 的空类有哪些成员函数

- 缺省构造函数。

- 缺省拷贝构造函数。

- 缺省析构函数。

- 缺省赋值运算符。

- 缺省取址运算符。

- 缺省取址运算符 const。

注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。

### 16：谈谈你对拷贝构造函数和赋值运算符的认识

拷贝构造函数和赋值运算符重载有以下两个不同之处：

- 拷贝构造函数生成新的类对象，而赋值运算符不能。

- 由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

### 17：STL 中的 vector 的实现，是怎么扩容的

vector 使用的注意点及其原因，频繁对 vector 调用 push_back() 对性能的影响和原因。vector 就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比 array 是静态空间一旦配置了就不能改变大小。

vector 的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在 VS 下是 1.5 倍扩容，在 GCC 下是 2 倍扩容。

在原来空间不够存储新值时，每次调用 push_back 方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。

### 18：用 C++ 设计一个不能被继承的类

```c++
template <typename T> class A
{
    friend T; private:
    A() {}
    ~A() {}
};

class B : virtual public A<B>
{
public:
    B() {}
    ~B() {}
};

class C : virtual public B
{
public:
    C() {}
    ~C() {}
};

void main( void )
{
    B b;  //C c;
    return;
}
```

注意：构造函数是继承实现的关键，每次子类对象构造时，首先调用的是父类的构造函数，然后才是自己的。

### 19：STL 中 unordered_map 和 map 的区别

map 是 STL 中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在 map 内部所有的数据都是有序的，且 map 的查询、插入、删除操作的时间复杂度都是 O(logN)。

unordered_map 和 map 类似，都是存储 key-value 对，可以通过 key 快速索引到 value，不同的是 unordered_map 不会根据 key 进行排序。unordered_map 底层是一个防冗余的哈希表，存储时根据 key 的 hash 值判断元素是否相同，即 unoredered_map 内部是无序的。

### 20：简述类成员函数的重写、重载和隐藏的区别

- 重写和重载主要有以下几点不同。

  - 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同

  - 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。

- virtual 的区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被 virtual 修饰，也可以没有。

- 隐藏和重写、重载有以下几点不同。

  - 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。

  - 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写。

说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

### 21：简述多态实现的原理

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr（对 vc 编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。
如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。
注意：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态 C++ 面试的重要考点之一，而虚函数是实现多态的基础。

### 22：C++ 的内存管理

在 C++ 中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区

栈：存放函数的参数和局部变量，编译器自动分配和释放

堆：new 关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收

自由存储区：由 malloc 分配的内存，和堆十分相似，由对应的 free 进行释放

全局 / 静态存储区：存放全局变量和静态变量

常量区：存放常量，不允许被修改

### 23：简述一下 C++ 编译过程

![alt](https://mmbiz.qpic.cn/mmbiz_png/QV1tlbY17b5hMMAGl4hXwwPhf085hRJ01DNw0RdrbABo4lB0uLQ0karB1OOH3X6vBOjmJDicTG3L6ZEvJ3mKefg/640?wx_fmt=png)

### 24：构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是 “先进先出”，栈是 “后进先出”。
注意：区别栈区和堆区。堆区的存取是 “顺序随意”，而栈区是 “后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。
1、构造函数不能声明为虚函数

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

2、析构函数最好声明为虚函数

首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。1、构造函数不能声明为虚函数

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

2、析构函数最好声明为虚函数

首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

### 25：简述大端、小端模式

大端模式，是指数据的高字节保存在内存的低地址。
小端模式，是指数据的高字节保存在内存的高地址中

![alt](https://mmbiz.qpic.cn/mmbiz_png/QV1tlbY17b5hMMAGl4hXwwPhf085hRJ0Jmh8WtLEBmibBogr6d8R8DRs7KdYIckEoXGXlZdjSknuovaMyqia7avg/640?wx_fmt=png)

使用程序判断大小端：

```cpp
    int a=1;
    char *p=(char *)&a;
    if(*p==1) printf("小端\n");
    else      printf("大端\n");
```

### 26：.i++ 是否为原子操作

不是。操作系统原子操作是不可分割的，在执行完毕不会被任何其它任务或事件中断，分为两种情况（两种都应该满足）

（1） 在单线程中， 能够在单条指令中完成的操作都可以认为是 "原子操作"，因为中断只能发生于指令之间。

（2） 在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。i++ 分为三个阶段：

内存到寄存器
寄存器自增
写回内存
这三个阶段中间都可以被中断分离开.

### 27：指针与引用的区别

(1) 指针只是一个变量，只不过这个变量存储的是一个地址；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已，不占用内存空间。(2) 引用必须在定义的时候初始化，而且初始化后就不能再改变；而指针不必在定义的时候初始化，初始化后可以改变。(3) 指针可以为空，但引用不能为空（这就意味着我们拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。） (4)“sizeof 引用 "= 指向变量的大小 ，"sizeof 指针 "= 指针本身的大小 (5) 指针可以有多级，而引用只能是一级

### 28：new 与 malloc 的区别

(1)malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。
(2) 对于非内部数据类型的对象而言，光用 malloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
(3)new 可以认为是 malloc 加构造函数的执行。new 出来的指针是直接带类型信息的。而 malloc 返回的都是 void 指针。

### 29：写一个 “标准” 宏 MIN

写一个 “标准” 宏 MIN，这个宏输入两个参数并且返回较小的一个。

```c++
#define min(a,b)((a)<=(b)?(a):(b))
// 注意：在调用时一定要注意这个宏定义的副作用，如下调用：
((++*p)<=(x)?(++*p):(x)。
// p 指针就自加了两次，违背了 MIN 的本意。
```

### 30：typedef 和 define 有什么区别

（1） 用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。
（2） 执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。
（3） 作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。（4） 对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。
注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。

### 31：关键字 const 的作用

(1) 定义变量为只读变量，不可修改
(2) 修饰函数的参数和返回值（后者应用比较少，一般为值传递）
(3)const 成员函数（只需要在成员函数参数列表后加上关键字 const，如 char get() const;）可以访问 const 成员变量和非 const 成员变量，但不能修改任何变量。在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为 const 成员函数。
(4)const 对象只能访问 const 成员函数, 而非 const 对象可以访问任意的成员函数, 包括 const 成员函数. 即对于 class A，有 const A a；那么 a 只能访问 A 的 const 成员函数。而对于：A b；b 可以访问任何成员函数。

(5) 使用 const 关键字修饰的变量，一定要对变量进行初始化

### 32：关键字 static 的作用

1）函数体内：static 修饰的局部变量作用范围为该函数体，不同于 auto 变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值

2）模块内：static 修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内

3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝

4）类中：修饰成员函数，表示该函数属于整个类所有，不接受 this 指针，只能访问类中的 static 成员变量

注意和 const 的区别！！！const 强调值不能被修改，而 static 强调唯一的拷贝，对所有类的对象

### 33：extern 关键字的作用

extern 置于变量或函数前，用于标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。它只要有两个作用：

(1)当它与 “C” 一起连用的时候，如：extern "C" void fun(int a,int b); 则告诉编译器在编译 fun 这个函数时候按着 C 的规矩去翻译，而不是 C++ 的（这与 C++ 的重载有关，C++ 语言支持函数重载，C 语言不支持函数重载，函数被 C++ 编译器编译后在库中的名字与 C 语言的不同）
(2)当 extern 不与 “C” 在一起修饰变量或函数时，如：extern int g_Int；它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用。记住它是一个声明不是定义! 也就是说 B 模块 (编译单元) 要是引用模块(编译单元)A 中定义的全局变量或函数时，它只要包含 A 模块的头文件即可, 在编译阶段，模块 B 虽然找不到该函数或变量，但它不会报错，它会在连接时从模块 A 生成的目标代码中找到此函数。

### 34：流操作符重载为什么返回引用

在程序中，流操作符 >> 和 << 经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。
注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如 +、-、\*、/ 等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

### 35：什么情况下会调用拷贝构造函数（三种情况）

系统自动生成的构造函数：普通构造函数和拷贝构造函数 （在没有定义对应的构造函数的时候）

生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数

调用拷贝构造函数的情形：

1）用类的一个对象去初始化另一个对象的时候

2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用

3）当函数的返回值是类的对象或者引用的时候

```c++
#include <iostream>
#include <string>

using namespace std;

class A{
private:
    int data;
public:
    A(int i){ data = i;}  //自定义的构造函数
    A(A && a);     //拷贝构造函数
    int getdata(){return data;}
};

//拷贝构造函数
A::A(A && a) {
    data = a.data;
    cout <<"拷贝构造函数执行完毕"<<endl;
}
//参数是对象，值传递，调用拷贝构造函数
int getdata1(A a)
{
    return a.getdata();
}
//参数是引用，引用传递，不调用拷贝构造函数
int getdata2(A &a)
{
    return a.getdata();
}
//返回值是对象类型，会调用拷贝构造函数
A getA1()
{
    A a(0);
    return a;
}
//返回值是引用类型，会调用拷贝构造函数，因为函数体内生成的对象是临时的，离开函数就消失
A& getA2()
{
    A a(0);
    return a;
}

int main()
{
    A a1(1);
    A b1(a1);             //用a1初始化b1，调用拷贝构造函数
    A c1=a1;              //用a1初始化c1，调用拷贝构造函数

    int i=getdata1(a1);         //函数形参是类的对象，调用拷贝构造函数
    int j=getdata2(a1);       //函数形参类型是引用，不调用拷贝构造函数

    A d1=getA1();         //调用拷贝构造函数
    A e1=getA2();        //调用拷贝构造函数

    return 0;
}
```

### 36：类型安全以及 C++ 中的类型转换？

类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。C 只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C 中相当多的操作是不安全的。

四种类型转换：

static_cast <T*> (content) 静态转换. 在编译期间处理，可以实现 C++ 中内置基本数据类型之间的相互转换。如果涉及到类的话，static_cast 只能在有相互联系的类型中进行相互转换, 不一定包含虚函数。
dynamic_cast<T*>(content) 动态类型转换; 也是向下安全转型; 是在运行的时候执行; 基类中一定要有虚函数，否则编译不通过。在类层次间进行上行转换时（如派生类指针转为基类指针），dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换时（如基类指针转为派生类指针），dynamic_cast 具有类型检查的功能，比 static_cast 更安全。
const_cast<T*>(content) 去常转换; 编译时执行;
reinterpret_cast<T*>(content) 重解释类型转换;

### 37：如何避免 “野指针”

“野指针” 产生原因及解决办法如下：
（1） 指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。
（2） 指针 p 被 free 或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。
（3） 指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。注意：“野指针” 的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生 “野指针”，在使用指针前一定要检验指针的合法性。

### 38：typdef 和 define 区别

`#define` 是预处理命令，在预处理是执行简单的替换，不做正确性的检查

`typedef` 是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

```c++
typedef (int*) pINT;

#define pINT2 int*
// 效果相同？实则不同！实践中见差别：pINT a,b; 的效果同 int *a; int *b; 表示定义了两个整型指针变量。而 pINT2 a,b; 的效果同 int \*a, b; 表示定义了一个整型指针变量 a 和整型变量 b。
```

### 39：动态绑定与静态绑定

(1) 静态绑定发生在编译期，动态绑定发生在运行期；(2) 对象的动态类型可以更改，但是静态类型无法更改；(3) 要想实现动态，必须使用动态绑定；(4) 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；(5) 静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。(6) 动态多态是指通过虚函数技术实现在运行期动态绑定的技术

**动态绑定**：有一个基类，两个派生类，基类有一个 virtual 函数，两个派生类都覆盖了这个虚函数。现在有一个基类的指针或者引用，当该基类指针或者引用指向不同的派生类对象时，调用该虚函数，那么最终调用的是该被指向对象对应的派生类自己实现的虚函数。

### 40：智能指针怎么实现？什么时候改变引用计数？

(1) 构造函数中计数初始化为 1；
(2) 拷贝构造函数中计数值加 1；
(3) 赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
(4) 析构函数中引用计数减一；
(5) 在赋值运算符和析构函数中，如果减一后为 0，则调用 delete 释放对象。

### 41：栈溢出的原因以及解决方法

1）函数调用层次过深, 每调用一次, 函数的参数、局部变量等信息就压一次栈

2）局部变量体积太大。

解决办法大致说来也有两种：

1> 增加栈内存的数目；增加栈内存方法如下, 在 vc6 种依次选择 Project->Setting->Link, 在 Category 中选择 output, 在 Reserve 中输入 16 进制的栈内存大小如: 0x10000000

2> 使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针, 然后动态申请内存; 也可以把局部变量变成全局变量, 一个偷懒的办法是直接在定义前边加个 static, 呵呵, 直接变成静态变量 (实质就是全局变量)

### 42：构造函数能否为虚函数

构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。
析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。
说明：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。

### 43：谈谈你对面向对象的认识

所谓的面向对象就是将我们的程序模块化，对象化，把具体事物的特性属性和通过这些属性来实现一些动作的具体方法放到一个类里面，这就是封装。封装是我们所说的面相对象编程的特征之一。除此之外还有继承和多态。继承有点类似与我们生物学上的遗传，就是子类的一些特征是来源于父类的，儿子遗传了父亲或母亲的一些性格，或者相貌，又或者是运动天赋。有点种瓜得瓜种豆得豆的意思。面向对象里的继承也就是父类的相关的属性，可以被子类重复使用，子类不必再在自己的类里面重新定义一回，父类里有点我们只要拿过来用就好了。而对于自己类里面需要用到的新的属性和方法，子类就可以自己来扩展了。当然，会出现一些特殊情况，就是我们在有一些方法在父类已经定义好了，但是子类我们自己再用的时候，发现，其实，我们的虽然都是计算工资的，但是普通员工的工资计算方法跟经理的计算方法是不一样的，所以这个时候，我们就不能直接调用父类的这个计算工资的方法了。这个时候我们就需要用到面向对象的另一个特性，多态。对，就是多态，我们要在子类里面把父类里面定义计算工资的方法在子类里面重新实现一遍。多态包含了重载和重写。重写很简单就是把子类从父亲类里继承下来的方法重新写一遍，这样，父类里相同的方法就被覆盖了，当然啦，你还是可以通过 super.CaculSalary 方法来调用父类的工资计算方法。而重载就是类里面相同方法名，不同形参的情况，可以是形参类型不同或者形参个数不同，或者形参顺序不同，但是不能使返回值类型不同。

### 44：引用作为函数参数以及返回值的好处

对比值传递，引用传参的好处：

1）在函数内部可以对此参数进行修改

2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过 “形参 = 实参” 来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

2）不能返回函数内部 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak

3）可以返回类成员的引用，但是最好是 const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。

![alt](https://mmbiz.qpic.cn/mmbiz_png/US10Gcd0tQHmdzSPtH4ymM026N4bDfJf33XzUEW427H9v57dI8DprKMicE9bGFqlLKfgebDpjAto5XSiaxAIUkww/640?wx_fmt=png)
