- [讲解类型问题](#讲解类型问题)
  - [Q：说说 ACK 报文？](#q说说-ack-报文)
  - [Q：说说滑动窗口？](#q说说滑动窗口)
  - [Q：说说零窗口探测？](#q说说零窗口探测)
  - [Q：说说拥塞控制？使用了哪些算法？](#q说说拥塞控制使用了哪些算法)
  - [Q：说说快速重试机制（拥塞控制）？](#q说说快速重试机制拥塞控制)
  - [Q：说说滑动窗口与拥塞控制的关系？](#q说说滑动窗口与拥塞控制的关系)
  - [Q：Nagle 算法的意义在哪里？](#qnagle-算法的意义在哪里)
  - [Q：延迟确认的作用？](#q延迟确认的作用)
  - [Q：TCP 的 keepalive 与 HTTP 的 keep-alive 有什么区别？](#qtcp-的-keepalive-与-http-的-keep-alive-有什么区别)
  - [Q：说说 TCP 有哪些定时器？](#q说说-tcp-有哪些定时器)
  - [Q：说说 TCP 快速打开(TFO)](#q说说-tcp-快速打开tfo)
  - [Q：说说 SO_REUSEADDR 套接字选项，以及为什么不会出现在客户端上](#q说说-so_reuseaddr-套接字选项以及为什么不会出现在客户端上)
  - [谈谈你对停止等待协议的理解？](#谈谈你对停止等待协议的理解)
  - [谈谈你对 ARQ 协议的理解？](#谈谈你对-arq-协议的理解)
- [分析类型问题](#分析类型问题)
  - [Q：TCP 如何保证可靠性](#qtcp-如何保证可靠性)
  - [Q：为什么握手是 3 次，而不是...次？（三次握手的意义）](#q为什么握手是-3-次而不是次三次握手的意义)
  - [Q：两次握手（去掉最后一次普通确认报文）可以吗？](#q两次握手去掉最后一次普通确认报文可以吗)
  - [Q：握手可以变为四次吗？会怎么样？](#q握手可以变为四次吗会怎么样)
  - [Q：为什么挥手要四次，变为三次会怎么样？](#q为什么挥手要四次变为三次会怎么样)
  - [Q：为什么连接建立的时候是握手三次，关闭的时候却是挥手四次？](#q为什么连接建立的时候是握手三次关闭的时候却是挥手四次)
  - [Q：客户端关闭链接为什么要等待 2 倍 MSL 才进入 CLOSED](#q客户端关闭链接为什么要等待-2-倍-msl-才进入-closed)
  - [Q：为什么时间是两个 MSL？](#q为什么时间是两个-msl)
  - [Q:生产中大量 timewait 状态的连接怎么办？](#q生产中大量-timewait-状态的连接怎么办)
- [其他分析类型问题](#其他分析类型问题)
  - [Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？](#q如果已经建立了连接但是客户端突然出现故障了怎么办)
  - [Q：如果有大量 TIME_WAIT 状态的连接会怎么样呢？](#q如果有大量-time_wait-状态的连接会怎么样呢)
  - [Q：收到 IP 数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）](#q收到-ip-数据包解析以后它怎么知道这个分组应该投递到上层的哪一个协议udp-或-tcp)
  - [Q：为什么 SYN 段不携带数据却要消耗一个序列号呢？](#q为什么-syn-段不携带数据却要消耗一个序列号呢)
  - [Q：ISN 能设置成一个固定值吗？](#qisn-能设置成一个固定值吗)
  - [Q：如果 FIN 段不消耗一个序列号会发生什么?](#q如果-fin-段不消耗一个序列号会发生什么)
  - [Q：如何应对 SYN Flood 攻击](#q如何应对-syn-flood-攻击)
  - [Q：RST 包如果丢失了怎么办？](#qrst-包如果丢失了怎么办)
  - [Q：如何处理 TCP 粘包？](#q如何处理-tcp-粘包)
- [未整理](#未整理)

## 讲解类型问题

### Q：说说 ACK 报文？

- 表示这之前的包都已经全部收到

### Q：说说滑动窗口？

- 滑动窗口（流量控制）做的事情就是，如果接收缓冲区（接收窗口）已满，发送端应该停止发送数据。
- 为了控制发送端的速率（可以被发送的字节序列范围）

### Q：说说零窗口探测？

- 利用滑动窗口来实现流量控制时，当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，因此需 PERSIST 定时器检测来告知发送端 接收端是否恢复了接收窗口

### Q：说说拥塞控制？使用了哪些算法？

- 拥塞处理（控制拥塞窗口/可发送的最大 MSS 段数），防止过多的数据注入到网络导致过载
- 主要涉及到下面这几个算法
  - 慢启动（Slow Start）拥塞窗口 2 的指数级增长
  - 拥塞避免（Congestion Avoidance）拥塞窗口大于慢启动阈值时线性增长
  - 快速重传（Fast Retransmit）
  - 快速恢复（Fast Recovery） 当收到三次重复 ACK 时拥塞窗口设置为慢启动阈值一般

### Q：说说快速重试机制（拥塞控制）？

- 当接收端收到一个不按序到达的数据段时，TCP 立刻发送 1 个重复 ACK，而不用等有数据捎带确认
- 当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到重传定时器超时再重传。
- 接收端利用 SACK（Selective Acknowledgment）告诉对端已收到的序列号范围

### Q：说说滑动窗口与拥塞控制的关系？

- 滑动窗口（流量控制）这种机制确实可以防止发送端向接收端过多的发送数据，但是它只关注了发送端和接收端自身的状况
- 而拥塞控制是考虑整个网络的通信状况，对发送端进行限制(慢启动/拥塞避免)

### Q：Nagle 算法的意义在哪里？

- Nagle 算法的作用是减少 小包在客户端和服务端直接传输（尽可能合并小包发送），但在通信时延较低的场景下意义不大

### Q：延迟确认的作用？

- 回复一个空的 ACK 太浪费了。为减少发送次数（尽可能捎带数据与 ACK 一起发送）

### Q：TCP 的 keepalive 与 HTTP 的 keep-alive 有什么区别？

- HTTP 的 keepalive 是保证 tcp 连接不过早关闭，比如 http 设置的 keep-alive 为 120s，然后当一次 http 响应结束后，不是立即关闭这个 tcp 连接，而是等 120s（尽可能在当前 TCP 中进行更多通信）。
- tcp 的 keepalive 是做链路检测。通信以后一段时间有再也没有传输过数据,探测连接是否失效

### Q：说说 TCP 有哪些定时器？

- 连接建立定时器
- 重传定时器
- 延迟 ACK 定时器
- PERSIST 定时器(零窗口探测)
- KEEPALIVE 定时器
- FIN_WAIT_2 定时器
- TIME_WAIT 定时器

### Q：说说 TCP 快速打开(TFO)

- 一种补充协议，在发送第一个 SYN 包的时候就开始传数据了，不过它要求当前客户端之前已经完成过「正常」的三次握手
- 可以减少一次在握手后发送/响应的交互，在握手的同时发送/响应数据
- 通过接收端生成/接收校验 Cookie，发送方存储/发送 Cookie 的方式

### Q：说说 SO_REUSEADDR 套接字选项，以及为什么不会出现在客户端上

- SO_REUSEADDR 开启后可以接触对仍有被连接的端口绑定操作的限制（重用端口）
- 因为客户端都是用的临时端口，这些临时端口与处于 TIME_WAIT 状态的端口恰好相同的可能性不大

### 谈谈你对停止等待协议的理解？

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

### 谈谈你对 ARQ 协议的理解？

自动重传请求 ARQ 协议
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ

## 分析类型问题

### Q：TCP 如何保证可靠性

• 数据包校验
• 超时重传机制
• 应答机制
• 对失序数据包重排序 SACK
• 流量控制
• 超时重发
• 停止等待协议
• 丢弃重复数据

### Q：为什么握手是 3 次，而不是...次？（三次握手的意义）

- 3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，
- 也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认

### Q：两次握手（去掉最后一次普通确认报文）可以吗？

- 不可以
- A.如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认
- B.会出现已失效的 tcp 请求又传送到 TCP 服务器现象
  - 因为 A 原因，两次握手接收方的序列号没得到发送方确认就会任务连接已建立开始传输数据。
  - 当发送方首次请求超时重发，并且二次请求正常传输完毕 close 后，首次请求延迟到来
  - 那么接收方会接收到序列号错误的请求信息并且回复 ACK，并等待不到数据发送。
  - 如果是三次握手，这种情况下，发送方会发现数据异常并发复位连接，让接收方释放资源。

### Q：握手可以变为四次吗？会怎么样？

- 理论上完全是可以的
  ![alt](../../../docs/images/FE52D39FE8A14C5FA9F8FC44AD9D345F.png)
- 与 FIN 包不同的是，一般情况下，SYN 包都不携带数据，收到客户端的 SYN 包以后不用等待，可以立马回复 SYN+ACK，四次握手理论上可行，但是现实中不实用

### Q：为什么挥手要四次，变为三次会怎么样？

> 首先我们先明确一个问题，TCP 连接终止一定要四次包交互吗？三次可以吗？

- 当然可以，因为有延迟确认的存在
- 如果服务端确定没有什么数据需要发给客户端，那么当然是可以把 FIN 和 ACK 合并成一个包，四次挥手的过程就成了三次。
- 如果服务端确认 FIN 之后仍有数据需要发送，三次挥手的话服务端不及时发送 ACK 包，客户端等不到 ACK 会造成客户端不必要的重发 FIN 包
  ![alt](../../../docs/images/37026638C8C049959ADD7F7EDE650B1E.png)

### Q：为什么连接建立的时候是握手三次，关闭的时候却是挥手四次？

- 因为建立连接时还没有数据通信 接收端可以同时发送 ACK+SYN（确认连接/交换序列号等信息）
- 而关闭连接时被关闭方需要先发 ACK（确认关闭），等待通信发完再发送 FIN（告知主动关闭方可关闭）

### Q：客户端关闭链接为什么要等待 2 倍 MSL 才进入 CLOSED

- 保证 TCP 协议的全双工连接能够可靠关闭-
  > 防止 Server 没有收到 Client 最后回复的 ACK 的情况，这时候 Server 会重发 FIN，==如果 Client 已经 CLOSED 了，就找不到与重发的 FIN 对应的连接，最后 Server 就会收到 RST 而不是 ACK== ，Server 就会以为是连接错误把问题报告给高层。
- 保证这次连接的延迟数据段从网络中消失
  > 假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达 Server，由于新连接和老连接的端口号是一样的，又因为 TCP 协议判断不同连接的依据是 socket pair，==TCP 协议就认为那个延迟的数据是属于新连接的==，这样就和真正的新连接的数据包发生混淆了。

### Q：为什么时间是两个 MSL？

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保如果被关闭方没有收到 ACK, 被关闭方重传的 FIN 报文可以到达
- 2MSL = 去向 ACK 消息最大存活时间（MSL) + 来向 FIN 消息的最大存活时间（MSL）

### Q:生产中大量 timewait 状态的连接怎么办？

- 根据业务把 http 设置 keepalive
- 设置允许端口重用
- 缩短 timewait 默认时间

## 其他分析类型问题

### Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？

- 考点为 TCP keepalive 计时器

### Q：如果有大量 TIME_WAIT 状态的连接会怎么样呢？

- 连接无法复用 因为处于 TIME_WAIT 的连接会存活 2MSL（60s），意味着相同的 TCP 连接四元组（源端口、源 ip、目标端口、目标 ip）在一分钟之内都没有办法复用

### Q：收到 IP 数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议（UDP 或 TCP）

- 在网络互联层的 IP 协议 protocol 区分协议

### Q：为什么 SYN 段不携带数据却要消耗一个序列号呢？

- 凡是消耗序列号的 TCP 报文段，一定需要对端确认。如果这个段没有收到确认，会一直重传直到达到指定的次数为止。
- 因为 SYN 需要被确认，所以三次握手中除了最后一次发往服务端的 ACK 不占用序列号，其他两次握手都会占用

### Q：ISN 能设置成一个固定值吗？

- 出于安全性考虑。如果被知道了连接的 ISN，很容易构造一个在对方窗口内的序列号，源 IP 和源端口号都很容易伪造，这样一来就可以伪造 RST 包，将连接强制关闭掉了。
- 因为开启 SO_REUSEADDR 以后端口允许重用，收到一个包以后不知道新连接的还是旧连接的包因为网络的原因姗姗来迟，造成数据的混淆。如果采用动态增长的 ISN，那么可以保证两个连接的 ISN 不会相同，不会串包。

### Q：如果 FIN 段不消耗一个序列号会发生什么?

![alt](../../../docs/images/8821CADECD474D32A585D30955A3322F.png)

- 客户端(seq=900)发送了 100 字节的数据包和 FIN 包，都等待服务端确认。如果这个时候客户端收到了 ACK=1000 的确认包，就无法得知到底是 100 字节的确认包还是 FIN 包的确认包。

### Q：如何应对 SYN Flood 攻击

> 大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态

- 增加 SYN 连接数：tcp_max_syn_backlog
- 减少 SYN+ACK 重试次数：tcp_synack_retries
- SYN Cookie 机制: 根据 SYN 包计算出一个 Cookie 值，作为握手第二步的序列号回复 SYN+ACK，等对方回应 ACK 包时校验回复的 ACK 值是否合法，如果合法才三次握手成功，分配连接资源。

### Q：RST 包如果丢失了怎么办？

- RST 是不需要确认的。
- 服务器关闭后会返回 RST 给到请求方，就算 RST 丢失请求方重试发送后也会自行断开

### Q：如何处理 TCP 粘包？

- 什么是粘包现象
  TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

为什么出现粘包现象
发送方原因
我们知道，TCP 默认会使用 Nagle 算法。而 Nagle 算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。

所以，正是 Nagle 算法造成了发送方有可能造成粘包现象。

接收方原因
TCP 接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP 将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果 TCP 接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。

什么时候需要处理粘包现象
（1）如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；

（2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。

如何处理粘包现象
（1）发送方: 对于发送方造成的粘包现象，我们可以通过关闭 Nagle 算法来解决，使用 TCP_NODELAY 选项来关闭 Nagle 算法。

（2）接收方: 遗憾的是 TCP 并没有处理接收方粘包现象的机制，我们只能在应用层进行处理。

（3）应用层处理

应用层的处理简单易行！并且不仅可以解决接收方造成的粘包问题，还能解决发送方造成的粘包问题。

解决方法就是循环处理：应用程序在处理从缓存读来的分组时，读完一条数据时，就应该循环读下一条数据，直到所有的数据都被处理；但是如何判断每条数据的长度呢？

两种途径：

1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；

2）发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前 4 字节是数据的长度（一个 int 来储存数据长度大小），应用层处理时可以根据长度来判断每条数据的开始和结束。

## 未整理

[知乎-tcp 常见面试题](https://zhuanlan.zhihu.com/p/87310327)

```
TCP 的三次握手
假设 A 为客户端，B 为服务器端。

首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
B 收到 A 的确认后，连接建立。
三次握手的原因
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。如果由于网络不稳定，虽然客户端以前发送的连接请求以到达服务方，但服务方的同意连接的应答未能到达客户端。则客户方要重新发送连接请求，若采用二次握手，服务方收到客服端重传的请求连接后，会以为是新的请求，就会发送同意连接报文，并新开进程提供服务，这样会造成服务方资源的无谓浪费。

为什么不需要四次握手？
有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？

我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。

Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？
接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

TCP 的四次挥手
假设 A 为客户端，B 为服务器端。以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

A 发送连接释放报文，FIN=1。
B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
当 B 不再需要连接时，发送连接释放报文，FIN=1。
A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
B 收到 A 的确认后释放连接。
四次挥手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL.

确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。
主动关闭连接的一方就会进入TIME_WAIT状态。客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间(后有MSL的解释)，进入CLOSED状态。最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。假设最终的ACK丢失，主机2将重发FIN，主机1必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果主机2认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，主机1必须进入 TIME_WAIT 状态，因为主机1可能面临重发最终ACK的情形。
大多数服务器端一般执行被动关闭，服务器不会进入TIME_WAIT状态。
当在服务器端关闭某个服务再重新启动时，服务器是会进入TIME_WAIT状态的。
由于网络原因，ACK可能会发送失败，那么这个时候，被动一方会主动重新发送一次FIN，这个时候如果主动方在TIME_WAIT状态，则还会再发送一次ACK，从而保证可靠性。那么从这个解释来说，2MSL的时长设定是可以理解的，MSL是报文最大生存时间，如果重新发送，一个FIN＋一个ACK，再加上不定期的延迟时间，大致是在2MSL的范围。
SYN 攻击
在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。
检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。
SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：
缩短超时时间: 增加最大半连接数，过滤网关防护，SYN cookies技术
TCP和UDP的应用
TCP应用场景
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

UDP应用场景
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

TCP粘包
什么是粘包现象
TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

为什么出现粘包现象
发送方原因
我们知道，TCP默认会使用Nagle算法。而Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。

所以，正是Nagle算法造成了发送方有可能造成粘包现象。

接收方原因
TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。

什么时候需要处理粘包现象
（1）如果发送方发送的多个分组本来就是同一个数据的不同部分，比如一个很大的文件被分成多个分组发送，这时，当然不需要处理粘包的现象；

（2）但如果多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。

如何处理粘包现象
（1）发送方: 对于发送方造成的粘包现象，我们可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭Nagle算法。

（2）接收方: 遗憾的是TCP并没有处理接收方粘包现象的机制，我们只能在应用层进行处理。

（3）应用层处理

应用层的处理简单易行！并且不仅可以解决接收方造成的粘包问题，还能解决发送方造成的粘包问题。

解决方法就是循环处理：应用程序在处理从缓存读来的分组时，读完一条数据时，就应该循环读下一条数据，直到所有的数据都被处理；但是如何判断每条数据的长度呢？

两种途径：

1）格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；

2）发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4字节是数据的长度（一个int来储存数据长度大小），应用层处理时可以根据长度来判断每条数据的开始和结束。

TCP 协议如何来保证传输的可靠性
TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。

停止等待协议：(正常情况)发送数据包后必须等待确认才会选择继续让其发送，否则等待。(超时重传)发出一个数据包后等待一个RTT时间(往返)后若没有收到确认信息，将重新发送这个报文(默认丢失,不确认就重传)。(确认包丢失)A端发M1B端收到后,B端发给A端的确认包丢失,A端会认为超时重传会再发一次M1，此时B端不接受M1但会再发送确认包信息给A端。(确认包迟到)B端发给A端的确认包迟到，A端默认丢失超时重传，B端接收后再次发送确认包，A端收到迟到的确认包时什么也不做。(只有收到确认信息才继续，否则重发,在不可靠的网络上实现可靠的TCP通信ARQ)；

连续ARQ(发送窗口)：发送方维持发送窗口，可以一次性发送窗口大小这么多个数据包然后等待确认报文，得到确认后窗口滑动发送新的字节流报文。互相根据对方的接收缓存设置(65535)发送窗口大小(1460)；

滑动窗口：发送方和接收方都有缓冲区，发送时会维护一个以字节为单位的滑动窗口，如果收到确认后窗口就会滑动，发送缓冲区会丢弃已发送的字节，B端发送确认报文后，窗口移动(确认报文含有下一步该发哪一个字节组成的报文)。接收窗口先移动，然后发送端口移动。窗口到底后循环使用；

数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据。TCP首部中的确认序号表示已成功收到字节，但还不包括确认序号所指的字节。希望下一次能收到确认序号所指的字节。 发送端初始时序号为1，同时会发送下一次将会发送的起始序号，接收端接收后返回确认同时包含发送端下一次发送的起始序号。若返回的是确认信息(已发送的包都没必要重传)则发送端窗口移动；

对丢失的数据包段发送选择型确认：若A端发送的数据包有丢失的情况,B端会返回确认包(SAK选择型确认)会告诉A端哪个序号部分的丢失，A端会重新发这一个数据包，然后发送窗口往前移动；

丢弃重复数据：对于重复数据，能够丢弃重复数据；

应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

超时重发：当TCP发出一个段后，它启动一个计时器，等待接收端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段，时间稍大于RTT；

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。对于发送端A端与接收端B端，A有发送缓存而B有接收缓存，要发送的数据先放到A的发送缓存，建立会话时B端设置自己的接收窗口(发送Ack，rwnd(receive window)=10(字节))。A根据此设置发送窗口，此时可以连续发送数据包。B端会根据自己的情况回复成功报文(包括rwnd)，若B端压力过大rwnd的值会缩小，待B端处理后rwnd的值再进行扩展，若含有rwnd的包遗失，A端会定时发包询问。通过接收端告诉发送端接收窗口的大小来防止缓冲区溢出。

TCP head
TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。

选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息。常见的TCP选项有7种。

kind=0是选项表结束选项。

kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。

kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。

kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。

和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。

kind=4是选择性确认（Selective Acknowledgment，SACK）选项。TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。

kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。

kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。

谈谈你对停止等待协议的理解？
停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

谈谈你对 ARQ 协议的理解？
自动重传请求 ARQ 协议
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

连续 ARQ 协议
连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

谈谈你对滑动窗口的了解？
TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

谈下你对流量控制的理解？
TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

谈下你对 TCP 拥塞控制的理解？使用了哪些算法？
拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。

慢开始
慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。

拥塞避免
拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。

快重传与快恢复
在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。

没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。

有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。
```
