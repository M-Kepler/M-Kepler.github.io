- [参考资料](#参考资料)
- [`HTTP`](#http)
  - [★ `HTTP` 各版本差异](#-http-各版本差异)
    - [`HTTP 0.9`](#http-09)
    - [`HTTP 1.0`](#http-10)
    - [`HTTP 1.1`](#http-11)
    - [`HTTP 1.x` 版本存在的缺点](#http-1x-版本存在的缺点)
    - [`HTTP 2`](#http-2)
  - [`HTTP 1.1` 存在的问题](#http-11-存在的问题)
    - [为什么 `HTTP 1.1` 不能实现多路复用](#为什么-http-11-不能实现多路复用)
    - [管道化问题](#管道化问题)
    - [队头堵塞问题](#队头堵塞问题)
  - [`HTTP` 报文结构](#http-报文结构)
    - [请求头报文](#请求头报文)
    - [常见的请求头](#常见的请求头)
    - [响应报文](#响应报文)
  - [★ `HTTP` 状态码](#-http-状态码)
    - [状态码 `301` 和 `302` 的区别](#状态码-301-和-302-的区别)
    - [转发和重定向的区别](#转发和重定向的区别)
  - [★ `GET`请求和`POST`请求](#-get请求和post请求)
    - [Get 和 Post 请求的区别](#get-和-post-请求的区别)
    - [既然 POST 有这么多优点，为什么还要用 GET 呢](#既然-post-有这么多优点为什么还要用-get-呢)
  - [整个 URL 的过程,浏览器输入地址后发生了什么](#整个-url-的过程浏览器输入地址后发生了什么)
  - [一个 TCP 连接可以发多少个 HTTP 请求](#一个-tcp-连接可以发多少个-http-请求)
    - [HTTP 的 `keepalive` 和 TCP 的 `keepalive` 的联系](#http-的-keepalive-和-tcp-的-keepalive-的联系)
    - [为什么大部分应用程序都没有开启 TCP 的 keepalive 选项](#为什么大部分应用程序都没有开启-tcp-的-keepalive-选项)
    - [HTTP 能不能一次连接多次请求，不等待后端返回](#http-能不能一次连接多次请求不等待后端返回)
    - [一个 `TCP` 连接中 `HTTP` 请求可以一起发送吗](#一个-tcp-连接中-http-请求可以一起发送吗)
    - [为什么有的刷新页面不需要重新建立 `SSL` 链接](#为什么有的刷新页面不需要重新建立-ssl-链接)
    - [浏览器同一 `HOST` 建立 `TCP` 连接的数量有限制吗](#浏览器同一-host-建立-tcp-连接的数量有限制吗)
- [`HTTPS`](#https)
  - [★ `HTTP` 和 `HTTPS` 的区别](#-http-和-https-的区别)
  - [★ `SSL` 握手过程](#-ssl-握手过程)
    - [握手过程解释](#握手过程解释)
    - [抓包分析](#抓包分析)
- [其他](#其他)
  - [收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的](#收到的-html-如果包含几十个图片标签这些图片是以什么方式什么顺序建立了多少连接使用什么协议被下载下来的)

# 参考资料

- [《图解 HTTP》](https://www.cnblogs.com/edisonchou/p/6013450.html)

# `HTTP`

`Hyper Text Transfer Protocol` 超文本传输协议

## ★ `HTTP` 各版本差异

[HTTP 协议版本介绍](https://blog.csdn.net/u013967628/article/details/78521908)

[HTTP 协议版本差异 - 简述](https://blog.csdn.net/qq825524012/article/details/95103453)

| 版本                                                             | 特点                                                         |
| :--------------------------------------------------------------- | :----------------------------------------------------------- |
| `HTTP 0.9`</br> 简单的 C/S 模型                                  | 仅支持 `GET` 请求命令                                        |
|                                                                  | 只能传输`纯文本`                                             |
|                                                                  |                                                              |
| `HTTP 1.0`</br> 能用，丰富了点功能                               | 引入了 `POST`、`HEAD` 请求命令                               |
|                                                                  | 任何格式的数据都可以发送，包括图像、二进制                   |
|                                                                  | **引入 `请求 / 响应头`**                                     |
|                                                                  |                                                              |
| `HTTP 1.1`</br> 1.0 后半年就发布 1.1 </br> 解决了一下 `性能问题` | 默认支持 **`长连接`**，可以被多个请求复用                    |
|                                                                  | 引入 **`管道机制`**，以支持同时发送多个请求，响应还是有序的  |
|                                                                  | 新增 `PUT`、`PATCH`、`DELETE` 等请求命令                     |
|                                                                  | 新增 **`HOST` 头域**，支持将请求发往同一台服务器上的不同网站 |
|                                                                  |                                                              |
| `HTTP 2` </br> 功能、性能都更强劲                                | 二进制分帧                                                   |
|                                                                  | 头信息压缩                                                   |
|                                                                  | 服务器主动推送                                               |
|                                                                  | 多路复用                                                     |
|                                                                  |                                                              |

### `HTTP 0.9`

- `短链接`：服务端响应之后，立即关闭 TCP 连接

- `只支持 GET 请求方式`：因此客户端是没办法向服务端传输太多的信息

- `没有请求头概念`：所以不能在请求中指定版本号，服务端也只具有返回 HTML 字符串的能力

### `HTTP 1.0`

- `短链接`

- 新增 `POST，DELETE，PUT，HEADER` 等请求方式

- 新增了 `请求头和响应头的概念`

- 在通信中指定了 `HTTP 协议版本号`，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)

- 任何格式的内容都可以发送。不仅可以传输文字，还能传输图像、视频、二进制文件

### `HTTP 1.1`

- **`长连接`**

  - 新增 `Connection` 字段，可以设置 `keep-alive` 值保持连接不断开

  - 持久连接（persistent connection），即 TCP 连接`默认`不关闭，可以被多个请求复用，不用声明 `Connection: keep-alive`

- **`管道机制`**

  【基于上面长连接的基础】，举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。**管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。**

- 新增 `PUT、PATCH、OPTIONS、DELETE` 方法

- `缓存处理`

  新增 `cache-control` 字段来控制缓存的行为

- `断点传输`

  新增 `range` 头域，允许只请求资源的某个部分

- `分块传输编码`

  使用`Content-Length`字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。

  对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，`采用 "流模式"（stream）取代 "缓存模式"（buffer）`。

  因此，**1.1 版规定可以不使用`Content-Length`字段，而使用 "分块传输编码"（chunked transfer encoding）**。只要请求或回应的头信息有`Transfer-Encoding`字段，就表明回应将由数量未定的数据块组成。

  ```sh
  Transfer-Encoding: chunked
  ```

- `HOST 头域`

  支持将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础

  - HTTP1.0 中认为每台服务器都绑定一个唯一的 iP 地址，因此消息中 URL 没有传递主机名

  - HTTP1.1 的请求消息和响应消息中都应支持 HOST 头域，没有头域的时候会报错 400

- 新增了 `24` 个错误状态码

### `HTTP 1.x` 版本存在的缺点

- `无状态`

  - 服务器无法跟踪记录请求过的状态

  - 对于无状态的问题可以借助 `cookie / session` 机制来做身份认证和状态记录

- `无连接`

  浏览器每次请求都需要建立 TCP 连接

- `HTTP 1.0` 传输的是明文，不安全

- `无法复用连接`

  每次发送请求，都需要进行一次 TCP 连接（即 3 次握手 4 次挥手），使得网络的利用率非常低

- ★ `队头阻塞`

  `HTTP 1.0` 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的

### `HTTP 2`

- `二进制分帧`

  将所有传输的消息分割为更小的信息和帧，并对它们采用二进制格式编码

- `多路复用`

  基于二进制分帧，在同一个域名下所有访问都是从同一个 TCP 连接走，HTTP 消息被分解为独立的帧，乱序发送，服务器根据标识符和首部将消息重新组装起来。

- `Header 头部压缩`

  - 每个请求带的一些首部字段都是相同的

  - `HTTP /1` 中使用文本的形式传输，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节

  - `HTTP /2` 中使用了 `HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小`。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

- `服务器推送`

  服务端可以在客户端某个请求后，主动推送其他资源

## `HTTP 1.1` 存在的问题

- [关于 HTTP/1.1 管道化的问答](https://www.cnblogs.com/gzchenjiajun-php/articles/4992795.html)

- [什么是队头阻塞以及如何解决](https://blog.csdn.net/weixin_34364071/article/details/91416530)

### 为什么 `HTTP 1.1` 不能实现多路复用

- 因为 `Http1.1 不是二进制传输`，而是通过文本传输，所以没有流的概念，在并行传输数据时，`接收端无法区分多个相应分别属于哪个请求`，所以无法将多个相应的结果重新进行组装，也就是用不了多路复用

### 管道化问题

- ==会造成队头阻塞==，前一个响应未及时返回，后面的响应被阻塞

- 请求必须是`幂等`请求，不能修改资源；因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。所以，目前大部分浏览器和 Web 服务器，都关闭了管道化，采用非管道化模式

- `只有幂等的请求才可以被管道化` 比如 GET 和 HEAD；POST 和 PUT 不应该被管道化。同样也不应该在建立新连接的时候发出管道化的请求 ，因为不能确保源服务或代理是否支持 `HTTP/1.1`。因此，管道化 `只能利用已存在的 keep-alive 连接`

**解决方法**

- `并发 TCP 连接`

  浏览器一个域名采用 6-8 个 TCP 连接，并发 HTTP 请求

- `域名分片`

  多个域名，可以建立更多的 TCP 连接，从而提高 HTTP 请求的并发

- `HTTP2`

  使用一个域名单一 TCP 连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了 HTTP 层面的请求队头阻塞。但是不能避免 TCP 层面的队头阻塞

### 队头堵塞问题

> 队头阻塞产生的主要问题的是操作的非`幂等性`，顺序不同，结果不同

- 虽然 `HTTP 1.1` 版本开始允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为 "队头堵塞"

- （队头阻塞在一些网站上还是挺明显的，有时候因为某个请求没完成，整个页面都无法展示）

**HTTP 的队头阻塞分为管道化和非管道化**

- `管道化` 就是每次请求必须等到上次的请求的响应后再接受

- `非管道化` 就是每次可以接受多个请求，但是响应的时候必须要等前面的请求响应后再响应

## `HTTP` 报文结构

[HTTP 请求行、请求头、请求体详解](https://blog.csdn.net/u010256388/article/details/68491509)

[HTTP 请求、响应报文结构](https://blog.csdn.net/shouwang666666/article/details/70232053)

[HTTP 中的请求头和响应头属性解析](https://blog.csdn.net/J080624/article/details/56006705)

### 请求头报文

![请求报文头](http://dl.iteye.com/upload/attachment/0069/3451/412b4451-2738-3ebc-b1f6-a0cc13b9697b.jpg)

- 请求头是不缺分大小写的

- 第一行叫请求行，描述一个 HTTP 请求的基本信息，可以用来区分是请求还是响应

- 首部行都是由 首部字段名 和 值 组成，每个首部行在结束地方都有 `CR + LF`（回车 + 换行）

- 中间部分叫请求头，描述了这个报文的基本信息

- 请求头后面接一个**空行** `CR + LF` 用来区分

- 最后部分叫报文体，具体的报文数据

### 常见的请求头

| 字段              | 含义                                                                                                               |
| :---------------- | :----------------------------------------------------------------------------------------------------------------- |
| `Accept`          | 浏览器可接受的 MIME 类型                                                                                           |
| `Accept-Charset`  | 浏览器可接受的字符集                                                                                               |
| `Accept-Encoding` | 浏览器能进行解码的数据编码格式，比如 gzip                                                                          |
| `Accept-Language` | 浏览器所希望的语言种类                                                                                             |
| `Authorization`   | 当客户端访问受口令保护时，服务器端会发送 401 状态码和 WWW-Authenticate 响应头，要求客户机使用 Authorization 来应答 |
| `Content-Length`  | 请求消息正文的长度                                                                                                 |
| `Referer`         | 客户机通过这个头告诉服务器，它是从哪个页面链接过来的，浏览器因此可以获取一些信息用于处理(防盗链)                   |
| `User-Agent`      | `User-Agent`头域的内容包含发出请求的用户信息                                                                       |
| `Cookie`          | 客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一                                                     |
| `Pragma`          | 指定 `no-cache` 值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝                 |
| `From`            | 请求发送者的 email 地址，由一些特殊的 Web 客户程序使用，浏览器不会用到它                                           |
| `Connection`      | 处理完这次请求后是否断开连接还是继续保持连接                                                                       |

### 响应报文

![响应报文头](http://dl.iteye.com/upload/attachment/0069/3492/bddb00b6-a3e1-3112-a4f4-4b3cb8687c70.jpg)

| 字段               | 含义                                                                                |
| ------------------ | ----------------------------------------------------------------------------------- |
| `Content-Type`     | 服务器通过这个头告诉浏览器回送数据的类型                                            |
| `Content-Length`   | 服务器通过这个头告诉浏览器回送数据的长度                                            |
| `Content-Encoding` | 内容编码方式                                                                        |
| `Date`             | 服务器当前 `GMT` 时间，返回响应式可以设置这个头部告诉浏览器以避免转换时间格式的麻烦 |
| `Set-Cookie`       | 服务端可以设置客户端的 `Cookie`，原理就是通过这个响应报文头属性实现的               |
| `Server`           | 告诉浏览器服务器的类型，比如 `Apache`                                               |
| `WWW-Authenticate` |

## ★ `HTTP` 状态码

[HTTP 常见状态码（14 种）](https://blog.csdn.net/banana960531/article/details/85621865)

| 状态码 | 说明                                   |
| :----- | :------------------------------------- |
| `1xx`  | 表示通知信息，比如请求收到了正在被处理 |
| `2xx`  | 表示成功                               |
| `3xx`  | 表示重定向                             |
| `4xx`  | 表示客户端的差错，比如链接不存在       |
| `5xx`  | 表示服务端的差错                       |

### 状态码 `301` 和 `302` 的区别

**`301` 永久重定向：**

请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。`今后任何新的请求都应使用新的 URI 代替`

**`302` 临时重定向：**

与 301 类似，但资源只是临时被移动，`客户端应继续使用原有 URI`

### 转发和重定向的区别

**转发**

转发是服务端执行完成的，Web 组件将未完成的处理通过容器转交给另一个组件继续完成，比如反向代理也是一种转发嘛

**重定向**

重定向是服务器向浏览器发送一个重定向错误码和 `Location` 消息头（该属性表示该网页的跳转网址，也被称为重定向网址），浏览器收到后，还需要向重定向地址发出请求

## ★ `GET`请求和`POST`请求

> `GET` 后面的参数长度有限制，且参数可以直接看到

**什么是 `GET` 请求**

- 当客户端要从服务端读取数据时用 GET，使用 GET 方法时，请求参数和对应的值 附加在 URL 后面

- 利用问号`?`代表 URL 的结尾和请求参数的开始，传递参数长度受限制，例：`/index.jsp?id=100&op=bind`

**什么是 `POST` 请求**

向服务器提交数据，POST 方法请求参数封装在 HTTP 请求数据中，可以传输大量数据，可用来传送文件

### Get 和 Post 请求的区别

Get 是向服务器索取数据的一种请求，而 Post 是向服务器提交数据的一种请求

- `参数传递方式`

  Get 请求的参数会跟在 url 后进行传递, POST 请求的数据会放置在请求头内提交

- `大小限制`

  Get 对传输的数据有大小限制, POST 没有

- `安全性`

  Post 比 Get 安全

### 既然 POST 有这么多优点，为什么还要用 GET 呢

一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET，POST，PUT，DELETE 就对应着对这个资源的查 ，改 ，增 ，删 4 个操作。

**GET 比 POST 更快**

POST 请求的过程，会先将请求头发送给服务器进行确认，然后才真正发送数据；

而 GET 请求的过程，会在连接建立后会将请求头和请求数据一起发送。

## 整个 URL 的过程,浏览器输入地址后发生了什么

![alt](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUn2BsPqwzxiaY6YX7BD4he0naG3y6AzUgVbfd6KOqTfpLfQtjmf9YXpv2QoibeicOn1R63StMMvB1SYw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 客户端`应用层`浏览器通过 DNS 解析到 www.baidu.com 的 IP 地址 220.181.27.48，通过这个 IP 地址找到客户端到服务器的路径；客户端浏览器发起一个 HTTP 会话到 220.161.27.48，然后通过 TCP 进行封装数据包，输入到网络层。

- 在客户端的`传输层`，把 HTTP 会话请求分成报文段，添加源和目的端口，如服务器使用 80 端口监听客户端的请求，客户端由系统随机选择一个端口如 5000，与服务器进行交换，服务器把相应的请求返回给客户端的 5000 端口。然后使用 IP 层的 IP 地址查找目的端。

- 客户端的`网络层`不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，无非就是通过查找路由表决定通过那个路径到达服务器。

- 客户端的`链路层`，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。

- **`URL` 解析**

  浏览器解析出主机名

- **`DNS` 解析**

  浏览器查询这个主机名的 ip 地址，并获取端口号

- **`TCP` 连接**

  浏览器发起到服务器的链接（TCP 连接握手）

- **处理请求**

  浏览器向服务器发送一条 `HTTP get` 或 `HTTP post` 报文，中间有可能先发给 proxy/gateway，再由他们转发给 `web` 服务器，`web` 服务器再做反向代理到达真正的服务器

- **接收响应**

  服务器处理之后，生成响应报文，原路返回给浏览器

- **渲染页面**

  浏览器进行渲染展示，最后关闭链接（短链接）

## 一个 TCP 连接可以发多少个 HTTP 请求

[一个 TCP 连接可以发多少个 HTTP 请求](https://www.jianshu.com/p/aaba68b87416)

**一个 `TCP` 连接可以对应几个 `HTTP` 请求**

- 如果请求头表明要维持 `TCP` 连接，那么一个 `TCP` 链接就可以发送多个 `HTTP` 请求

- `HTTP1.1` 开始支持 `管道机制`，管道化`可以不等第一个请求响应回来就可以继续【发送】后面的请求`

**浏览器与服务器建立 `TCP` 连接后是否在一个 `HTTP` 请求完成后就断开，什么情况下不会断开**

> `HTTP/1.0` 版本中，浏览器完成一个 `HTTP` 请求后就断开连接了，但是导致频繁建立和断开带来的消耗太大

- 可以在请求头设置 `Connection: keep-alive` 来保持连接

- `HTTP/1.1` 默认已经 `Connection: keep-alive` 这个写到请求头了，除非显式带上 `Connection: close`，否则 `TCP` 链接哦都会维持一段时间

### HTTP 的 `keepalive` 和 TCP 的 `keepalive` 的联系

> - HTTP 的 `Keep-Alive` 意图在于 `【TCP 连接复用】`，在同一个连接上以串行方式传递请求，响应数据
> - TCP 的 `Keepalive` 机制意图在于`【探测连接】的对端是否存活`
> - 永远记住 TCP 不是轮询的协议。为了防止长时间的死连接

从 `HTTP/1.1` 起，默认使用长连接，使用长连接的 HTTP 协议，会在响应头加上 Connection、Keep-Alive 字段

![alt](https://img-blog.csdn.net/20180427175710777?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nocmlzbm90Zm91bmQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- HTTP 的 keepalive 是保证 TCP 连接不过早关闭，而 TCP 的 keepalive 是用来做链路检测

- 比如 HTTP 设置的 keep-alive 为 120s，然后当一次 HTTP 响应结束后，不是立即关闭这个 TCP 连接，而是等 120s

### 为什么大部分应用程序都没有开启 TCP 的 keepalive 选项

因为超时时间太长了，见 [[01. 计算机网络基础 - tcp]]

### HTTP 能不能一次连接多次请求，不等待后端返回

本质上是使用 `socket` 连接，因此发送请求，会写入 TCP 缓冲，是可以多次进行的，这也是 HTTP 是无状态的原因

### 一个 `TCP` 连接中 `HTTP` 请求可以一起发送吗

> 比如一次发三个，再一次收三个响应

- `HTTP2` 提供 `Multiplexing` 特性，可以在一个 `TCP` 连接中同时完成多个 `HTTP` 请求；（`HTTP2`是建立在 `HTTPS` 上的）

- `HTTP1.1` 是文本协议，同时返回的内容并不能区分对应那个请求，所以只能串行处理；比如同时请求 `Get /query?q=A` 和 `Get /query?q=B`，服务器返回两个结果，但是浏览器并不知道怎么区分它们

### 为什么有的刷新页面不需要重新建立 `SSL` 链接

- 在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的

- 对于 `HTTPS`，也省略了多次进行 `SSL` 握手的过程，只要保持长连接，只需要握手一次就行了

### 浏览器同一 `HOST` 建立 `TCP` 连接的数量有限制吗

`Chrome` 最多允许对同一个主机建立`六个 TCP 连接`

# `HTTPS`

## ★ `HTTP` 和 `HTTPS` 的区别

![alt](https://img-blog.csdn.net/20160908111457440)

- HTTPS 协议需要向 CA `申请证书`

- HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 `SSL 加密传输协议`

- HTTP 和 HTTPS 使用的`端口不同`

- HTTP 的握手过程和 TCP 三次握手一样，HTTPS 握手过程和 SSL 握手过程一样

- HTTP 的连接很简单,`无状态的`

- HTTPS 协议是由 `SSL + HTTP` 协议构建的可进行加密传输、身份认证的网络协议， 要`比 HTTP 协议安全`

## ★ `SSL` 握手过程

> 整个过程就是怎么安全得把对称密钥告知对方

- [★ wireshark 抓 SSL 握手过程](https://www.cnblogs.com/small-office/p/9770896.html)

- [★ SSL 握手报文详解](https://blog.csdn.net/firefile/article/details/80537053#241_Application_Data_972)

- [HTTPS 协议详解 (四)：TLS/SSL 握手](https://blog.csdn.net/hherima/article/details/52469674)

SSL 协议在传输层与应用层之间，对网络连接加密

![alt](https://mmbiz.qpic.cn/mmbiz_png/I7vS3FZsGcBobNVd6XUopKam1icz7KCn1Ergzk4ia7UATAtic7m12jia2Su94DI2icobIfsLMdvfXP22LUOaMvcaUbQ/640?wx_fmt=png)

### 握手过程解释

- `client ----> server`

  客户端把自己支持的版本、加密套件、随机数 `random_c` 告诉服务服务端

- `server ----> client`

  服务端返回选择的加密套件，以及自己的`证书`，随机数 `random_s`

- `client 验证证书的有效性`

- `client ----> server`

  - 产生随机数 **`pre-master`**，并用服务端给的 `公钥进行加密`

  - 用前两步协商的算法计算三个随机数的消息摘要作为加解密的【密钥】

    ```py
    enc_key = func(random_c, random_s, pre-master)
    ```

  - 用【协商的算法和这个密钥】对信息加密后发给服务端

- `server ----> client`

  - 服务端用私钥解开得到 `pre-master`

  - 加上前面交换的 `random_c` 和 `random_s`，服务端也用同样的算法计算得到【密钥】

  - 同样，用前面【协商的算法结合密钥】对信息进行解密

- 至此通所需要的密钥、算法都已经协商好了，后续的报文就用这个来进行加密传输

### 抓包分析

![alt](https://img2018.cnblogs.com/blog/1365566/201810/1365566-20181011135651499-1361470161.png)

**`Client Hello`**

客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息

- 支持的最高 TSL `协议版本` version，从低到高依次 SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2

- 客户端支持的`加密套件` cipher suites 列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：认证算法 Au (身份验证)、密钥交换算法 KeyExchange(密钥协商)、对称加密算法 Enc (信息加密) 和信息摘要 Mac(完整性校验)

- 支持的`压缩算法` 列表，用于后续的信息压缩传输

- `随机数 random_C`，用于后续的密钥的生成

- 扩展字段 extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的 SNI 就属于扩展字段，后续单独讨论该字段作用

**`Server Hello、Certificate、Server Key Exchange、Server Hello Done`**

服务器从客户端发来的加密算法中选择一个 `协议版本`、`加密算法` 和 `哈希算法` 以及自己的 `证书（私钥）`、`随机数 Random_s` 返回

- `Server Hello`

  服务端返回协商的信息结果，包括选择使用的`协议版本 version`，选择的`加密套件 cipher suite`，选择的`压缩算法 compression method`、`随机数 random_S` 等，其中随机数用于后续的密钥协商

- `Server Certificates`

  服务器端配置对应的证书链，用于身份验证与密钥交换

- `Server Hello Done`

  通知客户端 server_hello 信息发送结束

**`Client Key Exchange、Change Cipher Spec、Encrypted Handshake Message`**

客户端`校验证书`是否合法，并从中`取出公钥`

- `Client Key Exchange`

  - 客户端计算产生 `随机数字 Pre-master`，并用证书公钥加密，发送给服务器

  - 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，计算得到`协商密钥 enc_key = Func(random_C, random_S, Pre-Master)`

- `Change Cipher Spec`

  客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信

- `Encrypted Handshake Message`

  结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用 `协商密钥` 与算法进行加密，然后发送给服务器用于数据与握手验证;

**`Change Cipher Spec、Encrypted Handshake Message`**

服务器用私钥解密加密的 `Pre-master` 数据，基于之前交换的两个明文随机数 `random_C` 和 `random_S`，计算得到`协商密钥 enc_key = Func(random_C, random_S, Pre-Master);`；计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;

- `Change Cipher Spec`

  验证通过之后，服务器同样发送 change_cipher_spec 以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;

- `Encrypted Handshake Message`

  服务器也结合所有当前的通信参数信息生成一段数据并采用`协商密钥` 与算法加密并发送到客户端;

**握手结束**

客户端计算所有接收信息的 hash 值，并采用`协商密钥`解密 encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成;

**加密通信**

开始使用`协商密钥`与算法进行加密通信

# 其他

[Chrome 浏览器 Network 面板 http 请求时间分析](https://www.cnblogs.com/zhenwen/p/5827925.html)

## 收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的

- 浏览器在 `SSL` 握手之后和服务器协商 HTTP 的版本

- 如果 `支持 HTTP2` 就用 `Multiplexing` 在这一个连接上同时进行多路传输

- 如果 `不支持 HTTP2` 就会在 `HOST` 上建立多个 `TCP` 连接
