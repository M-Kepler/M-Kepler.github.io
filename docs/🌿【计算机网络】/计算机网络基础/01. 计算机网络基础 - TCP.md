- [`TCP` 数据段](#tcp-数据段)
  - [端口](#端口)
  - [`TCP` 特性](#tcp-特性)
  - [`TCP` 报文结构](#tcp-报文结构)
  - [★ RST 连接重置的作用和一些场景](#-rst-连接重置的作用和一些场景)
    - [`RST` 和 `FIN` 的区别](#rst-和-fin-的区别)
    - [`RST` 中间人攻击](#rst-中间人攻击)
  - [★ `TCP` 状态迁移](#-tcp-状态迁移)
    - [三次握手状态与网络编程函数说明](#三次握手状态与网络编程函数说明)
    - [四次挥手状态说明](#四次挥手状态说明)
    - [半打开和半关闭](#半打开和半关闭)
  - [★ 三次握手](#-三次握手)
    - [如果已经建立了连接，但是客户端突然出现故障了怎么办](#如果已经建立了连接但是客户端突然出现故障了怎么办)
    - [为什么大部分应用程序都没有开启 TCP 的 `keepalive` 选项](#为什么大部分应用程序都没有开启-tcp-的-keepalive-选项)
    - [第三次握手过程网络发生错误会进行怎么处理](#第三次握手过程网络发生错误会进行怎么处理)
    - [握手为什么要三次，两次行不行](#握手为什么要三次两次行不行)
    - [三次握手（建立连接过程中）交流了什么内容](#三次握手建立连接过程中交流了什么内容)
    - [全连接队列和半连接队列](#全连接队列和半连接队列)
    - [全连接队列满了会影响半连接队列吗](#全连接队列满了会影响半连接队列吗)
    - [`SYN` 泛洪是什么](#syn-泛洪是什么)
    - [`SYN` 防洪防范措施](#syn-防洪防范措施)
  - [★ 四次挥手](#-四次挥手)
    - [为什么握手三次, 而挥手要四次](#为什么握手三次-而挥手要四次)
    - [四次挥手怎么优化](#四次挥手怎么优化)
    - [如果两端同时关闭会发生什么](#如果两端同时关闭会发生什么)
    - [`TIME_WAIT` 状态](#time_wait-状态)
      - [`TIME_WAIT` 为什么要等待 `2MSL`](#time_wait-为什么要等待-2msl)
      - [`TIME_WAIT` 会带来哪些问题](#time_wait-会带来哪些问题)
      - [如何避免 `TIME_WAIT`](#如何避免-time_wait)
      - [`连接池`可以复用连接，是不是意味着，需要等到上个连接 `TIME_WAIT` 结束后才能再次使用](#连接池可以复用连接是不是意味着需要等到上个连接-time_wait-结束后才能再次使用)
    - [`CLOSE_WAIT` 产生太多原因，怎么处理](#close_wait-产生太多原因怎么处理)
  - [同步序列号有什么作用](#同步序列号有什么作用)
  - [★ 可靠性](#-可靠性)
    - [怎么保证传输过程的可靠性](#怎么保证传输过程的可靠性)
    - [延时确认机制](#延时确认机制)
    - [累积确认机制](#累积确认机制)
    - [超时重传机制](#超时重传机制)
    - [校验和机制](#校验和机制)
  - [★ （自身）流量控制](#-自身流量控制)
    - [滑动窗口协议](#滑动窗口协议)
      - [为什么引入滑动窗口](#为什么引入滑动窗口)
      - [滑动窗口工作流程](#滑动窗口工作流程)
      - [滑动窗口机制](#滑动窗口机制)
      - [窗口大小](#窗口大小)
      - [滑动窗口为 0 时，发送端会做什么](#滑动窗口为-0-时发送端会做什么)
      - [大文件传输为什么越来越快](#大文件传输为什么越来越快)
      - [滑动窗口工作流程](#滑动窗口工作流程-1)
      - [糊涂窗口综合征](#糊涂窗口综合征)
  - [★ （网络）拥塞控制](#-网络拥塞控制)
    - [为什么要有拥塞控制呀，不是有流量控制了吗](#为什么要有拥塞控制呀不是有流量控制了吗)
    - [怎么知道当前网络是否出现了拥塞](#怎么知道当前网络是否出现了拥塞)
    - [什么是拥塞窗口，和发送窗口有什么关系](#什么是拥塞窗口和发送窗口有什么关系)
    - [★ 拥塞控制方法有哪些](#-拥塞控制方法有哪些)
      - [讲一下拥塞控制的过程](#讲一下拥塞控制的过程)
      - [慢启动算法](#慢启动算法)
      - [拥塞避免算法](#拥塞避免算法)
      - [拥塞发生算法](#拥塞发生算法)
      - [快重传算法（搭配快恢复使用）](#快重传算法搭配快恢复使用)
      - [快恢复算法](#快恢复算法)
  - [四个定时器](#四个定时器)
  - [TCP 保活机制](#tcp-保活机制)
    - [TCP 如何保持长连接 `keepalive`](#tcp-如何保持长连接-keepalive)
    - [★ 什么是长连接、短链接](#-什么是长连接短链接)
    - [长连接会一直保持吗](#长连接会一直保持吗)
  - [★ 粘包问题](#-粘包问题)
    - [为什么会有粘包问题](#为什么会有粘包问题)
    - [粘包问题怎么解决](#粘包问题怎么解决)
  - [TCP `服务器`最大并发连接数是多少](#tcp-服务器最大并发连接数是多少)
- [其他](#其他)
- [参考资料](#参考资料)

# `TCP` 数据段

## 端口

`常用端口`

| 协议     | 端口  |
| :------- | :---- |
|          |       |
| `FTP`    | `21`  |
| `TELNET` | `23`  |
| `SMTP`   | `25`  |
| `POP3`   | `110` |
| `HTTP`   | `80`  |
| `DNS`    | `53`  |
| `SSL`    | `443` |
| `HTTPS`  | `443` |

- 众所周知的端口 `0 - 1023`

- 注册端口 `1024 - 49151`

- 动态或私有端口 `49152 - 65535`

## `TCP` 特性

- `基于字节流`的传输服务

  - 传输的数据成为`segment`，即没有边界、格式的处理

  - 根本不知道什么时候发送/接收完成，一个数据报可能要发送/接收多次才得到完整的数据；所以就有可能一次接收到多个`TCP 段`，即出现`粘包` 问题

  - `tcp` 是基于字节流，所以它不知道到底哪里是一个数据报的边界，这个问题只能在`socket` 编码过程中做处理

- `面向连接`

- `提供可靠传输`

  提供端到端的校验和来保证数据不会出错，校验机制和网络层一样的

- `缓冲传输`

  - `TCP` 不会来一个`segment` 就传输一次，而是把段缓冲起来，等待一个最佳的实际来发送（所以进行`socket`层编程的时候，我们执行了`send` 操作，但是实际上数据报文还没发出去，应用层编码只要放到缓冲区就行了，至于怎么发的就是传输层的逻辑了）

- `全双工`

  - 即发送的时候也可以进行数据接收

## `TCP` 报文结构

> [计算机网络 之 TCP 协议报文结构](https://www.cnblogs.com/scutwang/p/3948607.html)

![alt](https://images0.cnblogs.com/blog/517982/201409/032325597971641.jpg)

- `TCP` 头部一共 `20` 字节（UDP `8` 字节)

- `16位` 的源、目的端口号

  - 所以端口号最大为 `2^16 = 65535`

  - `IP` 数据报中的源、目的地址是`32` 位，协议编号为`8` 位，所以五元组占用空间为`32 * 2 + 16 * 2 + 8 = 104 / 8 = 13` 个字节

- `32位 序号`

  即在这个报文段中的 `第一个数据字节`序号

- `32位 确认号`

  当 `ACK` 标记为为 `1` 的时候有效，表示下一个 `希望收到的下一个字节`序号

- `标志位`

  - `URG` 紧急指针

  - `ACK` 确认序列号有效

  - `PSH` 接收方应尽快将这个报文交给应用层，不会对这样的报文段使用缓存策略

  - `RST` 连接重置

  - `SYN` 同步序号，用来发起一个连接

  - `FIN` 表示将要终止一个连接

- `16位 窗口大小`

  - 此字段用来控制对方发送的数据量

  - 一般 TCP 连接的其中一端会根据自身的缓存空间大小来确定自己的接收窗口大小，然后告知另一端以确定另一端的发送窗口大小。该字段与 TCP 的流量控制服务有关

- `16位 校验和`

  对 `TCP` 头与数据进行校验

- `16位 紧急指针`

  - 告诉系统此报文段中有紧急数据，应尽快传送。

  - 就比如 `telnet` 与服务端正处于传输过程中，此时按下一个`Ctrl + C`，要立马终止与服务器端传输

  - 这种需要紧急发送过去的数据叫做 **`带外数据`**

- `选项与填充`

  - 长度是`4` 的整数倍，不足用`0` 来填充，估计是为了内存对齐

  - 常见选项：最长报文长度`MSS maximum segment size`，依此来**分组**

    - 用来说明本段能接收的最大长度的报文，如果不设置，则默认为`536`

    - `MTU 与 MSS`

      - 路由器`MTU` 一般是`576`，再扣除掉`IP/TCP` 层的头部，即：`576 - 20 - 20 = 536` 个字节

      - 所以要传输的数据不超过 536 字节就一般不会发生数据报分片，所以**应用层的缓冲区不要设置大于 536 字节**

## ★ RST 连接重置的作用和一些场景

[几种 TCP 连接中出现 RST 的场景分析](https://my.oschina.net/costaxu/blog/127394)

- **端口未打开**

  服务器程序端口未打开而客户端来连接

- **请求超时**

  主机上的程序认为接收超时，所以发送了 RST 拒绝进一步发送数据

- **在一个已关闭的 socket 上收到数据**

  客户端在服务端已经关闭掉 socket 之后，仍然在发送数据。这时服务端会产生 RST

### `RST` 和 `FIN` 的区别

[`RST` 和 `FIN` 标志位的区别](https://blog.csdn.net/yangguosb/article/details/79224872)

- 发送 `RST` 包关闭连接时，`【不必等缓冲区的包都发出去】`（不像上面的 FIN 包），直接就丢弃缓存区的包发送 RST 包

- 接收端收到 RST 包后，也`不必发送 ACK 包来确认`

### `RST` 中间人攻击

[TCP 中的 RST 标志 (Reset) 详解](https://blog.csdn.net/weixin_43763259/article/details/107390926)

A 和 B 之间建立了 TCP 连接，此时 C 伪造了一个 TCP 包发给 B，使 B 异常的断开了与 A 之间的 TCP 连接，就是 RST 攻击

- 假定 C 伪装成 A 发过去的包，这个包如果是 `RST` 包的话，毫无疑问，B 将会丢弃与 A 的缓冲区上所有数据，强制关掉连接。

- 如果发过去的包是 `SYN` 包，那么 B 会表示 A 已经发疯了（与 OS 的实现有关），正常连接时又来建新连接，B 主动向 A 发个 RST 包，并在自己这端强制关掉连接。

## ★ `TCP` 状态迁移

> - [TCP 状态详解](https://www.yunweigonghui.com/column/Transport/99/)
> - [TCP 的 11 种状态](https://blog.csdn.net/wk_bjut_edu_cn/article/details/82343939)

![alt](https://img-blog.csdn.net/20160423144456154)

![alt](https://img-blog.csdn.net/20180903095342465?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3drX2JqdXRfZWR1X2Nu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

当两端同时关闭时，会进入 `CLOSING` 状态

### 三次握手状态与网络编程函数说明

握手和挥手过程都是`在内核完成`的，`connect 和 accept` 系统调用只是通知内核发起连接

- 服务端调用 `socket` 创建套接字时默认是 `CLOSED` 状态；调用 `listen` 后把套接口设置为 `被动模式（默认为主动模式）`，只能用来接受连接，等待对端连接，随后进入 `LISTEN` 状态

- 客户端调用 `socket` 创建套接字时默认是 `CLOSED` 状态；调用 `connect` 主动发起连接（三次握手是内核完成的，通知内核开始进行握手），【程序阻塞】；内核 `发送 syn 报文`（进行第一次握手），进入 **`SYN_SENT`** 状态，此时连接被存放到对端的 `半连接队列`（所以 socket 编程要先启动服务端再启动客户端，要不然直接发 syn 报文得不到回应）

- 服务端调用 `accept` 函数的时候会从`全连接队列`中取出一个连接，如果还没已经完成的连接，则【程序阻塞】

- 服务端 `内核` 向对端 `发送 syn + ack 报文`（进行第二次握手）后；进入 **`SYN_RECVD`** 状态

- 客户端接收到报文后，进入 **`ESTABLISHED`** 状态，完成第二次握手；【`connect` 函数返回，阻塞结束】；然后向对端 `发送 ack 报文` 进行第三次握手

- 服务端接收到 `ack` 报文后，完成第三次握手，此时 【`accept` 函数返回，阻塞结束】

### 四次挥手状态说明

- 主动关闭方调用 `close` 函数，进入到 **`FIN_WAITE_1`** 状态

- 被动关闭方接收到关闭请求后（接收到 `FIN` 后，内核立马回应一个 `ACK` 了，见[为什么挥手要四次]），调用 `read` 函数返回值为`0`，就知道对端要关闭了，回复一个`ack` 报文，然后进入到 **`CLOSE_WAIT`** 状态

- 主动关闭端收到被动关闭端发过来的确认报文后，进入 **`FIN_WAIT2`** 状态

- 被动关闭端调用 `close` 函数后，也会发一个 `FIN` 报文给对端，表示本端要发送的数据也发送完了，然后进入到 **`LAST_ACK`** 状态

- 主动关闭方收到 `FIN` 报文后，向对端发一个 `ack` 报文，表明自己已经收到消息了，然后进入到 **`TIME_WAIT`** 状态（好的，我告诉一下你我知道你说完了，我再等等，确保你能收到我确认收到你消息的这句话） 见 `[为什么要有 TIME_WAIT 状态]`

- 被动关闭方收到 `ack` 报文后就进入到 **`CLOSED`** 状态

- 主动关闭方等了 `时间等待定时器 2MSL` 后也转为 **`CLOSED`** 状态

### 半打开和半关闭

**半打开：**

如果一方已经 `关闭或异常终止连接`，而另一方却不知道。 我们将这样的 TCP 连接称为半打开（Half-Open）

**半关闭：**

TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是 TCP 的半关闭。`shutdown` 可以选择关闭读或写任一个方向

## ★ 三次握手

目的是为了保证双方都能正常收发数据

[两张动图 - 彻底明白 TCP 的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)

![alt](https://img-blog.csdnimg.cn/114bd9b53c554319ae0db15b57b472b8.gif)

**握手过程通俗解释：**

```sh
  A: 你能听到我说话吗?
  (设置同步序列号（数值无所谓的其实），设置同步SYN位为1，表示这个报文是用来建立连接的)

A ---------------------------> B (A发完SYN进入SYN_SENT状态)
            SYN=1, seq=J
                                B 收到 A 消息了，要告诉他，让他知道


  B: 听到了，你能听到我吗?
  (设置确认号 J+1，告诉他已经收到了，设置SYN标志位，并设置序号K，期望得到确认号 K+1)

A <--------------------------- B (B发完ACK和SYN两个包后, 进入SYN_RECV状态) // 【半连接】
            SYN=1, ack=J+1, seq=K


  A: 我听到了
  （设置ACK标志位，发送确认号 K+1，表示收到了 B 的序号）

A ---------------------------> B (A发完ACK, A,B都进入 ESTABLISHED 状态) // 【全连接】
              ACK=1, ack=K+1

A 收到 B 消息了，要告诉他，让他知道
```

### 如果已经建立了连接，但是客户端突然出现故障了怎么办

> 可以看到需要三次通信才能完成握手过程，握手成功后就认为双方都准备好接收数据了，开始数据通信，可是通信过程中，某一方出现故障了呢

- **`保活定时器`**

  显然，客户端如果出现故障，服务器不能一直等下去，`服务器每收到一次客户端的请求后都会复位这个计时器`，若发送探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。如果过了保活时间还没反应，就会关闭连接

- 这个定时器时间通常是设置为 `2 小时`，若两小时后还没有收到客户端的任何数据，服务器就会发送一个探测报文段，之后每隔 `75 秒钟` 发送一次。若一连发送 `10 个探测报文` 仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

- 所以从没有数据交互到最终判断连接失效，需要花 `2.1875` 小时`（2 * 3600 + 75 * 9）`，显然太长了

### 为什么大部分应用程序都没有开启 TCP 的 `keepalive` 选项

`默认的超时时间太长了`，两个多小时；而如果修改这个值到比较小，又违背了 `keepalive` 的设计初衷（为了检查长时间死连接），因此在应用上做连接的有效性检测常用心跳包机制

### 第三次握手过程网络发生错误会进行怎么处理

> [TCP 三次握手第三次握手时 ACK 丢失怎么办](https://www.cnblogs.com/wuyepeng/p/9801470.html)

- 服务端端没收到 ACK 报文，会触发 TCP `超时重传`

- 服务端经过几次重传（指数退避算法慢慢增大重传间隔）后还没回应，就会发送 `RST` 给客户端，进入 `CLOSED` 状态，关闭链接，防范 `SYN防洪` 攻击

- 两次握手完成后，客户端已经进入 `ESTABLISHED` 状态，向服务端发数据，服务端回应 `RST` 报文重置连接

### 握手为什么要三次，两次行不行

> `不行`
>
> - `原因一`：无法确定双方都能正常接收数据
> - `原因二`：[防止旧的重复连接初始化造成混乱](https://www.zhihu.com/question/271701044/answer/1279809269)：第一次握手的重试会被认为是新的连接

- **情形一：第一次握手重传**

  > 服务端会响应超时重而来的第一次握手报文 `SYN 报文`，会造成资源的浪费

  ![alt](https://pic4.zhimg.com/80/v2-ac0ecdad293a096d6b9402231af9f202_720w.jpg?source=1940ef5c)

  试想一下, C 第一次发送 SYN1 请求连接, 但是在网络某节点滞留了, 然后 C 超时重传 SYN2, 然后这一次一切正常, C 跟 S 可以正常进行数据传输;等到连接释放了以后, 那个 SYN1 请求突然到了 Service 那, 如果是两次握手的话, Service 认为是新链接来了，于是发送确认 ACK2 打算连接；事实上 C 并不会理会这个 ACK2 确认, 因为 C 认为自己压根没有要传数据啊. 但是 S 却傻傻地等待对方的回应

  ```
  C: 喂, 你听到了吗?
  C: 喂, 你听到了吗?(...那么久还没回应, 我再喊一次)
  S: 我听到了
  ......(交流)
  C: 喂, 你听到了吗?(丢包或超时重传了, 反正有延时，晚一点到达)
  S: 我听到了 (什么鬼?, 刚交流完, 又来?)
  C: 我没又要跟你聊天啊, 不管了
  S: 我都听到了, 怎么C还没说话?
  ```

- **情形二：第二次握手丢失**

  > 服务端发送完 `SYN + ACK` 认为连接已经建立了，就开始向 客户端 发送数据，但是客户端没收到这个报文，认为还没建立连接

  假定 C 连接 S, S 发了 syn + ack 包给 C；此时 S 认为连接已经成功地建立了, 可以开始发送数据分组；但是如果 syn + ack 包丢失了, C 不知道 S 是否准备好, `C一直在等待 S 的 ack 报文, 将忽略一切S发过来的任何数据报文`, 而 S 发报文没收到 C 的回应, S 就会不断超时重发

  ```
  C : 喂, 你听到了吗?
  S : 我听到了<由于网络原因, 这句话没有成功发给C>
  S ：(收了一大堆话)
  S : (不是连接好了吗，怎么没回应? 我重说一遍)
  C : ...(奇怪了, 怎么那么久还没回应, 也不知道他听到没有)
  ```

### 三次握手（建立连接过程中）交流了什么内容

> 不止是我们看三次握手图时，见到的 `SYN`、`ACK`，握手过程其他字段也都是携带了数据的。

- `MSS` 最大报文长度

- `rwnd / swnd` 窗口大小（见下面的【流量控制】部分）

### 全连接队列和半连接队列

> - 半连接保存 `完成前两次握手`的连接请求
> - 全连接保存 `完成三次握手`的连接请求

- 完成三次握手的链接被放到到全连接队列, 只完成了两次握手的队列放在半链接队列

- Linux 内核协议栈为一个 tcp 连接管理两个队列，一个是半连接队列（用来保存处于`SYN_SENT 和 SYN_RECV` 状态的请求），一个是全连接队列（accpetd 队列）（用来保存处于`ESTABLISHED` 状态，但是应用层尚未调用`accept` 取走的请求）

- 调用`accept` 函数的时候会从全连接队列中取出一个连接，然后返回新的套接字进行通讯

### 全连接队列满了会影响半连接队列吗

会的，如果全连接队列已满，且未超时的 socket 的数量大于 1，则丢弃当前请求

### `SYN` 泛洪是什么

在三次握手过程中，**`服务器第二次握手发送 SYN + ACK 后的连接称为半连接。此时服务器处于 SYN_RECV 状态`**，当收到 ACK 后，服务器转入 `ESTABLISHED` 状态。利用三次握手的半连接队列发起拒绝服务攻击，导致服务器响应缓慢，严重者导致网络堵塞甚至系统瘫痪

![alt](https://img-blog.csdnimg.cn/20200317161012237.gif#pic_center)

**`SYN` 攻击方法：**

Syn 攻击是一个 `典型的 DDOS 攻击`。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。

伪冒客户端在短时间内 `伪造大量不存在的IP地址`, 不断往服务器发 SYN 包（`即第一次握手`）, 服务器回复确认包（`即第二次握手`）并等待客户端的确认包；

但是由于这些 IP 是伪造的，不会回复 ACK 包（`即不会有第三次握手`），服务器会不断重发直到超时，`大量的SYN包会长时间占用半连接队列`，导致正常的 SYN 请求被丢弃。

每收到一个 SYN 包, 就需要为该请求分配一个 `TCB（Transmission Control Block）`, 通常一个 TCB 至少需要 280 个字节，在某些操作系统中 TCB 甚至需要 1300 个字节，并返回一个 SYN ACK 命令, 立即转为 SYN-RECEIVED 即半开连接状态

### `SYN` 防洪防范措施

> 1. `Syn Cache`
> 2. `Syn Cookie`
> 3. `Syn Proxy`
> 4. 增大半连接队列

- 还有一种方法，识别对端地址是否有效：如果是 `私有地址`，那肯定是有人故意伪造报文来搞破坏的

- 监测是否被攻击

  ```sh
  $netstat -n -p TCP | grep SYN_RECV
  ```

**`完成三次握手前不分配资源`**

- **`SynCache 技术` 缓存半连接，握手成功才分配 `TCB`**

  在收到 SYN 数据报文时不急于去分配 TCB，而是先回应一个 SYN + ACK 报文，并在一个专用 HASH 表（Cache）中保存这种半开连接信息，直到收到正确的回应 ACK 报文再分配 TCB；

  - 旧逻辑：收到 syn 就分配 TCB 保存到半连接队列中

  - 现逻辑：`收到 syn 先计算一个哈希值，把哈希值保存到半连接队列，等收到握手成功后才实际分配TCB`，并转入全连接队列

    缺陷：需要保存连接的序列号信息

- **`SynCookie 技术` 计算 + 校验 Cookie，就像认证机制**

  原理是，在服务器接收到 SYN 包并返回 SYN + ACK 包（即第二次握手时）时，不分配一个专门的数据区，而是`根据这个 SYN 包计算出一个 cookie 值，这个 cookie 作为将要返回的SYN ACK包的初始序列号`。当客户端返回一个 ACK 包时，`根据包头信息重新计算 cookie`，与返回的确认序列号(初始序列号 + 1)进行对比 s；如果相同，则是一个正常连接，然后，分配资源，建立连接。

- **`SynProxy代理`**

  作为 server 与 client 连接的代理，**`代替 server 与 client 建立三次握手的连接, 确保链接成功后 proxy 再与 service 连接`**

- **增大最大半连接队列**

- **网关超时设置**

  - 防火墙设置 SYN 转发超时参数, 该参数远小于服务器的 timeout 时间. 当客户端发送完 SYN 包，服务端发送确认包后（SYN ＋ ACK）

  - 防火墙如果在计数器到期时还未收到客户端的确认包(ACK)，则往服务器发送 `RST` 包，以使服务器从队列中删去该半连接

  - 网关超时参数设置不宜过小也不宜过大，超时参数设置过小会影响正常的通讯，设置太大，又会影响防范 SYN 攻击的效果

## ★ 四次挥手

> - 目的是确保双方都把消息发送完了
> - 双方都可以断开连接，没有服务端、客户端，只有主动方、被动方

![alt](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRRr0taZIyx3pxsoyuia1c5usyQE3j0u3HBnAnIQU0vMhUqbdrnlQoclx3JcoaVcef0xlxc437TmqA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![alt](https://img-blog.csdnimg.cn/0c17d72769aa4bd2b95bbaee1749b39d.gif)

```sh
主动关闭方               被动关闭方

调用close()

FIN_WAIT1 ---- FIN1 ---> CLOSE_WAIT
                          |
FIN_WAIT2 <--- ACK -------+
                          .
                          . 调用 close()
                          ↓
TIME_WAIT <--- FIN2 ---- LASK_ACK
    |
    +---------- ACK ------> CLOSEED
```

**握手过程理解：**

```log
[主动方]                                                    [被动方]
                    我给你的消息发送完了, 你收到了吗?
                    （设置FIN标志位，并且发送确认号
                    表示自己要发送的东西完成了）

FIN_WAIT1  C ----------------------------------------------------> S  CLOSE_WAIT
                        FIN1

                    好，我知道了（ACK报文是由内核来触发立即回复的）
                    对端说他要发送的东西发完了，我给个回信表示我知道了
                    虽然他的话说完了，可是我自己的还没发送完
                    应用程序还没调用 `close` 关闭连接，还不能完全关闭
FIN_WAIT2  C <----------------------------------------------------- S
                        ACK

                    我要说的已经说完了，
                    只要你确认一下你听到了我就可以挂电话了
              C <----------------------------------------------------- S LAST_ACK
                        FIN2

                        收到了；这里 S 就不会再发一个 `ack` 了，
                        否则双方一直在相互确认，就陷入死循环了
TIME_WAIT  C -----------------------------------------------------> S CLOSED
                            ACK

等待 2MSL 后进入 CLOSED 状态
```

### 为什么握手三次, 而挥手要四次

挥手也可以三次完成，之所以分成四次是因为`被动关闭方可能有数据没发送完`

- **建立连接时**

  Server 把响应客户端的请求和请求客户端的确认放在一起发送给客户端了，即第二次握手时有`SYN + ACK`，ACK 用来应答，SYN 用来同步（因为报文中可以同时设置确认号和序号，两者不冲突）

- **断开连接时**

  一个方向的断开，`只说明该方向数据已传输完毕` 而另一个方向或许还有数据要发给对方,所以得等到另一个方向数据也全部传输完成后,才能执行第三次挥手

- 内核收到 FIN 后，由**内核**立即回复 ACK 对报文进行确认；而 FIN 报文则是应用层调用`close` 函数的时候才发的

### 四次挥手怎么优化

### 如果两端同时关闭会发生什么

同时关闭时，两端可能出现完全一样的状态转移 `FIN_WAIT1 —> CLOSEING —> TIME_WAIT`，也就会`【最后同时进入 TIME_WAIT 状态】`

![alt](https://img-blog.csdn.net/20170410153759607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 应用层的进程，同时发出关闭命令，两端均从 `ESTABLISHED` 变为了 `FIN_WAIT1` 状态，同时发送 `FIN` 段给对方

- `发送完 FIN 段后，并未收到对端的 ACK 而是对方发来的一个 FIN 段，于是直接进入 CLOSING 状态`，这个状态只有在两端同时关闭的场景中才会出现。

- 在 CLOSEING 状态下`接收到自己的 FIN 包的 ACK 包的话，那么就进入 TIME WAIT 状态`。

### `TIME_WAIT` 状态

`MSL: Max Segment Lifttime` 最大报文段生存时间

- 如果主动关闭方不进入 TIME_WAIT，那么在主动关闭方对被动关闭方 FIN 包的 ACK 丢失了的时候，被动关闭方由于没收到自己 FIN 的 ACK，会进行重传 FIN 包；

- 这个 FIN 包到主动关闭方后，由于这个连接已经不存在于主动关闭方了，这个时候主动关闭方无法识别这个 FIN 包，协议栈会认为对方疯了，都还没建立连接你给我来个 FIN 包？，于是回复一个 `RST` 包给被动关闭方，被动关闭方就会收到一个错误 (我们见的比较多的：`connect reset by peer`，这里顺便说下 `Broken pipe`，在收到 `RST` 包的时候，还往这个连接写数据，就会收到 `Broken pipe` 错误了)，原本应该正常关闭的连接，给我来个错误，很难让人接受。

#### `TIME_WAIT` 为什么要等待 `2MSL`

> 避免残余报文被新连接接收；确保被动方正常关闭

- 当 TCP 连接断开时候，执行`【主动关闭那一端】`在发完最后一个 `ACK` 报文后，会进入 `TIME_WAIT` 状态，等待 `2MSL`（每个分节最长生命期）

- 该状态存在于主动方 `收到被动方的 FIN 并返回 ACK 包后`的状态 ，当处于 `TIME_WAIT` 状态时，我们无法创建新的连接，由于端口被占用了

**`TIME_WAIT` 状态存在的理由：**

- 一个数据报在发送途中或者响应过程中有可能成为残余的数据报，因此必须等待足够长的时间 `避免残余数据报影响新链接`

- `确保被动关闭方正常关闭`，比如主动关闭方发完 ACK，但被动关闭方没收到，就会重发一个 FIN 之后，客户端等待 `2MSL` 保证能对这个报文进行应答

#### `TIME_WAIT` 会带来哪些问题

[服务端 TCP 链接的 TimeWait 问题](http://ningg.top/computer-basic-theory-tcp-time-wait)

[说说 TIME_WAIT 状态](https://www.cnblogs.com/yjf512/p/5327886.html)

> 主要是你要等 `2MSL` 那么久，占着资源肯定不好啊

- 作为服务器，`【短时间内关闭了大量的客户端连接】，就会造成服务器上出现大量的 TIME_WAIT 连接`，比如说`【有大量的短链接】`存在，严重消耗着服务器资源

- 作为客户端，短时间内大量的短链接，会大量消耗客户端的 **`端口`** ，毕竟端口最多也就`65535` 个，端口耗尽了，后续就无法发起新的链接

#### 如何避免 `TIME_WAIT`

[`TIME_WAIT` 状态](https://zhid.baidu.com/question/518425014.html)

- 根据业务设置 `HTTP 开启 keepalive 长连接`，避免出现大量 `【短连接】`

- 设置套接字选项 **SO_REUSEADDR 允许端口复用**

  - 服务器可以设置 `SO_REUSEADDR` 套接字选项来通知内核，如果端口忙，但 TCP 连接位于 `TIME_WAIT` 状态时可以`重用端口`

  - **或者** 内核开启 `tcp_tw_reuse` 和 `tcp_timestamps` 选项才可以开启 TIME_WAIT 重用

  - `tcp_tw_reuse` 是内核选项，而 `SO_REUSEADDR` 用户态的选项

    使用 SO_REUSEADDR 是告诉内核，如果端口忙，但 TCP 状态位于 TIME_WAIT，可以重用端口。

    如果端口忙，而 TCP 状态位于其他状态，重用端口时依旧得到一个错误信息，指明 `Address already in use`。如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时 `SO_REUSEADDR` 选项非常有用。但是，没有了 `TIME_WATI` 就会有上面说到的为什么要有 `TIME_WAIT` 的三点危险，虽然发生的概率不大。

- **`快速回收`**

  需要同时打开 `tcp_tw_recycle` 和 `tcp_timestamps`（默认打开）两选项

#### `连接池`可以复用连接，是不是意味着，需要等到上个连接 `TIME_WAIT` 结束后才能再次使用

**不用**，`TIME_WAIT` 状态的连接不会存放在连接池中

- 连接池复用，复用的一定是 **活跃的连接**

  - 所谓活跃，第一表明连接池里的连接都是 `ESTABLISHED` 的

  - 第二，连接池做为上层应用，会有定时的心跳去保持连接的活跃性

- 既然连接都是活跃的，那就不存在有 `TIME_WAIT` 的概念了（`TIME_WAIT` 是在主动关闭连接的一方才进入的状态）既然已经关闭了，那么这条连接肯定已经不在连接池里面了，即被连接池释放了

### `CLOSE_WAIT` 产生太多原因，怎么处理

回想一下四次挥手，被动关闭方收到第一个 FIN 报文后进入 `CLOSE_WAIT` 状态，随后自身的数据处理完成，调用 `close()` 关闭连接，进入到 `LASK_ACK` 状态。

- **`CLOSE_WAIT` 产生太多原因**

  比如是客户端要与服务端断开连接，先发一个 FIN 表示自己要主动断开连接了，服务端会先回一个 ACK，这时表示客户端没数据要发了，`但有可能服务端数据还没发完，所以要进入 CLOSE_WAIT 状态`，等待服务端数据发送完，再回一个 FIN 和 ACK。

  正常操作的话应该 `很短暂的一个状态`，接收到客户端的 FIN 包并且回复客户端 ACK 之后，会继续发送 FIN 包告知客户端关闭关闭连接，之后迁移到 `LAST_ACK` 状态。但是 CLOSE_WAIT 过多只能说明没有迁移到 `LAST_ACK`，也就是服务端是否发送 FIN 包，只有发送 FIN 包才会发生迁移，所以`问题定位在是否发送 FIN 包。FIN 包的底层实现其实就是调用 socket 的 close 方法，这里的问题出在没有执行 close 方法，说明服务端 socket 忙于读写。`

- **`CLOSE_WAIT` 太多解决方法**

  - 使用完 socket 就调用 `close` 方法

  - 如果 read 读取的长度为 0 时（读到结尾），立即 `close`

  - 如果 read 读取错误，返回 `-1`，检查 error 返回码，如果 `不是 AGAIN`，立即 close`

  - 可以设置 TCP 的连接时长 `keep_alive_time` 还有 tcp 监控连接的频率以及连接没有活动多长时间被迫断开连接

## 同步序列号有什么作用

> 同步序列号涉及到 `三次握手、报文重组、确认机制`

- 接收方可以【去除重】复的数据

- 接收方可以根据数据包的序列号按顺序接收，【避免乱序】

- 可以标识发送出去的数据包中，哪些是已经被对方收到的，【确认机制】

## ★ 可靠性

- `为什么不在 IP 层去做可靠性`

  - 因为网络层的`任务是快速把报文路由转发出去`

  - `传输层 TCP` 已经做了，不用增加消耗

  - 而且甚至都可以不要`IP` 层，用`数据链路层` 也可以完成点到点的传输

- `为什么要保证可靠`

  数据传输过程中有可能出现`差错、丢包、失序、重复`

- 应用数据会被分割成 `TCP` 认为最适合发送的数据段发送给 `IP` 层（即上面说到的 `MSS` 最大报文段限制）

- `TCP` 发出去一个段之后，就启动一个 `保活定时器`，（保活计时器通常设置为 2 小时）等待目的端确认收到这个报文段，如果收不到就会重发（重传机制）

- `TCP` 收到数据后，会发送一个确认，告知对方自己收到这个报文了，确认+定时器决定了什么时候要重传，如果已经确认那就不需要重传了；但是也不是立马就发送，而是会 `延时几分之一秒，如果有数据需要发送的话，会跟这些数据一起发送`，以此来提高效率

- `TCP` 报文段是放到 `IP` 数据包里传输的，有可能会失序；所以 `TCP` 要自己根据接收到的数据进行重新排序；重复的数据会被丢弃掉

### 怎么保证传输过程的可靠性

发送数据之前先进行 `三次握手建立连接`，确保双方都能正常收发数据；每个报文都有独特的 SYN 编号，根据编号确定数据包的顺序，确保收到报文后，不会出现乱序、重复、差错；会对已经接收到的报文进行确认，对没被确认的报文，有超时重传机制，来保障不会出现报文丢失 `丢包`；收到报文后，对报文进行校验，保证数据包的完整性；向对端通告自身窗口大小，来控制对方的发包频率，避免处理不过来而导致丢包；通过一系列拥塞控制算法来试探网络拥塞情况，控制自己的发包频率，避免丢包。

- `面向连接`

  三次握手和四次挥手的过程

- `序号` 来确保不会失序和重复

- `确认 + 超时重传` 来确保没有丢包

  TCP 进行传输时数据都进行了编号，每次接收方返回 ACK 都有 `确认` 序列号

  如果发送方发送数据一段时间后没有收到 ACK，那么就 `重发` 数据

- `校验和机制` 来确保没有差错

  发送方在发送数据之前计算校验和，`确保数据没有差错`；接收方收到数据后同样计算，如果不一致，那么传输有误

- `流量控制`

  TCP 协议报头包含 16 位的`窗口大小`，接收方会在返回 ACK 时同时把自己的即时窗口填入，发送方就根据报文中窗口的大小 `控制发送速度`

- `拥塞控制`

  刚开始发送数据的时候，拥塞窗口是 1，以后每次收到 ACK，则拥塞窗口+1，然后将拥塞窗口和收到的窗口取较小值作为实际发送的窗口，如果发生超时重传，拥塞窗口重置为 1。`这样做的目的就是为了保证传输过程的高效性和可靠性`

### 延时确认机制

> - **我是一个 ACK 包，刚才有人叫我过去，可我想再等等，有货车一起的话，我就搭便车，如果没有的话，我再自己打快车过去**
> - 经受时延的确认（就是延时确认）
> - [TCP 的 ACK 原理和延迟确认机制](https://www.cnblogs.com/wangshaowei/p/11063101.html)

- 收到一个包之后，如果暂时没有什么数据要发给对方，会延迟一段时间之后再确认（一般是 200ms，但并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔 200ms 会来检查是否需要发送 ACK 包）

  - `ACK 是可以合并的`，也就是指如果连续收到两个 TCP 包，并不一定需要 ACK 两次，只要回复最终的 ACK 就可以了，可以降低网络流量。

  - 如果接收方有数据要发送，那么就`会在发送数据的 TCP 数据包里，带上 ACK 信息`。这样做，可以避免大量的 ACK 以一个单独的 TCP 包发送，减少了网络流量。

- `好处`

  假如在延迟确认这段时间里刚好有包要发，就可以在发数据的时候把确认信息带过去，省了一个纯粹的确认包，很多 TCP 默认协议栈默认启动了延迟确认，正是这样可以节省带宽。

- `坏处`

  多出一段延迟，一般来说偶尔的浪费 `200ms` 不算什么严重问题，但是如果在同一窗口存在大量这种情况，就会严重影响性能，因为延迟太久甚至会导致超时重传。还有如果 TCP 窗口极小的情况，出现延迟超时会雪上加霜

- `ACK` 的确认号，是确认按序收到的最后一个字节序，对于 `乱序到来的 TCP 分段，接收端会回复相同的 ACK 分段，而不是重组之后的最大序号，只确认按序到达的最后一个 TCP 分段`。TCP 连接的延迟确认时间一般初始化为最小值 40ms，随后根据连接的 `重传超时时间（RTO）`、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。

  - `RTO` 较大时，重传就慢，丢包丢了半天才发现，效率低，性能差

  - `RTO` 较小时，会导致可能并没有丢包就冲床了，重传太快，增加网络拥塞，导致更多的超时，更多的超时又导致更多的重发

  - `RTO` 的值应该略大于往返`RTT` 的值

### 累积确认机制

> 一连串消息发过来，每个都回复，太低效了，我告诉你 **最新的消息** 已经收到了就行了

- 如果发送方发了包 1，包 2，包 3，包 4；接受方成功收到包 1，包 2，包 3。那么接受方可以发回一个确认包，序号为 4(4 表示期望下一个收到的包的序号；当然约定好用 3 表示也可以)，那么发送方就知道包 1 到包 3 都发送接收成功，必要时重发包 4。`一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包`

- TCP 要求接收方必须有`累积确认功能`，这样可以减小传输开销

- TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

- 假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且`中途如果有应答报文丢失，可以通过下一个确认应答进行确认`，这个模式就叫`累计确认（累积应答）`

### 超时重传机制

> 我打电话跟你说话，你半天还没回复我，是不是信号不好啊？我再说一次

- 超时重传指的是，发送数据包在一定的时间周期内没有收到相应的 ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。这个等待时间被称为 RTO

- TCP `每发送一个报文段，就设置一次定时器`。只要定时器设置的重发时间到而还没有收到确认，就要重发这一报文段

- TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段(UDP 才是发报文段)。 `发送窗口没收到确认不动，和收到新的确认后前移`

- **重传队列**

  在 `TCP重传队列中保存着发送而未被确认的数据包`，数据包 skb 中的 TCP 控制块包含着一个变量， `tcp_skb_cb->when`，记录了该数据包的第一次发送时间。

- **指数退避算法**

  > 在失败重试场景中，会设定一定的时间间隔和重试次数，避免不必要的频繁重试

  比如第一次失败后，隔 1 秒重试，再次失败就隔 3 秒重试，还是失败就隔 7 秒，一共尝试 n 次；当然，没有限定必须隔多少秒，意思是下次重试会调大重试的时间间隔

- **`RTT (Round-Trip Time)`** 数据包从发出去到回来的时间，即数据包的一次往返时间

  ![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg)

- `RTO (Retransmission Timeout)` 超时重传时间

  ![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg)

  - 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；

  - 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

### 校验和机制

- 维护一个端到端的校验和，来`校验发送的数据是否有差错`，如果有差错的话，不会发送确认报文，来触发对端的超时重传机制

- `16位` 校验和，对`TCP` 头与数据进行校验

## ★ （自身）流量控制

接收方 通过 TCP 报文窗口字段【告知发送方自己可接收的最大数据量（窗口）】，`解决发送方发送速率过快导致接收方无法接收的问题`

![alt](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwwTDZWIWFC9LakSgxrYMZGQib57JdYribwbrX2jQofvNhqfIb5vKNxnWvhvvPWOVrhJkF21brtQoRg/640?wx_fmt=png)

- `为什么要进行流量控制`

  因为可能对端网络环境不太好，或者对端处理不过来，就要把窗口变小了；如果本端还按这个速度发包，丢包可能性太高，丢包又会触发重传

- `控制出口流量`

  其实我们做流控的实现方法就是丢包。`故意把包丢掉，让协议栈误以为对端网络质量不好，然后限制自己的发送窗口`；但是又不能直接把整个会话的内容都丢掉，否则就被认为断网了，而是从各个会话中抽一些报文丢掉

- `控制入口流量`

  报文发出去的时候，`故意把窗口的值设置得小一点通报给对方`，触发对端的滑动窗口机制调节速度

### 滑动窗口协议

> 用来做流量控制的

![alt](https://mmbiz.qpic.cn/mmbiz/IJUXwBNpKlght4qBPsv9anqIqMEYwnicRZ77CVl6gZppKxPycUNfTicC8ICsib2fzNibekOicyuaCAz4rXfUBY7prOg/640?wx_fmt=other)

- 通过窗口机制来告诉对方，自己当前可以接收多少的数据，来让对方放慢发送速率

- 也可以用在链路层、传输层；区别在于链路层是以帧为单位进行确认，传输层是以字节为单位进行确认

#### 为什么引入滑动窗口

`TCP 发送一个数据，需要收到确认应答后，才能发送下一个数据` 这种应答方式有个缺点：数据报的往返时间越长，通信的效率就越低

引入滑动窗口的概念，即使在往返时间较长的情况下，也不会降低网络通信的效率

- 可以指定窗口大小，窗口大小就是指`无需等待确认应答，而可以继续发送数据`的最大值

- 假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且中途如果有 ACK 丢失，也还可以通过下一个确认应答进行确认，这个模式就叫`累计确认（累积应答）`

#### 滑动窗口工作流程

![图解 | 你管这破玩意儿叫 TCP](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRRr0taZIyx3pxsoyuia1c5u6EKcBw1qdxRXE5icLiaVqcxLhJiaM9VsiabWibFtmtTwjCsngRvH6HK8zRA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

![滑动窗口](http://file.elecfans.com/web1/M00/C7/32/o4YBAF9pw4eAPs3UAADFnNR-K78167.png)

- `发送端`

  - 从图中看出，A 的窗口大小为 `31 到 50` 即 20 字节

  - `26 到 30` 都是已经被接收端确认了的，即这几个数据已经被对端接收到了，这些数据已没有存在价值，可以丢弃了

  - `31 到 41` 为已发送但未确认的字节，即已经交由下层去发送了，但是还没收到确认消息

  - `42 到 50` 为仍支持发送的字节大小，但是还留在缓冲区没有发送出去的数据

  - 如果`31 - 41` 被确认，则窗口将会滑动到`42 到 61`，又可以容纳 20 个字节

- `接收端`

  - 数据承载与 `IP层` 发送，但是 IP 层并不保证数据能按序到达，所以接收端接收到的数据很有可能是乱序的

  - 图中接收端最先接收到的是 `32 和 33` 两个字节，可是实际上接收端期望接收到的是 `31`，接收到 `31` 它才会发送确认报文进行确认

  - 那这些先到达的 `32 和 33` 是被丢弃掉吗？`接收端虽然不会确认乱序的报文` 但是也不会丢弃这些报文，而是缓存起来

  - 等到 `31` 报文来了之后，接收端已经收到 `31、32、33` 三个数据了，那是否再逐个对这几个数据进行确认呢？并不会，这样效率太低了，既然我都收到 `31、32、33` 了，我肯定不会再去确认 `31` 啊，回顾一下 `ACK` 的意义，`ACK` 的意义是告诉对方 `31` 我收到了，你下次发 `32` 过来；那我现在都已经收到 `32` 了，干嘛还让对方发`32`，这不浪费时间吗，所以我直接告诉对方，我收到 `33` 了，你发`34` 过来吧，即**累计确认机制**

  - 接收端接收到之后，就会把接收端口滑动到 `34 到 53`

#### 滑动窗口机制

TCP 连接的每一端都必须设有两个窗口, 一个`发送窗口`和一个`接收窗口`；TCP 采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节。对应 `socket编程中讲的接收缓冲区、发送缓冲区`

- `发送窗口 / 缓存`

  存放发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。

- `接收窗口 / 缓存`

  存放按序到达的、但尚未被接收应用程序读取的数据；不按序到达的数据。

- 在 TCP 报文段首部的窗口字段写入的数值就是当前 `给对方设置的发送窗口数值的上限`。发送窗口在连接建立时由双方商定。但在通信的过程中，【接收端可根据自己的资源情况，随时 `动态地调整对方的发送窗口`上限值(可增大或减小)】。 这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知，所以 A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）

#### 窗口大小

预防应用程序发送的数据超过对方的缓冲区，保证接收端接受的数据落在接收端的缓冲区之内，不至于丢失，以 `避免发生数据丢失导致超时重传，加剧网络负担`

- 发送端维护一个发送窗口（即缓冲区）和接收端也会维护一个接收窗口，发送端发送的数据不能超过接收窗口的缓冲区，否则会导致数据的丢失

- 发送端发送数据的时候并不知道对方的接收窗口大小

  上面说了 `TCP` 报文中有个 `窗口大小` 字段，在三次握手建立连接的时候就已经向对方通告了自己的 `窗口大小` 了

- **是不是发送窗口越大就越好**

  虽然发送窗口越大发送端发送数据就会越多，但是对端还有一个 `接收窗口的限制，对方无法接收，就会将多余的数据丢失，发送端没收到确认就会 【触发超时重传机制】`，加大网络负担，从而降低了网络速度，所以并不是越大越好，而是越匹配越好

#### 滑动窗口为 0 时，发送端会做什么

> 有个`坚持定时器`，就是用来定时探测窗口的，`零窗口探测`

发送端不再发送数据，而是定时发送一个探测包，获取对方的窗口大小

#### 大文件传输为什么越来越快

> 滑动窗口，慢启动算法，越传越快

可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。明显是一个线性上升的算法

#### 滑动窗口工作流程

![滑动窗口](http://file.elecfans.com/web1/M00/C7/32/o4YBAF9pw4eAPs3UAADFnNR-K78167.png)

- `发送端`

  - 从图中看出，A 的窗口大小为 `31 到 50` 即 20 字节

  - `26 到 30` 都是已经被接收端确认了的，即这几个数据已经被对端接收到了，这些数据已没有存在价值，可以丢弃了

  - `31 到 41` 为已发送但未确认的字节，即已经交由下层去发送了，但是还没收到确认消息

  - `42 到 50` 为仍支持发送的字节大小，但是还留在缓冲区没有发送出去的数据

  - 如果`31 - 41` 被确认，则窗口将会滑动到`42 到 61`，又可以容纳 20 个字节

- `接收端`

  - 数据承载与 `IP层` 发送，但是 IP 层并不保证数据能按序到达，所以接收端接收到的数据很有可能是乱序的

  - 图中接收端最先接收到的是 `32 和 33` 两个字节，可是实际上接收端期望接收到的是 `31`，接收到 `31` 它才会发送确认报文进行确认

  - 那这些先到达的 `32 和 33` 是被丢弃掉吗？`接收端虽然不会确认乱序的报文` 但是也不会丢弃这些报文，而是缓存起来

  - 等到 `31` 报文来了之后，接收端已经收到 `31、32、33` 三个数据了，那是否再逐个对这几个数据进行确认呢？并不会，这样效率太低了，既然我都收到 `31、32、33` 了，我肯定不会再去确认 `31` 啊，回顾一下 `ACK` 的意义，`ACK` 的意义是告诉对方 `31` 我收到了，你下次发 `32` 过来；那我现在都已经收到 `32` 了，干嘛还让对方发`32`，这不浪费时间吗，所以我直接告诉对方，我收到 `33` 了，你发`34` 过来吧，即**累计确认机制**

  - 接收端接收到之后，就会把接收端口滑动到 `34 到 53`

#### 糊涂窗口综合征

> 实际上是如何避免大量小包的问题

如果接收端处理能力很慢，这样接收端的窗口很快被填满，然后接收处理完几个字节，`腾出几个字节的窗口后，通知发送端，这个时候发送端马上就发送几个字节给接收端吗`？发送的话会不会太浪费了

- **在接收端解决**

  `接收端不通知小窗口`，当窗口比较小的时候，就 ACK 一个零窗口，让发送端继续等待，不要发数据过来

- **在发送端解决**

  `Nagle 算法` 制定了一堆规则，规定了哪些包在什么情况下允许发送

## ★ （网络）拥塞控制

> `防止数据被过多发到网络中导致网络资源（路由器、交换机等）过载`

- 对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，网络的吞吐量随之负荷的增大而下降。

- 大量数据报涌入同一交换节点（如路由器），导致该节点资源耗尽而必须丢弃后面到达的数据报时，就是拥塞

### 为什么要有拥塞控制呀，不是有流量控制了吗

TCP 是端到端通信的，通信时通报的都是发送端和接收端的窗口大小，网络中经过的路由器缓冲区大小是不知道的，所以`要有拥塞控制机制来确保网络不拥堵`

- 虽然 TCP 是端到端的通信（即不需要考虑中间是怎么传递的），但实际上报文在传输过程中会经过很多的路由器，路由器也是运行在 `IP` 层的，路由器也有自己的接收缓冲器，而三次握手交流缓冲区大小是端到端之间的，即 `通告接收端口 rwnd`，所以**接收端并不知道中间路由器的缓冲区大小，所以为了适应网络的能力，`拥塞窗口 cwnd` 就出来了**，所以实际上确定的窗口就是 `拥塞窗口和通告接收窗口的最小值`

  上面说了中间经过的路由器和路由器承载能力都是不确定的，所以这个窗口需要动态的调整，这就扯到`慢启动`、`拥塞避免` 这些内容了

- 网络出现拥塞时，如果继续发送大量的数据报，可能会导致数据包延时、丢失等；这时就会触发 TCP 的重传机制，但是一重传又加重了网络拥塞，就会一直恶性循环下去

- `流量控制`

  - 修改自己的窗口大小，`迫使对方降低发包速度`，我装不下了；流量控制是`端（发送端）对端（接收端）控制`

  - 流量控制是避免**`发送方`** 的数据填满**`接收方`** 的缓存区，当时并不知道网络中发生了什么事情

- `拥塞控制`

  - 根据对方的接受能力，`控制自己的发包节奏`，避免出现过多的重传，加重网络拥塞；拥塞控制`涉及网络链路全局`，所以属于`全局控制`

  - 拥塞控制的目的是，根据**`接收方`** 的接受能力，**`控制发送方`** 的发送速度，避免数据报填满整个网络

### 怎么知道当前网络是否出现了拥塞

![alt](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXRRr0taZIyx3pxsoyuia1c5uaoFvUia5aDwWk5OH2r1IiaiaM870gxy0U4dic5WelO9Q1ibEicTc1WZG22kw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1)

`发送方`没有在规定时间内接收到 ACK 应答报文，也就是 `发生了超时重传`，就会认为网络出现了用拥塞

### 什么是拥塞窗口，和发送窗口有什么关系

> 拥塞窗口和接收窗口中的最小值

- `cwnd` 拥塞窗口 是`发送方`维护的一个的状态变量，它会根据网络的拥塞程度动态变化

- 发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系，那么由于引入了拥塞窗口的概念后，此时发送窗口的值是 `swnd = min(cwnd, rwnd)`

### ★ 拥塞控制方法有哪些

> - [拥塞控制方法](https://www.cnblogs.com/losbyday/p/5847041.html)
> - 慢启动、拥塞避免、快重传、快恢复

![alt](https://pic3.zhimg.com/v2-de79bf2c38bddb0c1caf5768577648e2_r.jpg)

旧版本直接拥塞发生：

![alt](https://img-blog.csdnimg.cn/20200501233735863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ptaWxr,size_16,color_FFFFFF,t_70)

新版本采用快重传和快恢复：

![alt](https://img-blog.csdnimg.cn/20200501233900671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ptaWxr,size_16,color_FFFFFF,t_70)

#### 讲一下拥塞控制的过程

> 拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口（cwnd）

`cwnd（congestion window）`拥塞窗口、`ssthresh（slow start threshold）` 慢启动阈值

- `慢启动阶段`

  拥塞窗口从 `1` 开始按 `指数增长`直到达到慢启动阈值 `ssthresh`（这个阈值一般是 `65535`），就进入拥塞避免算法。

- `拥塞避免阶段`

  达到慢启动阈值之后，需要把发送速度降低下来以免发生拥塞，原来是指数增长的，增长很快，`现在改为线性增长`，相对来说会减缓很多了

- `发生拥塞`

  虽然已经改成线性增长了，但还是在增长，如果增长到了 `慢启动阈值ssthresh`，就很`极端的快速将窗口重置为 1，并且将 慢启动阈值ssthresh 减半`；再次回到慢启动过程

- `快重传 + 快恢复`

  - 接收方每收到一个失序的报文段后就立即发出重复确认，`发送方只要收到 3 个重复确认就立即重传`。

  - 当发送方连续收到三个重复确认，就将慢启动门限减半，将当前的窗口设置为慢启动门限，并采用拥塞避免算法。（采用快恢复算法时，慢启动只在建立连接和网络超时时才使用）

#### 慢启动算法

上面说到了，发送接收双方需要确认窗口有多大，但是中间网络是变化不定的，所以 `需要慢慢地去探测一下这条线路的网络承载能力`

![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg)

新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况 **逐步增加** 每次发送的数据量，否则很容易导致网络中路由器缓存空间耗尽，从而发生拥塞

**算法过程：**

- TCP 连接完成，初始化拥塞窗口 `cwnd = 1`，表明可以传一个 MSS 单位大小的数据。

- 每当收到一个 ACK，`cwnd` 就加一;

- 每当过了一个 RTT，`cwnd 就增加一倍; 呈指数让升`

#### 拥塞避免算法

由慢启动阶段的指数增长，变为线性上升。

![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg)

**算法过程：**

- 每收到一个 ACK 时，`cwnd = cwnd + 1 / cwnd`

- 当每过一个 RTT 时，`cwnd = cwnd + 1`

- 显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

#### 拥塞发生算法

就是由指数增长变为线性增长；`一旦出现网络拥塞，就立即 把【窗口重置为 1】，把【慢启动阈值降一半】，重新开始慢启动`

![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg)

**算法过程：**

- 慢启动阀值 `sshthresh = cwnd / 2`

- `cwnd` 重置为 1

- 进入新的慢启动过程

#### 快重传算法（搭配快恢复使用）

![alt](https://img-blog.csdn.net/20160909153345254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

- 只要还没收到 `A` 报文，就只会回复对 `A - 1` 报文的确认，告知对方我还没拿到 `A` 报文

  如果接收端没有收到 A 报文，而先收到了 `A + 1` 报文，按照快重传算法的规定，接收方应 `再次发送对 A - 1 报文的重复确认`，如果接收方还是没收到 A 报文，而是收到了后续的 `A + 2`,`A + 3` 报文，则`【接收方仍然是发送 A - 1 的确认】`

- `发送方收到连续三个对 A 报文的确认，就【立即重发A报文，而不会等待到超时才重发】`

#### 快恢复算法

快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，`【还能收到 3 个重复 ACK 说明网络也不那么糟糕】`，所以没有必要像 RTO 超时那么强烈

![alt](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/30.jpg)

- `拥塞发生算法`说了，碰到高压线`慢启动阈值 ssthresh` 就直接把窗口置为`1` 了，重新开始慢启动而且将`ssthresh` 减半，即虚线部分

- `快恢复` 的做法则是将`拥塞窗口cwnd 设置为慢启动阈值ssthresh 的一半，然后开始执行拥塞避免算法`，使窗口缓慢增大

**算法过程：**

- `cwnd = sshthresh + 3`

- 重传重复的那几个 ACK（即丢失的那几个数据包）

- 如果再收到重复的 ACK，那么 `cwnd = cwnd + 1`

- 如果收到新数据的 ACK 后, `cwnd = sshthresh`。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

## 四个定时器

> 坚持定时器（`探测窗口`大小） -->
>
> 保活定时器（`探测连接`是否还在） -->
>
> 重传定时器（`对报文确认`的等待时间） -->
>
> 时间等待定时器（2MSL 避免旧连接的报文对新连接产生影响、确保被动关闭方能正常`关闭`）

[动手学习 TCP：4 种定时器](https://www.cnblogs.com/wilber2013/p/4854526.html)

- `重传定时器`

  > 对报文段确认的等待时间

  由于网络环境的易变性，该定时器时间长度肯定不是固定值；该定时器时间长度的设置依据是`数据从网络的一端传送到另一端所需要的时间，即 RTT（Round Trip Time）`，根据网络环境的变化，TCP 会根据这些变化并相应地改变超时时间。

- `坚持定时器`

  > 定时检查窗口大小变化

  - 万一通知发送方窗口大于 0 的`ACK` 丢了，则双方就有可能因为等待对方而使连接死锁。接收方等待接收数据（因为它已经向发送方通告了一个非 0 的窗口），而发送方在等待允许它继续发送数据的窗口更新

  - 因此发送方使用一个`坚持定时器 (persist timer)` 来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查（window probe），使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口

- `保活定时器`

  > 用来探测与对端的 TCP 连接是否还在

  保活计时器通常设置为 2 小时。若服务器过了 2 小时还没有收到客户的信息，它就发送探测报文段。若发送了 10 个探测报文段（每一个相隔 `75 秒`）还没有响应，就假定客户出了故障，因而就终止该连接。

- `时间等待定时器 2MSL`

  > 用于测量一个连接处于`TIME_WAIT` 状态的时间

## TCP 保活机制

- 系统多在 OA 网和外网间有防火墙隔离，很多防火墙对一段时间内没有报文活动的 socket 会自动关闭

- 对于非正常断开的连接系统并不能侦测到，比如防火墙关闭端口、网线被拔掉、未关闭应用程序直接关机等，这些`异常情况导致 TCP 连未得到正常释放，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费`

### TCP 如何保持长连接 `keepalive`

- `应用层程序的心跳机制`

  自定义心跳消息头，一般客户端主动发送到服务端，服务端接收到后进行回应（也可以不进行回应），以便能够侦测到连接是否异常断开

- `TCP 协议自带的保活机制`

  通过设置 `内核` 的 `keepalive` 属性，并设置发送底层心跳包的时间间隔，我们的 `socket` 编程是写应用层程序，而 TCP 的 keepalive 是在底层定时发送心跳报文，服务端接收到后直接丢弃，不关心内容

  ```sh
  # linux内核包含对 keepalive 的支持

  # tcp_keepalive_time（开启keepalive的闲置时长）
  cat /proc/sys/net/ipv4/tcp_keepalive_time
  7200

  # tcp_keepalive_intvl（keepalive探测包的发送间隔）
  cat /proc/sys/net/ipv4/tcp_keepalive_intvl
  75

  # tcp_keepalive_probes （如果对方不予应答，探测包的发送次数）
  cat /proc/sys/net/ipv4/tcp_keepalive_probes
  9
  ```

### ★ 什么是长连接、短链接

- **`短连接`**

  建立一条连接，`传输一个请求，马上关闭连接`

  **短连接的优点**

  管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

- **`长连接`**

  就是客户端发送连接请求，连接成功后就 `一直【保持连接】，直到客户端和服务端断开连接`

  随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

### 长连接会一直保持吗

> 不会，有超时时间

- 一般服务端都会设置 `keepalive` 超时时间，超过指定时间间隔，`服务端会主动关闭连接`

- 参数 `content-length` 指明响应体数据的大小，浏览器收到如数的响应就知道响应完成了，就可以关闭连接了

## ★ 粘包问题

[TCP 粘包和拆包的原因及处理方案](https://www.cnblogs.com/hpu001/p/9925573.html)

### 为什么会有粘包问题

因为`TCP` 是基于字节流的传输服务，传输的数据都是字节，无法区分数据边界；从缓冲区读取数据有很多种可能

`UDP` 是基于消息的传输服务，传输的数据时报文，数据报之间是有边界的，`UDP` 能保证对端一次读操作可以把数据完成读取到

![粘包问题](https://img-blog.csdn.net/20151009215943286)

- 假设主机 A 发送了两条消息 M1 和 M2 各 10k 给主机 B，由于主机 B 一次提取的字节数是不确定的，接收方提取数据的情况可能是：

  ```
  - 一次性提取 20k 数据
  - 分两次提取，第一次 5k，第二次 15k
  - 分两次提取，第一次 15k，第二次 5k
  - 分两次提取，第一次 10k，第二次 10k（仅此正确）
  - 分三次提取，第一次 6k，第二次 8k，第三次 6k
  - 其他任何可能
  ```

- `TCP` 在读取数据的时候无法确定对端一次读操作能读取到多少个字节，无法知道对端是否已经读取到传输过去的数据报，有可能只读取了一半，也有可能把其他数据一起读进来了。

### 粘包问题怎么解决

> `粘包问题` 是由 TCP 协议的特性产生的，所以只能自己在应用层在应用层处理消息与消息之间的边界

- **`发送接收定长数据包`**

  - 每次发送消息的时候都指定本次发送的数据包长度，对端也按照这个长度来接收，`readn、writen 函数`

  - 这种方法缺点很明显，比如服务端接收缓存区为 1024 个字节，那么客户端每次发送都必须发 1024 个字节，与服务端匹配，如果客户端只发了 10 个字节，服务端会因为读取不到 1024 个字节而一直在等待。可是客户端实际要发送的数据只有 10 个字节，剩余的长度全部用 0 来填充，`加重了网络负担，降低效率`

- **`包尾加 \r\n 分隔符`**

  比如 `ftp` 协议就是这样做的，但是如果 `\r\n` 本身就是消息的一部分就不好区分了，`recv` 系统调用加上 `MSG_PEEK` 选项窥探缓冲区里的字符

- **`头部加上包体长度`**

  - 包头中记录着包体的长度，读取的时候根据这个长度来读取数据

  - 自定义一个协议，协议中包含数据的长度和数据部分

    ```cpp
    /*
     * 自定义数据包
     * 先接收 sizof(int) 个字节知道这个数据包有多长，然后在接收 len 个字节
     * 通信双方都要要按照这个协议来进行接受和发送
     */
    struct my_packet
    {
        /* 包头存放缓冲区实际的数据长度 */
        int len;
        /* 包体存放实际要发送的数据 */
        char buf[1024];
    };
    ```

## TCP `服务器`最大并发连接数是多少

> 理论上 `无上限`，与机器资源、操作系统限制有关

[TCP 连接数量最大不能超过 65535 个吗，那服务器是如何应对百万千万的并发的](https://www.q578.com/s-5-1319974-0)

- 可能会错误地以为是 `65535`

  之所以会以为是 `65535` 是因为，TCP 端口号有 `16` 位，端口数最多 `65535` 个

- 如何标识一个 `TCP` 连接

  四元组：`源IP + 源端口 + 目的IP + 目的端口（没有IP五元组中的 协议号）`

- 客户端的理论最大 TCP 连接数

  客户端与服务端发起连接前，需要绑定一个由系统分配一个空闲的端口号，而系统中端口号总共为 `65535` 个，`所以作为【客户端】最大 TCP 连接数为 65535 个`

- 服务端的理论最大 TCP 连接数

  服务端 `【只需要监听一个端口】`，然后就可以接受客户端的连接了，所以最大可接受的连接数和 IP 个数有关，为 `2^32（IP报文源地址为 32 位） * 2^16（TCP报文端口号为 16位） = 2^48` 个连接

- 客户端实际的连接数

  - 在 Linux 系统下，限制发起连接数的因素包括`内存` + `允许打开的文件描述符个数`（tcp 连接需要占用内存、打开的 socket 占用文件描述符）

  - 保留端口、知名端口不可分给客户端使用

- 服务端实际的连接数

  通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万，甚至上百万是没问题的

# 其他

- 冗余 ACK

- **选择性确认 `SACK`**

  在标准的 TCP 确认机制中，如果发送方发送了 0 - 10000 序号之间的数据，但是接收方只接收到了 0 -1000, 3000 - 10000 之间的数据，而 1000 - 3000 之间的数据没有到达接收端，此时发送方会重传 1000 - 10000 之间的数据，实际上这是没有必要的，因为 3000 后面的数据已经被接收了。但是发送方无法感知这种情况的存在。

  俗语来解释就是：“我这里最多允许接收 1000 之后的报文段，但是我却收到了 3000 - 10000 的报文段，请给我 1000 - 3000 之间的报文段”。

- 带宽的单位是 Mbps，1Mbps=1024Kbps=128KB/s，即 1Mbps 的带宽每秒传输的最大数据量为 128KB；

# 参考资料

- [★ TCP 基础知识](https://mp.weixin.qq.com/s/JVTc85ZDzS505pdPa4V5OQ)

- [帅地 - 计算机网络面试真题](https://www.iamshuaidi.com/673.html)

- [我用大白鲨让你看见 TCP](https://mp.weixin.qq.com/s/y89cPgaIBWeudJnsFRR-Ow)

- [★ 彻底弄懂 TCP 协议：从三次握手说起](https://mp.weixin.qq.com/s/6LiZGMt2KRiIoMaLwx-lkQ)

- [图解 | 你管这破玩意儿叫 TCP？](https://mp.weixin.qq.com/s/Xb-kcSAF0q7awMfx6Dgp6A)
