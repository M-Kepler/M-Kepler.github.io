- [一、为什么会出现跨域问题](#一为什么会出现跨域问题)
- [二、什么是跨域](#二什么是跨域)
- [三、非同源限制](#三非同源限制)
- [四、跨域解决方法](#四跨域解决方法)
  - [【1】设置 document.domain 解决无法读取非同源网页的 Cookie 问题](#1设置-documentdomain-解决无法读取非同源网页的-cookie-问题)
  - [【2】跨文档通信 API：window.postMessage()](#2跨文档通信-apiwindowpostmessage)
  - [【3】JSONP](#3jsonp)
  - [【4】CORS](#4cors)
  - [【5】webpack 本地代理](#5webpack-本地代理)
  - [【6】websocket](#6websocket)
  - [【7】Nginx 反向代理](#7nginx-反向代理)

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_38128179/article/details/84956552)

### 一、为什么会出现跨域问题

- 出于浏览器的`同源策略`限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

- 同源策略需要同时满足 `协议、域名、端口` 三者都相同；只要任意条件不满足，都存在 **跨域问题**

### 二、什么是跨域

当一个请求 url 的**协议、域名、端口**三者之间任意一个与当前页面 url 不同即为跨域

| 当前页面 url                                           | 被请求页面 url | 是否跨域                       | 原因 |
| ------------------------------------------------------ | -------------- | ------------------------------ | ---- |
| `http://www.test.com/` 和 `http://www.test.com/index.html`  | 否             | 同源（协议、域名、端口号相同） |
| `http://www.test.com/` 和 `https://www.test.com/index.html` | 跨域           | 协议不同（http/https）         |
| `http://www.test.com/` 和 `http://www.baidu.com/`           | 跨域           | 主域名不同（test/baidu）       |
| `http://www.test.com/` 和 `http://blog.test.com/`           | 跨域           | 子域名不同（www/blog）         |
| `http://www.test.com:8080/` 和 `http://www.test.com:7001/`  | 跨域           | 端口号不同（8080/7001）        |

### 三、非同源限制

【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB

【2】无法接触非同源网页的 DOM

【3】无法向非同源地址发送 AJAX 请求

### 四、跨域解决方法

#### 【1】设置 document.domain 解决无法读取非同源网页的 Cookie 问题

因为浏览器是通过 document.domain 属性来检查两个页面是否同源，因此只要通过设置相同的 document.domain，两个页面就可以共享 Cookie（此方案仅限主域相同，子域不同的跨域应用场景。）

```js
// 两个页面都设置
document.domain = 'test.com';
```

#### 【2】跨文档通信 API：window.postMessage()

调用 postMessage 方法实现父窗口 http://test1.com 向子窗口 http://test2.com 发消息（子窗口同样可以通过该方法发送消息给父窗口）

它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递

- 多窗口之间消息传递

- 页面与嵌套的 iframe 消息传递

- 上面三个场景的跨域数据传递

```js
// 父窗口打开一个子窗口
var openWindow = window.open('http://test2.com', 'title');

// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)
openWindow.postMessage('Nice to meet you!', 'http://test2.com');
```

调用 message 事件，监听对方发送的消息

```js
// 监听 message 消息
window.addEventListener('message', function (e) {
  console.log(e.source); // e.source 发送消息的窗口
  console.log(e.origin); // e.origin 消息发向的网址
  console.log(e.data);   // e.data   发送的消息
},false);
```

#### 【3】JSONP

`JSON with Padding` 的缩写，这玩意儿就是利用了 `<script>` 标签的 src 属性没有跨域限制的漏洞，让我们可以得到从其他来源动态产生的 JSON 数据。

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本 IE），缺点是只支持 get 请求，不支持 post 请求。

核心思想：网页通过添加一个 `<script>` 元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

① 原生实现：

```js
<script src="http://test.com/data.php?callback=dosomething"></script>
// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字

// 处理服务器返回回调函数的数据
<script type="text/javascript">
    function dosomething(res){
        // 处理获得的数据
        console.log(res.data)
    }
</script>
```

② jQuery ajax：

```js
$.ajax({
    url: 'http://www.test.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```

③ Vue.js

```js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res);
})
```

#### 【4】CORS

后台的请求响应头告诉浏览器 “我的这个请求很安全，允许当前域名跨域访问”。

CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

1、普通跨域请求：只需服务器端设置 `Access-Control-Allow-Origin`

2、带 cookie 跨域请求：前后端都需要进行设置

**【前端设置】** 根据 `xhr.withCredentials` 字段判断是否带有 cookie

① 原生 ajax

```js
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};
```

② jQuery ajax

```js
$.ajax({
   url: 'http://www.test.com:8080/login',
   type: 'get',
   data: {},
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
});
```

③vue-resource

```js
/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */

// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'
response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com");

// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示
response.setHeader("Access-Control-Allow-Credentials", "true");

// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");
```

④ axios

```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /*
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

【服务端设置】

服务器端对于 CORS 的支持，主要是通过设置 `Access-Control-Allow-Origin` 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。

① Java 后台

```js
<?php
 header("Access-Control-Allow-Origin:*");
```

② Nodejs 后台

```js
devServer: {
        port: 8080,
        proxy: {
            "/api": {
              target: "http://192.168.25.20:8088" // 后端接口
            }
        }
    }
```

③ PHP 后台

```ini
server {

    #nginx监听所有localhost:8080端口收到的请求
    listen       8080;
    server_name  localhost;

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;

    #localhost:8080 会被转发到这里
    #同时, 后端程序会接收到 "192.168.25.20:8088"这样的请求url
    location / {
        proxy_pass http://192.168.25.20:8088;
    }

    #localhost:8080/api/ 会被转发到这里
    #同时, 后端程序会接收到 "192.168.25.20:9000/api/"这样的请求url
    location /api/ {
        proxy_pass http://192.168.25.20:9000;
    }

    error_page 404 /404.html;
        location = /40x.html {
    }

    error_page 500 502 503 504 /50x.html;
        location = /50x.html {
    }
}
```

④ Apache 需要使用 mod_headers 模块来激活 HTTP 头的设置，它默认是激活的。你只需要在 Apache 配置文件的 `<Directory>, <Location>, <Files> 或 <VirtualHost>` 的配置里加入以下内容即可

```js
Header set Access-Control-Allow-Origin *
```

#### 【5】webpack 本地代理

![alt](https://img-blog.csdnimg.cn/img_convert/1512ec3b3811d93f6cea94c63e7f7874.png)

在 webpack.config.js 中利用 WebpackDevServer 配置本地代理，详情配置查看 [devServer](https://webpack.docschina.org/configuration/dev-server/#root "devServer")

如下简单配置案例，这样  `http://localhost:8080/api/getUser.php`  的请求就是后端的接口  `http://192.168.25.20:8088/getUser.php`

```ini
devServer: {
        port: 8080,
        proxy: {
            "/api": {
              target: "http://192.168.25.20:8088" // 后端接口
            }
        }
    }
```

#### 【6】websocket

Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是  WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的   服务器与   客户端都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

#### 【7】Nginx 反向代理

[Nginx](https://blog.csdn.net/qq_38128179/article/details/120543114) 实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。

使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

我们只需要配置 nginx，在一个服务器上配置多个前缀来转发 http/https 请求到多个真实的服务器即可。这样，这个服务器上所有 url 都是相同的域 名、协议和端口。因此，对于浏览器来说，这些 url 都是同源的，没有跨域限制。而实际上，这些 url 实际上由物理服务器提供服务。这些服务器内的 javascript 可以跨域调用所有这些服务器上的 url。

先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改如下：

```ini
server {

    #nginx监听所有localhost:8080端口收到的请求
    listen       8080;
    server_name  localhost;

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;
    #localhost:8080 会被转发到这里
    #同时, 后端程序会接收到 "192.168.25.20:8088"这样的请求url
    location / {
        proxy_pass http://192.168.25.20:8088;
    }
    #localhost:8080/api/ 会被转发到这里
    #同时, 后端程序会接收到 "192.168.25.20:9000/api/"这样的请求url
    location /api/ {
        proxy_pass http://192.168.25.20:9000;
    }
    error_page 404 /404.html;
        location = /40x.html {
    }
    error_page 500 502 503 504 /50x.html;
        location = /50x.html {
    }
}
```
