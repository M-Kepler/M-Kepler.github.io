- [参考资料](#参考资料)
- [`Zeromq` 三种模型](#zeromq-三种模型)
  - [注意](#注意)
  - [请求响应模型](#请求响应模型)
    - [`PAIR - PAIR`](#pair---pair)
    - [`REP - REQ`](#rep---req)
    - [`ROUTER - DEALER`](#router---dealer)
      - [负载均衡](#负载均衡)
    - [异步 REQ - REP 模型](#异步-req---rep-模型)
  - [发布订阅模型](#发布订阅模型)
    - [`PUB-SUB`](#pub-sub)
    - [发布者和订阅者消息同步问题](#发布者和订阅者消息同步问题)
  - [管道模型](#管道模型)
    - [`PUSH-PULL`](#push-pull)
- [推送和拉取](#推送和拉取)
- [其他](#其他)

# 参考资料

- [★ ZeroMQ 基础 - 三种消息模式](https://zhuanlan.zhihu.com/p/80460493)

- [★ ZeroMQ 之 Router 与 Dealer 运行原理](https://blog.csdn.net/kobejayandy/article/details/20163783)

# `Zeromq` 三种模型

代理模式和路由模式等都是在 `REP-REQ、PUB-SUB、PUSH-PULL` 三种基本模式上面的扩展或变异

**一些名词解释**

- `router` 路由

- `dealer` 经销商、贸易商

- `broker` 经纪人、掮客

- `frontend` 前端

- `backend` 后端

## 注意

- 大部分的关键字都是可以相互之间建立新的模式或者组合新的模式

- 这些只是基础的模式，根据需求可以设计自己需要的模式

## 请求响应模型

- `ZMQ_REQ` 模式在发送消息时，`ZMQ` 底层会在`消息内容头部插入一个空帧`，在接收消息时，会去掉空帧，将内容返回给应用层（就是定义一种交流协议，像 HTTP 协议那样，用空行把报文头和报文体隔开）。

  ```ini
  +--------------------+
  | +----------------+ |
  | |   proto head   | |     =====> 协议头
  | +----------------+ |
  | +----------------+ |
  | |                | |     =====> 空行
  | +----------------+ |
  | +----------------+ |
  | |     data       | |     =====> 数据
  | +----------------+ |
  +--------------------+
  ```

- `ZMQ_REP` 模式在接收消息时，会将消息空帧之前的信封帧保存起来，将空帧之后的内容传给上层应用。上层应用在响应消息时，底层会在响应消息前加上空帧以及对应请求的信封帧。

---

- `ZMQ_ROUTER` （以前叫作 `XREP` 升级版的 REP)模式在接收消息时，ZMQ 底层会`在消息头部添加上一个信封帧，用于标记消息来源`

  该信封帧可由发送端指定（调用 `zmq_setsockopt(ZMQ_IDENTITY)`），也可由接收端自动生成唯一标识作为信封帧。在发送消息时，将信封帧之后的内容发送到以信封帧为标识的地址

  ```ini
  +--------------------+
  | +----------------+ |
  | |   proto head   | |     =====> 协议头
  | +----------------+ |
  | +----------------+ |
  | |     address    | |     =====> 地址帧（或者叫标志帧）
  | +----------------+ |
  | +----------------+ |
  | |                | |     =====> 空行
  | +----------------+ |
  | +----------------+ |
  | |     data       | |     =====> 数据
  | +----------------+ |
  +--------------------+
  ```

- `ZMQ_DEALER` （以前叫作 `XREQ` 升级版的 REQ）模式，对接收到的消息公平排队，以 轮询调度（Round-Robin）的方式分发消息

  Dealer 收到了上图格式的数据，再通过 router 发送回 request 端，这个时候就可以通过前面的标志帧来知道究竟应该将数据发送给哪一个连接了，即，Dealer 才能解 Router 封装的数据包

---

- 四种可搭配出以下几种使用

  - 常规搭配：`ZMQ_REQ + ZMQ_REP`

  - 带输入负载均衡 (Round Robin) 搭配：`ZMQ_REQ + ZMQ_ROUTER`

  - 带输出负载均衡 (load-balance) 搭配：`ZMQ_DEALER + ZMQ_REP`

  - 消息分发搭配：`ZMQ_ROUTER + ZMQ_DEALER`

### `PAIR - PAIR`

```log
+------------+              +------------+
|            |              |            |
|   client   +------------->+   server   |
|            |              |            |
+------------+              +------------+
```

- 一对一模式，`PAIR` 类型的套接字只能一次连接到单个对等方

- 当 `PAIR` 套接字由于已达到连接对等方的高水位线而进入静音状态时，或者如果没有连接任何对等方，则套接字上的任何 `zmq_send()` 操作都应阻塞

### `REP - REQ`

请求应答模式（Request-Reply）（rep 和 req），消息双向的，有来有往，req 端请求的消息，rep 端必须答复给 req 端

![alt](https://img-blog.csdn.net/20131120125845921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzbG92ZWpobA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 客户端`必须先发送消息，再接收消息`；服务端必须先进行接收客户端发送过来的消息，再发送应答给客户端。如此循环。

- 服务端和客户端谁先启动，效果都是一样的，服务端在收到消息之前，会一直阻塞，等待客户端连上来。

- 一个服务端可以同时处理多个客户端的额链接

- `1 : 1`

  ```log
  +------------+              +------------+
  |            |              |            |
  |   client   +------------->+   server   |
  |            |              |            |
  +------------+              +------------+
  ```

- `n : 1`

  ```log
  +------------+
  |            |
  |  client_1  +-------+
  |            |       |
  +------------+       |
                       |
  +------------+       |      +------------+
  |            |       |      |            |
  |  client_2  +-------+----->+   server   |
  |            |       |      |            |
  +------------+       |      +------------+
                       |
  +------------+       |
  |            |       |
  |  client_3  +-------+
  |            |
  +------------+
  ```

- `n : m`

  ```log

                              +------------+
                              |            |
                      +------>+  server_1  |
                      |       |            |
                      |       +------------+
                      |
  +------------+      |       +------------+
  |            |      |       |            |
  |   client   +-------------->  server_2  |
  |            |      |       |            |
  +------------+      |       +------------+
                      |
                      |       +------------+
                      |       |            |
                      +------->  server_3  |
                              |            |
                              +------------+
  ```

### `ROUTER - DEALER`

- 对请求应答模式的扩展，一般的请求应答模式是同步的，服务端发送了数据，要等到客户端接收到数据后再发送回服务端才可以。而这个新模式是异步的，不需要等到客户端返回数据，就可以继续发送数据。

- 由请求端发起请求，并等待回应端回应请求。从请求端来看，一定是一对对收发配对的； 反之，在回应端一定是发收对。请求端和回应端都可以是 1：N 的模型。通常把 1 认为是 server，N 认为是 Client。

- ZMQ 可以很好的支持路由功能（实现路由功能的组件叫做 Device），把 1：N 扩展为 N：M（只需要加入若干路由节点）。

- 为了不将服务端直接暴露给 “客户端”，增加可扩展性，我们可以制作个中间层 broker（参照官方示例代码），更底层的端点地址是对上层隐藏的。每个请求都隐含回应地址，而应用则不关心

- 比如 request-reply 这种最简单的模型，我们可以通过一个中间组件将后面的服务透明化，增强系统的可扩展性，后台只需要增加 service 数目就可以增强服务能力

![alt](https://img-blog.csdn.net/20131124191730375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZmpzbG92ZWpobA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- `hwm high-water-marks` 高水位

  当发送端与接收端存在速度差的时候，就会把一些请求缓存到内存中（`socket` 好像也是这样的），`hwm` 就是表示这个缓冲区的大小，`zmq` 中可以指定这个缓冲区的大小。缓冲区总会满的，缓冲区满了会发生什么呢？（默认会丢弃消息）

- `ZMQ` 的 `Router、Dealer` 异步模式

  - 这两种模式是对请求应答模式的扩展，一般的请求应答模式是同步的，服务端发送了数据，要等到客户端接收到数据后再发送回服务端才可以

  - 而这个新模式是异步的，不需要等到客户端返回数据，就可以继续发送数据。

- `ZMQ` 代理 `zmq.proxy(frontend, backend)`

  - 启动内置 `ZMQ` 代理，最好先设置后前后端的 socker 属性

  - 代理将前端 socker 连接到一个后端

  - 代理是双向的，一般来说数据是从前端流向后端

  - 代理会扮演一个共享队列的角色，从许多的客户端接收消息，并且把这些消息公平的分发到服务端

  - 这些请求会被前端公平地放置在队列里进行接收，并通过后端进行均衡地分发，`回复会自动返回给原始请求者`

- 当前端是一个 `ZMQ_ROUTER` 套接字，并且后端是一个 `ZMQ_DEALER` 套接字时，`代理服务器将作为一个共享队列来收集来自一组客户端的请求`，并在一组服务中公平地分配这些请求。 请求应从前端连接公平排队并均匀分布在后端连接中。 回复将自动返回到发出原始请求的客户端，ROUTER + DEALER 组成的 broker 不处理任务，只是转发消息，通过 poll 实现异步 IO

  ```log
  +------------+                                          +------------+
  |            |                                          |            |
  |  client_1  +------+                           +------>+  worker_1  |
  |            |      |                           |       |            |
  +------------+      |                           |       +------------+
                      |                           |
  +------------+      |       +------------+      |       +------------+
  |            |      |       |            |      |       |            |
  |  client_2  +------------->+   ROUTER   +-------------->  worker_2  |
  |            |      |       |            |      |       |            |
  +------------+      |       +------------+      |       +------------+
                      |                           |
  +------------+      |                           |       +------------+
  |            |      |                           |       |            |
  |  client_2  +------+                           +------->  worker_3  |
  |            |                                          |            |
  +------------+                                          +------------+
  ```

- ROUTER 套接字会在消息的外层包裹一个来源地址

  ![alt](https://img-blog.csdnimg.cn/img_convert/ee5213e688e574a9a3cdcf96b5a9958c.png)

- `client` 对应ZMQ_REQ类型的zmq_socket

- `worker` 对应ZMQ_REP类型的zmq_socket

- `broker` 创建一个 `router` 和一个 `dealer`，`router` 接受 `client` 的消息并转发给 `worker`，`worker` 再把处理结果发送给 `dealer`，`dealer`再转发给 `client`

#### 负载均衡

[ZeroMQ 之负载均衡](https://blog.csdn.net/fjs_cloud/article/details/16943719) `zmq` 利用 `ROUTER 和 proxy` 做负载均衡

- client 对应 ZMQ_REQ 类型的 zmq_socket

- worker 对应 ZMQ_REP 类型的 zmq_socket

- broker 创建一个 router 和一个 dealer，router 接受 client 的消息并转发给 worker

  worker 再把处理结果发送给 dealer，dealer 再转发给 client

- 绝大多数的任务都是独立的，这里中间层可以将 A 发送过来的请求先缓存起来，然后 `B 的行为就是主动的找中间层获取请求处理`，然后返回，再获取；也就是`中间层只是做一个请求的缓存`；由 B 自己来掌控合适来处理请求，也就是当 B 已经处理完了任务之后，自己去主动获取，而不是由中间层自己去主动分发。

  ```log
  +------------+  +------------+  +------------+
  |   Client   |  |   Client   |  |   Client   |
  +------------+  +------------+  +------------+
  |  request1  |  |  request2  |  |  request3  |
  +------------+  +------------+  +------------+
         |               |               |
         +---------------+---------------+
                         |
                +--------v--------+
                | Frontend ROUTER |
                +-----------------+
                |      Proxy      |
                +-----------------+
                |  Backend ROUTER |
                +--------^--------+
                         |
         +---------------+---------------+
         |               |               |
  +------------+  +------------+  +------------+
  |  response  |  |  response  |  |  response  |
  +------------+  +------------+  +------------+
  |   worker   |  |   worker   |  |   worker   |
  +------------+  +------------+  +------------+
  ```

- 由两个 `Router` 做中间层

- `worker` 链接到 `后端路由中间层 Backend ROUTER`，向其发送 `Request` 请求，这时候中间层就知道那个 `worker` 是空闲的了，将其添加到工作队列中，等待处理请求

- `Client` 将请求发送到 `前端路由中间层 Forntend ROUTER`，中间层将这些请求缓存到任务队列中

- 中间层从任务队列取出一个任务，将其分配给 `worker` 队列中的一个 `worker`来处理，并将其从队列中移除

- `worker` 处理完之后，发送执行结果，中间层收到数据后，将其发送给 `相应的 Client`，然后返回到工作队列，等待接收新任务

- 如果只是为了应付 `多对一` 的场景，直接用 `socket + 多进程/多线程` 来处理不完事了吗？为什么还要引入 `zmq`？

  - 确实是这样的，直接多进程就完事了，可是这几个进程的负债能力是不一样的，有可能 A 进程忙坏了，B 进程空闲下来了，当还是分发（`socket` 貌似没有明确的分发机制）到了 A 进程来处理新进来的请求；所以引入 `zmq` 主要是为了利用 `Router-Dealer` 模式来做负载均衡

  - 可以通过中间层来先把请求`缓存`起来，然后服务端的行为就是`去中间层取消息`来处理，结束后再返回；也就是中间层仅仅是做个缓存的处理，主要是由服务端自己控制什么时候来消费消息，比如服务端 1 空闲了就去取任务来处理

  - 工作进程是无状态的，启动时有一份新的资源，包括 mysql 连接池

- `IDENTITY`

### 异步 REQ - REP 模型

![alt](https://img-blog.csdn.net/20131127150641343)

## 发布订阅模型

发布端是单向只发送数据的，且不关心是否把全部的信息都发送给订阅者。

- 如果发布端开始发布信息的时候，订阅端尚未连接上，这些信息直接丢弃。不过一旦订阅端连接上来，中间会保证没有信息丢失。同样，订阅端则只负责接收，而不能反馈。

- 如果发布端和订阅端需要交互（比如要确认订阅者是否已经连接上），则使用额外的 socket 采用请求回应模型满足这个需求。

### `PUB-SUB`

![alt](https://pic4.zhimg.com/v2-426ca2dfd85c8488ecafa49e7ee6502f_r.jpg)

可按照发布端可发布制定主题的消息，订阅端可订阅喜欢的主题，订阅端只会收到自己已经订阅的主题。发布端发布一条消息，可被多个订阅端同时收到。

- 消息是单向流动的，发布者只能发布消息，不能接受消息；订阅者只能接受消息，不能发送消息。

- 服务端发布消息过程中，如果有订阅者退出，不影响发布者继续发布消息，当订阅者再次连接上来，收到的消息是后来发布的消息。

- 比较晚加入的订阅者，或者中途离开的订阅者，必然会丢掉一部分信息。

- 如果发布者停止，所有`订阅者会阻塞`，等发布者再次上线的时候会继续接受消息。

- 订阅者必须使用 `zmq_setsockopt()` 方法来设置订阅的内容，否则将收不到任何消息。

### 发布者和订阅者消息同步问题

`"慢连接"`：我们不知道订阅者是何时开始接收消息的，就算先启动 “订阅者”，再启动“发布者”，“订阅者” 还是会缺失一部分消息，因为建立连接是需要时间的，虽然很短，但不是零。ZMQ 在后台是进行异步的 IO 传输，在建立 TCP 连接的短短的时间段内，ZMQ 就可以发送很多消息了。

有种简单的方法来同步 “发布者” 和“订阅者”，通过 `sleep` 让发布者延迟发送消息，等连接建立完成后再进行发送。

![alt](https://pic4.zhimg.com/v2-426ca2dfd85c8488ecafa49e7ee6502f_r.jpg)

## 管道模型

这个模型里，管道是单向的，从 PUSH 端单向的向 PULL 端单向的推送数据流。

`server` 为 `REP` 模式，等待消息，`client` 为 `REQ` 模式，向 `server` 请求消息。

### `PUSH-PULL`

![alt](https://pic4.zhimg.com/v2-15a733aed264e56c7e56481f1926aabf_r.jpg)

流水线模式，平行管道，分布式处理；消息单向的，也是有去无回的。push 的任何一个消息，始终只会有一个 pull 端收到消息.

- `ventilator`: 任务发布器会生成大量可以并行运算的任务

- `worker`: 有一组 worker 会处理这些任务

- `sinker`: 结果接收器会在末端接收所有 worker 的处理结果，进行汇总

- `worker`: 上游和 “任务分发器” 相连，下游和 “结果接收器” 相连。 “任务分发器”和 “结果接收器” 是这个网路结构中比较稳定的部分，由他们绑定至端点。`worker` 只是连接两个端点。

- 需要等 worker 全部启动后，再进行任务分发。socket 的连接会消耗一定时间（慢连接），如果不进行同步的话，第一个 worker 启动时会一下子接收很多任务。

- "ventilator 任务分发器" 会向 worker 均匀地分发任务（负载均衡机制）。

- "sinker 结果接收器" 会均匀地从 worker 处收集消息（公平队列机制）。

# 推送和拉取

**推送**

```sh
# 流程：

  生产者把消息直接推给消费者

# 优点：

  可以实现数据实时处理，消息一来，就可以推送给消费者

# 缺点：

  如果三个消费者处理的都是同一个业务，
  如果【平均】推送，由于消费者配置不同，消费能力不一样；
  就会出现有的消费者负载不均的情况，有的很忙，有的很闲
                                                   +----------+
                                                   |          |
                                            +----->+ consumer |
                                            |      |          |
                                            |      +----------+
                                            |
                       +-------------+     PUSH
                       |             |      |
+-----------+          |             |      |      +----------+
|           |          |             |      |      |          |
| producer  +--------->+    M   Q    +-----PUSH----> consumer |
|           |          |             |      |      |          |
+-----------+          |             |      |      +----------+
                       |             |      |
                       +-------------+     PUSH
                                            |
                                            |      +----------+
                                            |      |          |
                                            +------> consumer |
                                                   |          |
                                                   +----------+
```

**拉取**

观察者模式（发布订阅模式）

```sh
# 流程：

  生产者把消息存放到消息队列，然后通知消费者上来取消息（Notify 观察者的角色）。

# 优点：

  消费者可以根据自己处理能力决定什么时候处理消息

# 缺点：
                                                         +----------+
                                                         |          |
                                                  +------> consumer |
                                                  |      |          |
                                                  |      +----------+
                                                  +
                       +-------------------+     PULL
                       |          Notify   |      +
+-----------+          |                   |      |      +----------+
|           |          |                   |      |      |          |
| producer  +--------->+    M   Q          +----+PULL+---> consumer |
|           |          |                   |      |      |          |
+-----------+          |                   |      |      +----------+
                       |                   |      +
                       +-------------------+     PULL
                                                  +
                                                  |      +----------+
                                                  |      |          |
                                                  +------> consumer |
                                                         |          |
                                                         +----------+

```

# 其他
