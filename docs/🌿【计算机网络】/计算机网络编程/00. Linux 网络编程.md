- [参考资料](#参考资料)
- [`Socket` 编程](#socket-编程)
  - [`socket` 结构体](#socket-结构体)
  - [套接字类型](#套接字类型)
  - [套接字选项](#套接字选项)
- [高性能网络](#高性能网络)
  - [多进程/线程模型](#多进程线程模型)
  - [线程池模型](#线程池模型)
  - [IO 多路复用模型](#io-多路复用模型)
  - [事件驱动模型](#事件驱动模型)
    - [`Reactor` 事件驱动模型](#reactor-事件驱动模型)
    - [`Proactor` 模式](#proactor-模式)
- [事件库方案选型](#事件库方案选型)

# 参考资料

- [★ 图解|深入理解 Linux 高性能网络架构的那些事](https://mp.weixin.qq.com/s/5QMfkclFc_UrbLHr1-Fymg)

- [Socket 编程面试题](https://blog.csdn.net/u014800094/article/details/60591852)

- [网络编程重难点解析](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MTkwMTE4Nw==&action=getalbum&album_id=1406695350672523267&scene=173#wechat_redirect)

- [Linux 网络编程视频教程（41 讲）](https://www.bilibili.com/video/BV1eb411F74G)

  - [视频中涉及的源码](https://github.com/834810071/NetworkProgramming)

  - [博客笔记](https://blog.csdn.net/NK_test/category_9264538_2.html)

# `Socket` 编程

## `socket` 结构体

- `IPV4` 地址结构，通过 `man 7 ip` 命令可以看到帮助文档

  ```cpp
  struct sockaddr_in {
      uint8_t sin_len;          /* 该结构体大小 */
      sa_family_t sin_family;   /* 地址族 AF_INET 表示IPV4 */
      in_port_t sin_port;       /* 端口；2字节（16位） */
      struct in_addr sin_addr;  /* IPV4 地址；4字节（32位） */
      char sin_zero[8];         /* 暂时不适用，一般设置为0；8字节 */
  }

  // IPV6 是另外的结构，了解就行了
  struct sockaddr_in6 {
      sa_family_t sin6_family;              /* AF_INET6 */
      in_port_t sin6_port;                  /* transport layer port # */
      uint32_t sin6_flowinfo;               /* IPv6 traffic class & flow info */
      struct in6_addr sin6_addr;            /* IPv6 address */
      uint32_t sin6_scope_id;               /* set of interfaces for a scope */
  };

  struct in_addr {
      uint32_t s_addr;          /* 网络字节序下的地址 */
  }
  ```

- 通用地址结构 `socket` 结构体

  套接字接口不仅可以用于 `TCP/IP` 编程，还可以用于 `UNIX 域协议` 编程；不同协议结构不一样，但 `socket` 结构可以用于任意协议的编程

  ```cpp
  struct sockaddr {
      uint8_t sin_len;          /* 该结构体大小 */
      sa_family_t sin_family;   /* 地址族： AF_INET 表示IPV4 */
      char sa_data[14];         /* 由 sin_family 决定他的形式 */
      // 这里sa_data 有14个字节，上面的 ipv4 结构后面三个字段也是14个字节
  }
  ```

## 套接字类型

> [套接字简介](https://www.cnblogs.com/alantu2018/p/8460269.html)

- `流套接字 SOCK_STREAM（TCP）`

  提供面向连接的，可靠的数据传输服务，数据无差错，无重复发送，且按发送顺序接收

- `数据报套接字 SOCK_DGRAM（UDP）`

  提供无连接服务、不提供差错保证、数据可能丢失或重复，而且接收顺序混乱

- `原始套接字 SOCK_RAW`

  - 可以直接将数据 `绕过 TCP 层直接封装后丢给 IP 层`

  - 流套接字、 数据报套接字`工作在传输层`，主要为应用层的应用程序提供服务，而且也都只操作数据部分，报文头的解析、填充都由系统协议栈来完成

  - 如果要开发更低层的网络应用，如自定义 IP 包、发 ICMP、设置混杂模式、伪装 IP 等等，就要用到原始套接字

## 套接字选项

> [套接字 (Socket) 编程(三) 套接字可选项](https://www.jianshu.com/p/fad573d12e66)

- `REUSERADDR`

  服务端监听 `5000` 端口，刚关闭服务器时，服务器处于 `TIME_WAIT` 状态，此时无法再次绑定 `5000` 端口，即再次启动服务器时，会报错 `"bind: Address already in use"`

- `SO_RCVTIMEO & SO_SNDTIMEO`

  设置套接字读取 / 发送数据的超时时间

- `SO_LINGER`

  `linger`字面意思上来看就是延迟关闭；在调用关闭套接字的情况下，设置了此参数就可以让系统尽量把缓冲区的数据发送出去(因为有超时时间)

# 高性能网络

> - `C10K` 问题： 网络服务在处理数以万计的客户端连接时，往往出现效率底下甚至完全瘫痪
> - 上面讲了那么多 `IO` 模型，都是在讲如何提高请求的接收能力，那么请求的处理呢

- 一个完整的网络请求

  ![一个完整的网络请求](https://pic4.zhimg.com/v2-287185d879a1e7ecd7cd24a30f01803b_r.jpg)

  怎么提高请求的接收能力和处理能力？

## 多进程/线程模型

![alt](https://ask.qcloudimg.com/http-save/yehe-1640143/t5blpjftfi.jpeg)

使用一个线程来监听，当新的客户端发起连接时候，创建一个新的线程来处理；即每个连接都需要创建一个线程来处理；

当客户端数量很多时，服务端线程数过多，即便不压垮服务器，由于 CPU 有限其性能也极其不理想。因此此方案不可用。

## 线程池模型

![alt](https://ask.qcloudimg.com/http-save/yehe-1640143/lvhepyvjs5.jpeg)

相对上一个模型的优化，用线程池避免了频繁创建线程的开销。

- 客户端连接数量不会压垮服务端。

- 服务端处理能力受限于线程池的线程数，而且如果客户端连接中大部分处于空闲状态的话服务端的线程资源被浪费。

## IO 多路复用模型

## 事件驱动模型

> 事件驱动模型是 `一种编程范式，编程思想`，应用比较广泛的有 `libevent`、`libev`、`libuv`
>
> BBC 的 cl_ev 就是封装的 libuv

- 每收到一个请求，加入到事件列表中，让主进程通过非阻塞 I/O 方式来处理请求；写起来复杂

- 包含一个事件循环并且只有 `当外部事件发生时才使用回调机制来触发相应的处理`。也就是说程序运行的整个流程都是取决于用户触发的各种事件来决定的，开发者并不用关心大体流程，而只是需要做好每一个事件对应的处理方式即可

  - 起一个事件循环

  - 触发一个事件

  - 调用该事件的回调函数进行事件处理

### `Reactor` 事件驱动模型

> `Reactor` 反应堆模式，事件驱动；Redis、libevent 都有用到

- 响应快，不必为单个同步事件所阻塞；

- 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程 / 进程的切换开销；

- 可扩展性，可以方便的通过增加 reactor 实例个数来充分利用 CPU 资源；

- 可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性。

### `Proactor` 模式

# 事件库方案选型

- 异步事件库 `libevent、libev、libuv`

  [libevent、libev、libuv、IOCP、asio、muduo 优劣分析](http://qiusuoge.com/16686.html)

  **`libevent`**

  名气最大，应用最广泛，历史悠久的跨平台事件库；

  **`libev`**

  较 libevent 而言，设计更简练，性能更好，但对 Windows 支持不够好；

  **`libuv`**

  node 的开发过程中需要一个跨平台的事件库，他们首选了 libev，但又要支持 Windows，故重新封装了一套，linux 下用 libev 实现

  （公司内部用的 libev 就是基于 libuv 封装的）

- [`SO_REUSEADDR、SO_REUSEPORT` 地址、端口复用](https://blog.csdn.net/ctthuangcheng/article/details/39014675)

  - 两个 tcp 的 socket 不能绑定同一个端口；而如果使用 SO_REUSEADDR 选项，两个 udp 的 socket 可以绑定同一个端口

  - 意思一个服务对外提供一个入口，内部可以开多进程监听处理
