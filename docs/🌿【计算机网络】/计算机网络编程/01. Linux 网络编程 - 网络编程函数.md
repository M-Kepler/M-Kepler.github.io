- [网络编程函数](#网络编程函数)
  - [`socket`](#socket)
  - [大小端字节序](#大小端字节序)
  - [字节序转换函数](#字节序转换函数)
  - [地址转换函数](#地址转换函数)
  - [★ 通信连接过程函数](#-通信连接过程函数)
  - [`connect` 会阻塞多久，怎么解决](#connect-会阻塞多久怎么解决)
  - [★ `connect` 函数 在 TCP 和 UDP 协议中的区别](#-connect-函数-在-tcp-和-udp-协议中的区别)
  - [`send 和 recv` 阻塞和非阻塞模式](#send-和-recv-阻塞和非阻塞模式)
  - [`read` 常见错误码](#read-常见错误码)
  - [为什么 `close(fd)` 会导致接收端读到复位 `RST`](#为什么-closefd-会导致接收端读到复位-rst)
  - [`recv/send` 和 `read/write` 的区别](#recvsend-和-readwrite-的区别)
  - [`ftp` 协议粘包问题解决方式](#ftp-协议粘包问题解决方式)
  - [`getsockname` 和 `getpeername` 的区别](#getsockname-和-getpeername-的区别)
  - [★ `close` 与 `shutdown` 的区别](#-close-与-shutdown-的区别)
- [其他](#其他)
- [参考资料](#参考资料)

# 网络编程函数

## `socket`

```cpp
#include <sys/types.h>
#include <sys/socket.h>

/**
 * socket 函数原型
 *
 * @param 域: AF_INET IPV4
 *            AF_LOCAL 表示的是本地地址，对应的是 Unix 套接字，一般用于本地 socket 通信
 *            很多情况下也可以写成 AF_UNIX 或 AF_FILE
 * @param 类型: SOCK_STREAM、SOCK_DGRAM、SOCK_RAW
 * @param 协议
 * @return 文件描述符
 */
int socket (int domain, int type, int protocol);
```

## 大小端字节序

由于通信双方都不知道对方的字节序，所以凡是发送整数，都要先用 `htonl` 统一成网络字节序

```
0x12345678
[低地址]----------------------> [高地址] 内存地址增长方向
[12][34][56][78]               大端字节序（复合我们的认知）
[78][56][34][12]               小端字节序
```

- **大端字节序**

  这里的位可以认为是个十百千万的那个位

  `高位`字节排放在内存的`低地址`端，`低位`字节排放在内存的`高地址`端

- **小端字节序**

  `低位`字节排放在内存的`低地址`端，`高位`字节排放在内存的`高地址`端

- **为什么要引入字节序**

  因为 `socket` 支持`异构系统之间的通讯`，即不管是什么系统，只要你支持 `TCP/IP`，那我们就可以通信；但是不同的字节序是不一样的，会导致读取到的数据是不一样的

- **主机字节序**

  不同主机有不同的字节序，比如 `x86` 的就是小端字节序；而 `arm` 的字节序是可配置的

- **网络字节序**

  统一标准把网络字节序规定为 `大端字节序`

## 字节序转换函数

```cpp
#include <arpa/inet.h>

/*
 * h 表示 host
 * n 表示 network
 * s 表示 short 16 位短整数
 * l 表示 long 32 位长整数
 */
// 将4字节整数 hostlong 由主机字节序转换成网络字节序
uint32_t htonl(uint32_t hostlong);

// 将2字节整数 hostshort 由网络字节序转换成主机字节序
uint16_t htons(uint16_t hostshort);

uint32_t ntohl(uint32_t netlong);

uint16_t ntohs(uint16_t netshort);
```

## 地址转换函数

[Linux Socket 学习 - 地址转换函数](https://www.cnblogs.com/rollenholt/archive/2012/08/16/2642366.html)

从上面 `socket` 结构体可以知道，`IP` 地址存放在 `32` 位字节中，可是单从 32 位字节，也看不出具体地址是多少，还是点分十进制容易看懂

```cpp
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>

// 将点分十进制地址转换成地址结构
int inet_aton(const char *cp, struct in_addr *inp);

// 将点分十进制地址转换成32位整数（网络字节序）
// 如 "192.168.10.2" ====> 3232238082
in_addr_t inet_addr(const char *cp);

// 将一个地址结构转换成点分十进制
char *inet_ntoa(strut in_addr in);

// 把点分十进制的 IP 地址，转化成主机字节序的 32 位二进制地址
in_addr_t inet_network(const char *cp);

// 把 IP 地址转换为没有网络位的主机位
in_addr_t inet_lnaof(struct in_addr in);

// 把 IP 地址转换为没有网络位的网络位
in_addr_t inet_netof(struct in_addr in);

// 把网络位和主机位合并成要一个 IP 地址
struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host);

```

## ★ 通信连接过程函数

**`TCP` 通信过程：**

![alt](https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwooE10RtLDCLnrlFpxvicW0Uehl4yUU3o99cdjAn2s1UKSY2mmbNC2s9lrFKfcITiaR7hZRhpS7dSOg/640?wx_fmt=png)

![alt](https://pic3.zhimg.com/100/v2-6259279b77ab619f4e39c6507cbb553a_r.jpeg)

**`UDP` 通信过程：**

![alt](https://pic4.zhimg.com/v2-f5bed064fe1f83fded4799e2cb72c083_r.jpg)

## `connect` 会阻塞多久，怎么解决

[从内核角度看怎么设置 connect 超时](https://jishuin.proginn.com/p/763bfbd52bad)

- 调用 `connect` 函数，如果服务端已关闭，则客户端会一直阻塞在 `connect` 那里，默认超时时间为 `75秒`

- 虽然 `SO_RCVTIMEO` 与 `SO_SNDTIMEO` 明确提到`只能用于读写操作`；但是实际上是可以达到设置 `connect` 超时的目的的

- 采用`信号处理`函数设置阻塞超时控制，推荐单进程模型使用, 因为多进程处理信号比较麻烦

- 把套接字`设置成非阻塞模式`

## ★ `connect` 函数 在 TCP 和 UDP 协议中的区别

> [TCP、UDP connect 函数的区别](https://blog.csdn.net/renlonggg/article/details/79758369)

- **TCP 发起三次握手；UDP 记录对端 IP 端口**

  - TCP 中调用 connect 会引起三次握手, client 与 server 建立连接

  - UDP 中调用 `connect 仅仅把对端 ip 和 port 记录下来`

- **UDP 中可以多次调用 connect；TCP 只能调用一次 connect**

  - UDP 多次调用 connect 可用于 `指定一个新的 ip&port 连接`、`断开和之前的 ip&port 的连接`

  - 指定新连接, 直接设置 connect 第二个参数即可.

  - 断开连接, 需要将 connect 第二个参数中的 sin_family 设置成 AF_UNSPEC 即可.

- **UDP 中使用 connect 可以提高效率**

  - 普通的 UDP 发送两个报文内核做了如下:#1: 建立连结 #2: 发送报文 #3: 断开连结 #4: 建立连结 #5: 发送报文 #6: 断开连结

  - 采用 connect 方式的 UDP 发送两个报文内核如下处理:#1: 建立连结 #2: 发送报文 #3: 发送报文另外一点, 每次发送报文内核都由可能要做路由查询.

  - 采用 connect 的 UDP 发送接受报文可以调用 send,write 和 recv,read 操作. 当然也可以调用 sendto,recvfrom.

  - 调用 sendto 的时候第五个参数必须是 NULL, 第六个参数是 0. 调用 recvfrom,recv,read 系统调用只能获取到先前 connect 的 ip&port 发送的报文

## `send 和 recv` 阻塞和非阻塞模式

`socket` 默认是阻塞的， `fcntl()` 函数或 `send`、`read` 最后一个参数可以设置为非阻塞模式

- 阻塞与非阻塞返回值没有区分，都是 `< 0 出错；= 0 对方连接关闭；> 0 数据大小`

- `send/recv` 只是把应用层的数据拷贝到内核发送缓冲区，真正执行发送以及什么时候发送是由系统（协议栈）决定的，所以函数返回成功，只能说明拷贝成功了，如果在还未发送之前网络断开，则发送失败

- **`send / sendto`**

  阻塞非阻塞就是当 `缓冲区大小 buff < 要发送大小 len` 时是否等待；就是说你要发送的大小我还装不下，等前面的发了才轮到你

  - `buff < len` 时阻塞

    直到发送缓冲区里的数据被发送出去，可用缓冲区大小比要发送的数据长度大时，`send` 返回成功

  - `buff = 0`不会阻塞

    则立即返回 `EWOULDBLOCK` 错误，表示无法拷贝任何数据到发送缓冲区

  - `buff ∈ (0, len)`不会阻塞

    发送缓冲区有数据但是还未发送，则拷贝尽可能多的数据到缓冲区，所以存在非阻塞 send 返回的大小比发送数据的长度要小的情况，此时要轮询，直到要发送的大小等于已发送大小

- **`recv / recvfrom`**

  从接收缓冲区拷贝数据。成功时，返回拷贝的字节数，失败返回 `-1`

  - 阻塞模式下

    `recv会一直阻塞直到缓冲区至少有一个字节（TCP) / 至少有一个完整的数据包(UDP) 才返回`

  - 非阻塞模式下

    如果没有数据就会返回，不会阻塞，有数据返回大小，无数据则置错误码 `erno` 为`EWOULDBLOCK` 因此需要循环读取

- 返回值的意义

  阻塞与非阻塞 `recv` 返回值没有区别

  - `> 0`

    - 表示成功发送 n 个字节, 如果 n 不等于 buff 的长度, 则不能表示发送完毕

    - 实际情形下，由于对端的 TCP 窗口可能因为缺少一部分字节就满了，所以返回值 n 的值可能在 (0, buf_len] 之间, 所以要把剩下的(buf_len,n]继续发

  - `= 0`

    - 对方如果 send 或者 recv 函数返回 0，我们就认为对端关闭了连接，我们这端也关闭连接即可

    - 但是，现在还有一种情形就是，假设调用 send 函数传递的数据长度就是 0 的时候

    - send 发送 0 字节数据，client 的协议栈并不会把这些数据发出去, server 端由于没有数据会一直阻塞在 recv 函数调用处

  - `< 0`

    调用出错, 并设置错误码

    ```cpp
    if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR))
    {
        // 这几种错误码，认为连接是正常的，可以忽略继续接收
    }
    ```

## `read` 常见错误码

[Linux 网络编程中 socket 常见错误分析](https://zhuanlan.zhihu.com/p/333640971)

- `EINTR`

  中断错误，阻塞操作被取消阻塞的调用打断；被中断，可以继续读取

- `EWOULDBLOCK`

  资源暂时不可用,表示无法拷贝数据到缓冲区；表示当前 socket_fd 文件描述符是非阻塞的，但是现在被阻塞了

- `EAGAIN (Resource temporarily unavailable)`

  表示现在没有数据稍后重新读取

  - `send` 返回值小于要发送的数据数目

  - `recv` 返回值小于请求的长度时说明缓冲区已经没有可读数据

  - `socket` 是非阻塞时，如返回此错误，表示写缓冲队列已满,可以做延时后再重试

- `EPIPE`

  对端 `socket` 关闭

- `SIGPIPE`

  在网络编程中这个信号发生在如果客户端已经关闭了套接字, 而服务器调用了一次 `write`，服务器就会收到一个 `RST segment`，如果服务器再次调用 `write`，这个时候就会产生 `SIGPIPE` 信号，系统默认的处理方式是杀掉这个进程

- `ECONNRESET`

  - 接收端 `recv` 或者 `read`， 对端已经关闭连接，`recv/read` 返回该错误

  - 对端重启连接，还未建立连接，会触发这个错误

  - 发送端已经断开连接，但是调用 `send` 会触发这个错误

## 为什么 `close(fd)` 会导致接收端读到复位 `RST`

[关闭 Socket 的正确方式及 ECONNRESET，WSAECONNRESET 产生的原因](https://blog.csdn.net/qwq1503/article/details/79406192)

- 因为 close(fd) 只是将文件描述符关闭，并没有关闭 tcp 建立起来的连接，断开连接需要四次握手，

- 倘若发送端发送缓冲区有数据未发送完或者接受缓冲区有数据未读完，调用 close(fd)，那么连接并没有关闭，这样，接收端收到的就是所谓的 104 或 10054 错误了

- 判断发送端发送和接受操作是否进行完，也就是判断缓冲区是否有数据，如果有数据需要等待数据处理完毕在关闭，否则会出现上述错误

## `recv/send` 和 `read/write` 的区别

[`send/recv 和 write/read` 的区别](https://blog.csdn.net/petershina/article/details/7946615)

- **`recv / send`**

  ```cpp
  #include <sys/types.h>
  #include <sys/socket.h>
  /*
   * @brief
   * @param sockfd 套接字
   * @param buf 接收数据缓冲区
   * @param len 接收数据的长度
   * @param flags 标志位，默认为0
   */
  ssize_t recv(int sockfd, void *buf,  size_t len, int flags)

  #include <unistd.h>
  ssize_t read(int fd, void *buf, size_t count);
  ```

- 功能上，`read/write` 是 `recv/send` 的子集

- `read/wirte` 是更通用的文件描述符操作，而 `recv/send` 在 `socket` 领域则更"专业"一些，多一个参数用来进行 `socket` 控制

- `recv` 和 `read` 函数功能一样，都可以从文件描述符的缓冲区中获取指定长度的数据到 `buff`

- `recv` 只能用于套接字 IO，而 `read` 可以用于任何 IO

- `recv` 增加了 `flags` 参数，支持更多的选项

  - 比如 `MSG_OOB` 选项，支持接收带外数据，即报文中设置了紧急指针发过来的数据

  - 比如 `MSG_PEEK` 选项，从缓冲区读数据，但是并不把数据从缓冲区中清除，可以用来窥探缓冲区的数据

## `ftp` 协议粘包问题解决方式

- 自定义 `readline` 函数解决粘包问题，比如 `ftp` 就是按照 `\r\n` 来表示消息之间的边界

  - **方案一: 逐字符读取**

    从缓存区中读取数据，如果一个字节一个字节读取判断是否有 `\r\n` 标记，但是这样会频繁进行系统调用去读取，效率很低

  - **方案二: 偷窥字符**

    ```cpp
    // 就是上面说到的 `MSG_PEEK` 选项
    int ret = recv(sockfd, buf, len, MSG_PEEK);
    ```

  - **方案三: 使用静态变量**

    就像 `strtok` 一样，先把从缓存中读取到的数据保存到静态变量中，然后循环读取静态变量的数据，判断是否有 `\r\n` 标记位，如果没有标记位才像系统提交 `recv` 进行接收数据；但是用到了静态变量，意味着这个函数不可重用的。

## `getsockname` 和 `getpeername` 的区别

[`getsockname / getpeername`](https://www.cnblogs.com/zl-graduate/p/5934192.html)

- 函数原型

  ```cpp
  #include <sys/socket.h>

  /*
   * 获取套接字所关联的对端的地址
   * @param sockfd 已连接的套接字，所以可以知道本端和对端的地址和端口
   */
  int getsockname(int sockfd, struct sockaddr* localaddr, socklen_t *addrlen);

  /*
   * 获取套接字本地端口
   * @param sockfd 已连接的套接字，所以看可以知道本端和对端的地址和端口
   */
  int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t *addrlen);
  ```

- `gethostname / gethostbyname`

  - `gethostname` 进行域名与 IP 的转换

  - `gethostbyname / gethostbyaddr` 通过主机名获取主机上所有的 `IP` 地址

## ★ `close` 与 `shutdown` 的区别

[`close` 与 `shutdown` 的区别](https://blog.csdn.net/weixin_42634329/article/details/81147784)

- **`close` 表示终止数据传送的 `读和写两个方向`**

  - 如果主动方调用了 `close`，那么就无法再通过这个套接字`发送`数据给对端

  - 也无法再通过该套接字`接收`对端发送过来的数据了，（但是对端仍可以通过套接字发送数据过来，只不过会收到 `FIN`报文，如果继续发，就会收到 `SIGPIPE` 信号）

  - 只有当 `close` 的引用计数为 `0` 的时候才会发送 `FIN` 段

  - 如果主动关闭方，发往最后 ABC 报文后，调用 `close` 关闭套接字，（报文发送顺序是：`[FIN, C, B, A]`)，那么就`会把套接字的读写两端都关闭`，就是说没办法知道对端对这些报文的响应了（如果业务需要知道对端的响应的话）；比如我希望的是关闭写这一端，那么被动关闭方发报文过来，还是可以通过该套接字读取到内容

- **`shutdown` 可以选择关闭读或关闭写 `任一方向`**

  ```cpp
  int shutdown(int sockfd, int how);
  ```

  只要`how>=1` 就可以保证对等放接收到一个 `EOF` 字符（即肯定会向对方发送了个 `FIN` tcp 段），而不管`其他进程`是否已经打开了套接字；而 `close` 则不能保证，要直到套接字`引用计数减少为零的时候才发送，也就是说所有的进程都关闭了套接字才行`

  ```cpp
  how 可选以下枚举值
  SHUT_RD = 0,    /* 关闭读方向 */
  SHUT_WR,    /* 关闭写方向 */
  SHUT_RDWR  /* 读写都关闭 */
  ```

# 其他

# 参考资料
