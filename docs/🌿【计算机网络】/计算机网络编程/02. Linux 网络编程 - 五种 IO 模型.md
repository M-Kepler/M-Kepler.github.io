- [五种 `IO` 模型](#五种-io-模型)
  - [同步阻塞式 `IO` - 死等](#同步阻塞式-io---死等)
  - [同步非阻塞式 `IO` - 轮询、忙等](#同步非阻塞式-io---轮询忙等)
  - [`IO` 多路复用 - 让别人等](#io-多路复用---让别人等)
  - [信号驱动 `IO`](#信号驱动-io)
  - [异步 `IO`](#异步-io)
- [其他](#其他)
- [参考资料](#参考资料)

# 五种 `IO` 模型

[`I/O` 模型](https://blog.csdn.net/baixiaoshi/article/details/48708347)

- 一次 `I/O` 操作包括两个步骤

  - **准备数据**

    硬件网卡到内核态: 从硬件网卡`接收`客户端发过来的数据到内核空间

  - **拷贝数据**

    内核态到用户态: 把数据从内核空间`拷贝`到用户空间

- [`UNIX` 下五种 `I/O` 模型](https://www.cnblogs.com/pandang/p/7366781.html)

  前三种都是同步 `IO`。异步必定是非阻塞的，所以不存在异步阻塞、异步非阻塞之分

  - 阻塞式 `I/O`

  - 非阻塞式 `I/O`

  - `I/O` 多路复用（select 、poll、epoll）

  - 信号驱动式 `I/O`（SIGIO）

  - 异步 `I/O`（AIO）

## 同步阻塞式 `IO` - 死等

`BIO` 应用进程被阻塞，直到所有数据到达，并成功从内核复制到应用进程才返回。

![alt](https://img2018.cnblogs.com/blog/1448094/201809/1448094-20180928214400806-1441362586.png)

- 用户程序调用 `recvfrom` 或 `recv` 来接受数据

- 进程阻塞，直到内核接收到客户端发送的数据，并填充到用户空间的接收缓冲区后才返回，否则就一直等待

- 图中有两处地方在耗时，一处是内核一直在等待数据，一处是内核接收到数据后把数据从内核拷贝到用户空间

- 通俗解释

  ```sh
  # 【死等】
  我提这个水壶去热水房打水

  热水房大叔说还没有热水，然后我就在那里等

  等了好久之后终于有水了

  于是大叔打开水龙头，滴答滴答帮我装水

  打满水后我就带着水壶回去了
  ```

## 同步非阻塞式 `IO` - 轮询、忙等

`NIO` 应用进程执行系统调用之后，内核返回一个 `错误码`。应用进程可以继续执行，但是 `需要不断的执行系统调用(轮询)来获知 I/O 是否完成`

![alt](https://img2018.cnblogs.com/blog/1448094/201809/1448094-20180928215718651-2053341946.png)

- `recv` 即使没有获取到数据，也不会阻塞，而是得到内核返回的一个错误 `EWOULDBLOCK`

- 如果想获取到数据，就需要时不时地去 `轮询`，所以还是一直占用 `CPU` 的（`忙等待`）

  ```cpp
  int socketfd = socket(AF_INET, SOCK_STREAM, 0);

  // 把套接字设置成非阻塞模式
  int flag = fcntl(socketfd, F_GETFL);
  fcntl(socketfd, F_SETFL, falg|O_NONBLOCK);
  while (1)
  {
      data = socket_fd.read()
      // 还不如阻塞IO，这里循环调用增加了系统调用开销
      if (data != error)
      {
          // do_something...
          break;
      }
  }
  ```

- 通俗理解

  ```sh
  # 【忙等、轮询】
  我提这个水壶去热水房打水，
  热水房大叔说还没有热水，然后我就先回去了
  等了一下子，我又过去问下大叔有热水了没有，
  大叔说还没有，那我也没办法，只能先回去了
  又等了一下子，我又又过去问大叔...；
  过了很久，终于有水了，接完水就回去了

  # 我这样子跑来跑去看着挺忙的，但其实并没有什么进展
  # 还是一直死等这壶水打上了才考虑干别的事
  # 不仅没啥帮助，还频繁跑来跑去浪费精力
  ```

## `IO` 多路复用 - 让别人等

![alt](https://img2018.cnblogs.com/blog/1448094/201809/1448094-20180928220101298-847700644.jpg)

**`复用了什么`**

IO 多路复用，`【复用的是系统调用】`。通过有限次系统调用判断海量连接是否数据准备好了

- 如果没有多路复用，每处理一个请求，就要独占一个连接，就需要频繁进行 IO 操作

- 多路复用的优势就是可以同时处理多个请求的 IO 操作

- 多路复用主要复用的是`通过有限次的系统调用来实现管理多个网络连接`

  最简单来说，我目前有 10 个连接，我可以通过一次系统调用将这 10 个连接都丢给内核，让内核告诉我，哪些连接上面数据准备好了，然后我再去读取每个就绪的连接上的数据。

**单路存在的问题**

- `每个请求响应独占一个连接，【且独占连接网络读写】；导致连接在有大量时间被闲置无法更好地利用网络资源`

- 由于是独占读写 IO，这样导致 RPS 处理量由必须由 IO 承担, IO 操作起来比较损耗性能，这样在高 RPS 处理就出现性能问题，由于不能有效的合并 IO 也会导致在通讯中的带宽存在浪费情况，特别对于比较小的请求数据包。通讯上的延时当要持大量的 RPS 那就必须要有更多连接支撑，连接数增加也对资源的开销有所增加

**多路复用的优点**

- `在一个连接上同时处理多个请求响应，这样可以大大的减少连接的数量，并提高了网络的处理能力`

- 由于是共享连接不同请求响应数据包可以`合并到一个 IO 上处理`，这样可以大大降低 IO 的处理量，让性能表现得更出色

- `select` 同时**管理多个文件描述符**，一旦有一个文件描述符检测到数据到来就返回，既然已经**探测**到有数据了，这时候再调用 `recv` 肯定就不会再阻塞了

- IO 复用的函数 **也会使进程阻塞**，即 `select` 函数是阻塞的，但是和阻塞 `I/O` 所不同的的，这两个函数 `可以管理同时阻塞多个I/O操作`。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数

- 用户首先将需要进行 IO 操作的 socket 添加到 select 中，然后循环调用 select（`会阻塞直到 select 系统调用返回`）。当数据到达时，socket 被激活，select 函数返回。用户线程正式发起 read 请求，读取数据并继续执行

- 有新的客户端要连接进来全部丢给 `select`，把所有等待 IO 的套接字接管起来；然后去遍历每个套接字，看是否数据准备完成

- 通俗理解

  ```sh
  # 【让别人等】
  我提这个水壶去热水房打水，热水房大叔说还没有热水，那我也不能干等着啊，
  还有那么多水壶要让我打呢，可是我又不能离开，离开了就不能及时打水回去了。

  于是我雇佣了A，让A在这里等着，我则去把要打水的水壶一个个搬过去，
  反正有A帮看着如果有某个水壶打满水了我就提走；对于A来说他就啥事没干也是在干等着了，
  相对来说两个人比一个人效率要高； A也不知道谁更需要水，只能先把水壶按先后顺序排好，
  然后一个个检查，看他们的水龙头是否有水了
  ```

## 信号驱动 `IO`

![alt](https://img2018.cnblogs.com/blog/1448094/201810/1448094-20181001132423114-1632476327.png)

- `信号个数有限，多个描述符时不适用`，不过由于设置了信号，可以免去了 `select` 的阻塞和轮询，有数据到来的时候就以信号通知的方式通知

- 应用进程使用 `sigaction` 系统调用，内核立即返回，应用进程可以继续执行，在等待数据阶段应用进程是 `非阻塞` 的。内核在数据到达时向应用进程发送 `SIGIO` 信号，应用进程收到之后在信号处理程序中调用 `recvfrom`（这个函数还是阻塞的） 将数据从内核复制到应用进程中

- 不明白为什么用信号可以不阻塞，而且可以及时通知进程处理的，先去了解下信号是如何传递给进程的

## 异步 `IO`

> `AIO`

![alt](https://img2018.cnblogs.com/blog/1448094/201810/1448094-20181001132649584-1282520774.png)

- 应用进程执行 `aio_read` 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会`在所有操作完成之后向应用进程发送信号`。

- 信号驱动 IO 和 异步 IO 的区别

  - `信号驱动 IO` 的信号是数据接收完了，通知应用进程`可以开始 IO` 了

  - `异步 IO` 的信号是通知应用进程 IO 完成了

# 其他

- 说了那么多，多路复用也只解决了 `I/O` 的问题，`I/O`之后的处理还是要用户自己去处理；比如你想提高系统的并发能力，一部分是提高 IO 性能，再一部分是 IO 之后的处理能力

- 如何解决异步消息通知？

  - 最原始的，就是不断去轮询检查是否就绪；

  - `发布订阅模式` 就可以解决需要轮询才知道有消息来了；

  - `回调` 也是一种方式

# 参考资料

- [linux 五种 IO 模型与事件驱动模型](https://www.cnblogs.com/Yunya-Cnblogs/p/13246517.html)

- [五种 IO 模型](https://www.cnblogs.com/rexcheny/p/9721246.html)

- [Linux IO 模式及 `select、poll、epoll` 详解](https://zhuanlan.zhihu.com/p/156521560)

- [★ 网络 IO 演变发展过程和模型介绍](https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ)
