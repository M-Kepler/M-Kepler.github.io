- [参考资料](#参考资料)
- [`select、poll、epoll`](#selectpollepoll)
  - [多进程 / 多线程模型](#多进程--多线程模型)
  - [`select`](#select)
    - [`select` 工作原理](#select-工作原理)
    - [`select` 函数原型](#select-函数原型)
    - [`select` 读写异常事件发生条件](#select-读写异常事件发生条件)
    - [`select` 检测到可读时调用 read 的情况](#select-检测到可读时调用-read-的情况)
    - [`select` 如何实现超时](#select-如何实现超时)
    - [`select` 的三个缺点](#select-的三个缺点)
    - [`select` 的优点](#select-的优点)
  - [`poll`](#poll)
    - [`poll` 工作原理](#poll-工作原理)
    - [函数原型](#函数原型)
    - [`select 和 poll` 的区别](#select-和-poll-的区别)
    - [`poll` 缺点](#poll-缺点)
  - [`epoll`](#epoll)
    - [函数原型](#函数原型-1)
    - [`epoll` 工作原理](#epoll-工作原理)
    - [`epoll` 水平触发模式 LT 和 边缘触发模式 ET](#epoll-水平触发模式-lt-和-边缘触发模式-et)
    - [`epoll` 水平触发和边缘触发的区别](#epoll-水平触发和边缘触发的区别)
    - [★ `select 和 epoll` 的区别](#-select-和-epoll-的区别)
      - [`epoll` 怎么解决套接字集合整体 `反复拷贝` 的问题](#epoll-怎么解决套接字集合整体-反复拷贝-的问题)
      - [`epoll` 怎么解决套接字 `轮询` 的问题](#epoll-怎么解决套接字-轮询-的问题)
      - [`epoll` 怎么解决套接字 `容量` 的问题](#epoll-怎么解决套接字-容量-的问题)
    - [LT 触发模式下，当 socket 可写时，会不停的触发 socket 可写的事件，如何处理](#lt-触发模式下当-socket-可写时会不停的触发-socket-可写的事件如何处理)
- [其他](#其他)

# 参考资料

- [★ Linux IO 模式及 select、poll、epoll 详解](https://segmentfault.com/a/1190000003063859)

- [你管这破玩意叫 IO 多路复用?](https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw)

- [Linux IO 复用区别与 epoll 详解](https://blog.csdn.net/hacker00011000/article/details/52160590)

- [Epoll 原理解析](https://blog.csdn.net/armlinuxww/article/details/92803381)

- [深入揭秘 epoll 是如何实现 IO 多路复用的](https://mp.weixin.qq.com/s/9vVs2olnfoVEpoJCFWUmMQ)

# `select、poll、epoll`

当需要读两个以上的 `I/O` 的时候（`比如socket编程中有多个客户端连接进来`），如果使用阻塞式的 `IO`，那么可能长时间的阻塞在一个描述符上面，其他的描述符虽然有数据但是不能读出来，这样实时性不能满足要求。

[select、poll、epoll 之间的区别总结](https://www.cnblogs.com/weizhixiang/p/6306600.html)

![select、poll、epoll的区别](https://img-blog.csdnimg.cn/20190111184024145.png)

## 多进程 / 多线程模型

> 可以认为是非阻塞 IO 的处理方式

在引入 IO 多路复用之前，我们可以使用多进程模型、多线程模型来提供服务的并发量，即`来一个请求就创建一个进程/线程去处理（当然可以池化）`，这样就不会导致程序阻塞而无法接受新的情求

![alt](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zA55fIbicSuYiad7vYdyLD0usibPibYiaAjBDR0gQPzArnzYlWXOZRyQzub3Q/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1.gif)

## `select`

### `select` 工作原理

为每个客户端创建一个线程，服务器端的线程资源很容易被耗光；最好就是把这些需要等待的描述符放到一个数组里，然后用一个线程/进程去遍历它，这样就不用频繁创建线程/进程，也可以同时接受多个请求了

- 用 `select` 来管理多个 `I/O`，一旦其中 `一个或多个I/O` 检测到我们所关注的套接字变为可读，`select` 函数就返回

- 返回值为检测到的 `事件个数`，并且返回哪些 `I/O` 发生了事件，遍历这些事件来进行处理

### `select` 函数原型

```cpp
#include <select.h>

/**
 * select 阻塞地接受请求，如果有一个文件描述符准备就绪就返回可读文件描述符个数
 *
 * 进入 select 的时候，会把文件描述符集合从用户空间拷贝到内核空间
 * 之后需要遍历整个集合，找出哪些文件描述已就绪
 *
 * @param: int 读、写、异常集合中的文件描述符最大值 + 1
           加一是因为遍历的时候是从0开始的，是个左闭右开区间 [begin, end)
           所以 nfds 为最大描述符（注意，描述符不是个数） + 1
 * @param: fd_set* 需要关注某个IO的 可读 事件，就放到这个读IO集合
 * @param: fd_set* 需要关注某个IO的 可写 事件，就放到这个写IO集合
 * @param: fd_set* 需要关注某个IO的 异常 事件，就放到这个异常IO集合
 * @param: struct timeval 超时结构体，如果到了超时时间还没有准备好的IO，则返回0
 * @return: 事件就绪的个数
 */
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *excepfds, struct timeval *timeout);
```

**套接字集合操作**

```cpp
// 实际上每个操作都是做移位操作

// 【step0】: 先清空套接字集合
// fd_set & = 0
void FD_ZERO(fd_set *set);

// 【step1】: 将文件描述符添加到集合中
// fd_set = fd_set | (1 << fd)
void FD_SET(int fd, fd_set *set);

// 【step2】: 检测到套接字事件后，会把文件描述符从内核空间拷贝到用户空间
// nready = select(maxfd + 1, &read_set, NULL, NULL, NULL);
// > 0 表示IO准备就绪了，可以开始处理业务了

// 把文件描述符从集合中移除
// fd_set = fd_set & ~(1 << fd
void FD_CLR(int fd, fd_set *set);

// 【step3】: 判断文件描述符是否在集合中存在，如果存在则证明可以进行读/写操作了
// return (fd_set >> fd & 1)
void FD_ISSET(int fd, fd_set *set)
// if (FD_ISSET(sock_fd, &read_set))，读写就绪后，根据套接字类型判断是否是自己的套接字准备好了

/**
 *  FD_SETSIZE 读/写集合可以监听的最大套接字数量 1024
 * 实际上 socket 编程最多能打开的是 1021 个，
 * 还有三个文件描述符 0、1、2 表示标准输入、标准输出、标准错误
 */
```

### `select` 读写异常事件发生条件

**`可读`**

- 套接口缓冲区有数据可读，即对方发送数据过来，填充了本地的套接口缓冲区

- 连接的`读一半`关闭，即收到了 `FIN` 段（即对端调用了 `close`），读操作会返回 `0`

- 如果是监听套接口，已完成队列不为空（即对端完成调用 `accept` ）

- 监听口上发生了一个错误待处理，可以通过 `getsockopt` 指定 `SO_ERROR` 选项来获取

**`可写`**

- 套接字发送缓冲区有空间容纳数据，（即缓冲区未满，可以把数据放到缓冲区的时候）因为缓冲区大部分时间都不会满的，所以写事件是经常会发生的

- 连接的`写一半`关闭，即收到 `RST` 段（即对端关闭了套接字，且进程已经销毁，虽然对端不会再发数据过来了，但本端仍可向套接字写数据的，此时再往套接字调用 `write` 写数据，内核就会返回个 `SIGPIPE` 信号，告诉对端已经关闭了，这个信号默认操作就是退出进程）

- 监听口上发生了一个错误待处理，可以通过 `getsockopt` 指定 `SO_ERROR` 选项来获取

**`异常`**

- 套接口存在 `带外数据`

### `select` 检测到可读时调用 read 的情况

`select` 返回值的情况

- 当是接收缓冲区的数据大于阈值时，返回`实际读出的字节数`

- 收到 `FIN` 关闭连接时，返回 `0`

- 收到 `RST` 重置报文时，返回 `-1`

### `select` 如何实现超时

> 套接字 `I/O` 超时设置的方法

- 借助信号来实现，但是 `SIGALRM` 可能用来做别的用途，大家都用这个信号容易冲突

  ```cpp
  // 伪代码
  void alarm_handler(int signal)
  {
      return;
  }

  void test()
  {
      // 定义信号处理函数
      signal(SIGALRM, alarm_handler);

      // 设置闹钟时间为5秒，5秒后执行handler函数
      alarm(5);

      int ret = read(fd, buf, sizeof(buf));
      if (ret == -1 && errno == EINTR)
      {
          errno = ETIMEDOUT
      }
      else if (ret >= 0)
      {
          // 立即执行 handler 函数
          alarm(0);
      }
  }
  ```

- 套接字选项 `SO_SNDTIMEO`、`SO_RCVTIMEO`，但是有些不支持这两个套接字选项

  ```cpp
  // 设置套接字选项，超时时间为 5 秒钟
  setsocketopt(socket, SOL_SOCKET, SO_RECVTIMEO, 5);

  int ret = read(fd, buf, sizeof(buf));
  if (ret == -1 && errno = EWOULDBLOCK)
  {
      // 如果超时时间到了，ret 返回值是 -1，且 errno 为 EWOULDBLOCK 则判定为超时
      ...
  }
  ```

- `select` 根据 `read` 的返回值和错误码来判断套接字是超时还是正常

  ```cpp
  int ret = read_timeout(fd, 5);

  if (ret == 0)
  {
      read(fd, ...);
  }
  else if (ret == -1 &*& errno == ETIMEDOUT)
  {
      do_timeout();
  }
  else:
  {
      ERR_EXIT("read_timeout");
  }
  ```

### `select` 的三个缺点

> - `1. 句柄数限制`
> - `2. FD 增长导致效率底下`
> - `3. 套接字需要在内核与用户空间之间频繁拷贝`
> - 而且是并发处理的，不是并行，如果某个 IO 处理时间太久，会导致其他 IO 也无法进行，所以多核 CPU 只有开进程/线程，每个进程都 select 才能发挥出最大的作用

![alt](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

**可以监听的套接字数量进程可打开的最大文件描述符限制**

`select` 中的 **`fd_set` 集合容量的限制 `FD_SETSIZE`**，这个也是在内核指定的，虽然这个可以通过修改内核参数来调整

```sh
# 最大支持 1024 个套接字
ulimit -n
```

**通过遍历确认有响应的文件描述符效率不高，时间复杂度要 O(n)**

- `select 仅返回可读【文件描述符的个数】`，具体哪个可读还是要用户自己遍历。

- 在内核层仍然是通过`遍历的方式检查文件描述符的就绪状态`，是个同步过程，只不过无系统调用切换上下文的开销。

**套接字集合需要反复在用户态和内核态之间拷贝**

- `select` 调用的时候要把套接字集合从用户空间拷贝到内核空间，套接字准备好后，又要把套接字从内核空间拷贝到用户空间，**文件描述符集合内核态到用户态的拷贝消耗大**

- `select` 调用需要传入文件描述符数组，`需要拷贝一份到内核`；有文件描述符准备就绪后，又要从内核空间拷贝到用户空间

- 每次都需要把文件描述符数组从用户空间拷贝的内核空间

### `select` 的优点

- 跨平台

## `poll`

### `poll` 工作原理

`poll` 和 `select` 的主要区别就是，`poll 采用链表`解决了 `select` 只能监听 `1024` 个文件描述符的限制，其他都一样

### 函数原型

```cpp
#include <poll.h>

struct pollfd
{
    // 文件描述符
    int fd;

    /**
     * 等待的事件
     * POLLIN       有数据来，文件描述符可读
     * POLLPRI      有经济数据可读（例如带外数据）
     * POLLOUT      文件描述符可写
     * POLLRDHUP    流式套接字半关闭
     * POLLERR      错误发生
     * POLLHUP      关闭
     * POLLNVAL     非法请求
     * POLLRDNORM   与 POLLIN 相同
     * POLLRDBAND   优先数据可读
     * POLLWRNORM   与 POLLOUT 相同
     * POLLWRBAND   优先数据可写
     */
    short events;

   // 发生的事件
    short revents;
};

/**
 * poll
 *
 * @param: struct pollfd* 指向一个结构体数组的指针
 *    每个元素都是一个 struct pollfd 结构，用于指定测试某个给定的 fd 条件
 * @param: nfds_t* 第一个参数数组元素个数
 * @param: int 等待的毫秒数
 * @return:
 *    成功返回 revents 中不为 0 的文件描述符个数
 *    失败返回 -1，并设置 errno 值
 *
 *    EBADF   一个或多个结构体中指定的文件描述符无效
 *    EFAULT  fds指针指向的地址超出了进程的地址空间
 *    EINTR   中断信号
 *    EINVAL  nfds 参数超出 PLIMIT_NOFILE 值
 *    ENOMEM  内存不足，无法完成请求
 */
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

### `select 和 poll` 的区别

> - 同：轮询、整体`复制`
> - 异：连接数（因为 poll 采用链表）

`poll` 没有最大连接数的限制，原因是它是基于【链表】来存储的

- `poll`的机制与`select`类似，与`select`在本质上没有多大差别，管理多个描述符`也是进行遍历轮询，根据描述符的状态进行处理`

- `select` 和 `poll` 都需要在返回后，通过遍历来获取已经就绪的文件描述符。事实上，**同时连接的大量客户端在一时刻可能只有很少的处于就绪状态**，因此随着监视的描述符数量的增长，其效率也会线性下降。

### `poll` 缺点

- 大量的 fd 的数组被整体**复制**于用户态和内核地址空间之间

- poll 还有一个`特点是水平触发`，如果报告了 fd 后，没有被处理，那么下次 poll 时会再次报告该 fd

- `poll 和 select` 同样存在一个缺点就是，包含大量`文件描述符的数组【被整体复制于用户态和内核的地址空间之间】`，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

## `epoll`

> `event poll` 有点像事件驱动（回调）

在应对大量网络连接时，`只有【活跃连接较少的情况下】（正常场景活跃的套接字也不多） epoll 才能表现出性能优异`。换句话说，在处理大量非活跃的连接时性能才会表现的优异。如果 15000 个 socket 都是活跃的，epoll 和 select 其实差不了太多

![alt](https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vcL2AwTHxYD6ZK7uvniaetQIiaicF9dluc6CD2EX3qLoC4EyuObNbzzxicw/640?wx_fmt=png)

### 函数原型

> - 先用 `epoll_create` 创建一个 epoll 对象 epfd（这个就是 select 一直在遍历的那个表）
> - 再通过 `epoll_ctl` 将需要监视的 Socket 添加到 Epfd 中
> - 调用 `epoll_wait` 等待数据

```cpp
/**
 * 【创建】 epoll 句柄，epoll 只会占用一个文件描述符，用完记得 close()
 *
 * @param: int 告诉内核这个监听的数目一共有多大
 *     不像 select 那样，会限制监听的套接字多少
 *     内部实现使用的是一个【哈希表】，这个值就表示哈希表的容量
 *     // 新内核已经换成红黑树了
 *
 * @return: 返回文件描述符
 */
int epoll_create(int size);
// epoll_create1(int flags); 已经换成红黑树实现了


typedef union epoll_data
{
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;

struct epoll_event
{
    // Epoll 事件，可以是以下几个宏的组合
    __uint32_t events;

    /**
     * EPOLLIN  表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
     * EPOLLOUT 表示对应的文件描述符可以写
     * EPOLLPRI 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
     * EPOLLERR 表示对应的文件描述符发生错误
     * EPOLLHUP 表示对应的文件描述符被挂断
     * EPOLLET  将 EPOLL 设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的
     * EPOLLONESHOT 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
     */

    // 携带的数据
    epoll_data_t data;

    // epoll_data_t 是一个 union 共用体，大小是 8 个字节
}

/**
 * epoll_ctl 对指定描述符进行【操作】，所以每个套接字其实只会拷贝一次到内核空间
 *
 * @param: int epoll_create() 的返回值
 * @param: int 表示操作类型
 *     添加 `EPOLL_CTL_ADD` 需要管理的套接字
 *     删除 `EPOLL_CTL_DEL` 作用是确保把这个 socket 的 fd 从监听队列中删除
 *     修改 `EPOLL_CTL_MOD`
 *
 * @param: int 需要监听的文件描述符
 * @param: struct epoll_event 告诉内核需要监听什么事件
 * @return: int
 */
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

/**
 * 【等待】 epfd 上的 io 事件发生
 *
 * 如果发生则将发生的 sokct 描述符和事件类型放入到 events 数组中
 * epoll 为每个文件描述符指定【回调】函数
 * 当文件描述符就绪，唤醒等待队列上的等待者时，就会执行这个回调函数
 * 而这个回调函数会把就绪的 fd 加入一个就绪链表
 *
 * epoll_wait 的工作实际上就是在这个就绪链表中查看有没有就绪的 fd
 * 去掉了遍历的过程，而是通过监听回调的方式
 *
 * @param: int epoll_create() 的返回值
 * @param: struct epoll_event* 用于从内核得到事件的集合
 *     当事件发生时，可以直接通过 epoll_event->data->fd 来获悉哪个套接字发生了可读事件
 *     就没有必要像 select、poll 那样通过遍历套接字集合的方式来进行确定了
 * @param: int 该值不能大于创建 epoll_create() 时的 size
 * @param: int 超时时间
 * @return: int 返回需要处理的事件数目，返回 0 表示超时了
 */
int epoll_wait(int epfd, struct epoll_event * events,
               int maxevents, int timeout);
```

### `epoll` 工作原理

使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个 `【事件表】` 中，这样在用户空间和内核空间只需要把这个事件表 `【拷贝进去一次】` 就行了。

可以看到把 I/O 事件的等待和监听任务交给了操作系统内核，内核在 I/O 状态发生改变后（例如 socket 连接已建立成功可发送数据），即发生了可读可写事件后 (EPOLLIN/EPOLLOUT)，`【回调】`我们注册的函数 (recv/send)，这样我们就收到了内核的通知完成收发数据操作。

![alt](https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

### `epoll` 水平触发模式 LT 和 边缘触发模式 ET

> - `LT 水平触发`：就像那一根针划过一张砂纸，会不断收到提醒
> - `ET 边缘触发`：就像两根针针锋相对地碰一下

- `Level Triggered（水平触发）`

  - 当被监控的文件描述符上有可读写事件发生时，`epoll_wait()` 会通知处理程序去读写。

  - 如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，**那么下次调用 `epoll_wait()` 时，它还会通知你在上没读写完的文件描述符上继续读写，知道你读完为止**

- `Edge Triggered（边缘触发）`

  - 当被监控的文件描述符上有可读写事件发生时，`epoll_wait()` 会通知处理程序去读写。

  - 如果这次没有把数据全部读写完(如读写缓冲区太小)，**那么下次调用 `epoll_wait()`时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！**

### `epoll` 水平触发和边缘触发的区别

- 水平模式比较耿直，有事件就一定给老子处理掉它，一次不行就两次；如果一直不去读写，它会一直通知你！

- 如果系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！

- `边缘触发`模式比`水平触发`效率高，系统不会充斥大量你不关心的就绪文件描述符！ `select(), poll()` 模型都是水平触发模式，信号驱动 IO 是边缘触发模式，`epoll()` 模型即支持水平触发，也支持边缘触发，默认是水平触发。

**`总结`**

- 对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，网上有的方案是用 while 来循环 accept()

- 对于读写的 connfd，水平触发模式下，阻塞和非阻塞效果都一样，不过为了防止特殊情况，还是建议设置非阻塞

- 对于读写的 connfd，边缘触发模式下，必须使用非阻塞 IO，并要一次性全部读写完数据

### ★ `select 和 epoll` 的区别

围绕着 `select` 的三个缺点：文件描述符限制、轮询、整体复制

`epoll` 不仅会告诉有 `I/O` 时间到来，还会告诉应用程序相关的信息这些信息是应用程序填充的（上面说到的 `epoll_data` 可以保存一个指针，指向用户自定义的结构，类似回调），因此，根据这些新应用程序就能直接定位到事件，而不必遍历整个 fd 集合。（又节省了一次对集合的遍历）

#### `epoll` 怎么解决套接字集合整体 `反复拷贝` 的问题

> 前面学习 `select` 和 `poll` 知道需要把套接字集合/链表从用户态拷贝到内核态，那么 epoll 是怎么做的呢？把哈希表拷贝到内核态吗？

本来 select 是要把表整个拷贝进内核，epoll 是直接在内核中创建表

- 内核通过一个`【事件表】`直接管理用户感兴趣的所有事件，因此每次调用 `epoll_wait` 的时候，无须反复传入用户感兴趣的事件，`epoll_wait` 系统调用的参数 `events` 仅用来反馈就绪的事件

- `epoll_ctl 函数中。每次【注册新事件】到 epoll 句柄中时（在 epoll_ctl 中指定 EPOLL_CTL_ADD 操作），会把所有的 fd 拷贝进内核`，而不是在 epoll_wait 的时候重复拷贝。epoll 保证了每个 fd 在整个过程中只会拷贝一次

**内核空间和用户空间之间的内存拷贝问题**

- `select` 和 `poll` 内核函数调用时，需要把集合整体从用户空间拷贝到内核空间，发生事件后，又把集合从内核拷贝到用户空间，其实大部分文件描述符都是未就绪状态，这增加了消耗。

- `epoll` 的实现中`每次只遍历活跃的描述符`，在活跃文件描述符少的情况下很有优势，**如果大部分描述符都是活跃的，epoll 的效率可能不如 select 或 poll**

#### `epoll` 怎么解决套接字 `轮询` 的问题

- 在 `epoll_ctl` 时把 current 挂一遍（这一遍必不可少）并为每个 fd 指定一个回调函数，`【当套接字就绪，会唤醒等待队列上的等待者时，就会调用对应的回调函数】`

- 这个回调函数会把就绪的 fd 加入一个就绪链表。epoll_wait 的工作实际上就是在这个就绪链表中查看有没有就绪的 fd

- **select 会随着文件描述符数目增长而降低效率**

  - `select 采用轮询文件描述符的方式处理`，其中的数据结构类似一个数组的数据结构

  - `epoll是维护一个【哈希表】`，直接看是不是空就可以了(`select`存放在数组，`poll` 存放在链表，`epoll`存放在哈希)

#### `epoll` 怎么解决套接字 `容量` 的问题

- `epoll` 没有这个限制，`它所支持的 FD 上限是最大可以打开文件的数目`，这个数字一般远大于 2048

- 举个例子, 在 1GB 内存的机器上大约是 10 万左右，具体数目可以 `cat /proc/sys/fs/file-max` 察看, 一般来说这个数目和系统内存关系很大

- 句柄数目受限

  `epoll` 也有限制，但是很大，它的限制是最大的打开文件句柄数目

  ```sh
  # 1GB 内存的机器上大约是 10w 左右
  $cat /proc/sys/fs/file-max
  ```

### LT 触发模式下，当 socket 可写时，会不停的触发 socket 可写的事件，如何处理

[epoll 的 accept , read, write(重要)](https://blog.csdn.net/ctthuangcheng/article/details/9716715)

**第一种最普遍的方式：**

- 需要向 socket `【写数据的时候才把 socket 加入 epoll】` ，等待可写事件。接受到可写事件后，调用 write 或者 send 发送数据。

- 当所有数据都写完后，把 socket 移出 epoll。

- 这种方式的**缺点**是，即使发送很少的数据，也要把 socket 加入 epoll，写完后在移出 epoll，有一定操作代价。

**一种改进的方式：**

- 开始不把 socket 加入 epoll，需要向 socket 写数据的时候，`【直接调用 write 或者 send 发送数据】`；

- `如果返回 EAGAIN，把 socket 加入 epoll`，在 epoll 的驱动下写数据，全部数据发送完毕后，再移出 epoll。

- 这种方式的优点是：数据不多的时候可以避免 epoll 的事件处理，提高效率。

# 其他

`socket` 可以看作是`用户进程`与`内核`网络协议栈之间的编程接口, 所有的 `bind`, `listen`, `accept`, `send` 等都是内核函数；

所以应用层是通过 socket 来与其他几层进行交互的(socket 是对其他几层的封装)；socket 不仅能在本机间进行进程通信, 还可以在异构系统(即硬件可以不同)中进行。

```log
# 虚线框中为内核空间

[Application]                                          [Application]
      ↓                                                      ↓
      ↓ (socket)                                             ↓ (socket)
      ↓                                                      ↓
+- - - - - - - - - - - - - - - -  - - - - - - - -  - - - - - - - - - -+
|  [TCP / UDP]                                           [TCP / UDP]  |
|     ↓                                                      ↓        |
|     ↓                                                      ↓        |
|   [IP]                                                    [IP]      |
|     ↓                                                      ↓        |
|     ↓                                                      ↓        |
|     + --> --> --> --> --> [网络接口层] --> --> --> --> -->  +        |
+ - - - - - - - - - - - - - - - -  - - - - - - - -  - - - - - - -  - -+
```
