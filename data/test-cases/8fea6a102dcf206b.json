{"uid":"8fea6a102dcf206b","name":"test_video_handler[TedEd]","fullName":"lib.youtube.test_video_handler#test_video_handler","historyId":"460f64e7a6b6aff9fd7ddba1a64e667f","time":{"start":1720667765883,"stop":1720667780424,"duration":14541},"description":"\n    测试 youtu 视频剪辑\n    ","descriptionHtml":"<pre><code>测试 youtu 视频剪辑\n</code></pre>\n","status":"broken","statusMessage":"yt_dlp.utils.DownloadError: ERROR: unable to download video data: HTTP Error 403: Forbidden","statusTrace":"self = <yt_dlp.YoutubeDL.YoutubeDL object at 0x7fe054093c70>\ninfo_dict = {'__postprocessors': [], '__real_download': True, '_filename': '/home/runner/work/github-runner/github-runner/mypy/tes...vbt7c/mAxFB3vbt7c.mp4', '_format_sort_fields': ('quality', 'res', 'fps', 'hdr:12', 'source', 'vcodec:vp9.2', ...), ...}\n\n    @_catch_unsafe_extension_error\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result. (Modifies it in-place)\"\"\"\n    \n        assert info_dict.get('_type', 'video') == 'video'\n        original_infodict = info_dict\n    \n        if 'format' not in info_dict and 'ext' in info_dict:\n            info_dict['format'] = info_dict['ext']\n    \n        if self._match_entry(info_dict) is not None:\n            info_dict['__write_download_archive'] = 'ignore'\n            return\n    \n        # Does nothing under normal operation - for backward compatibility of process_info\n        self.post_extract(info_dict)\n    \n        def replace_info_dict(new_info):\n            nonlocal info_dict\n            if new_info == info_dict:\n                return\n            info_dict.clear()\n            info_dict.update(new_info)\n    \n        new_info, _ = self.pre_process(info_dict, 'video')\n        replace_info_dict(new_info)\n        self._num_downloads += 1\n    \n        # info_dict['_filename'] needs to be set for backward compatibility\n        info_dict['_filename'] = full_filename = self.prepare_filename(info_dict, warn=True)\n        temp_filename = self.prepare_filename(info_dict, 'temp')\n        files_to_move = {}\n    \n        # Forced printings\n        self.__forced_printings(info_dict, full_filename, incomplete=('format' not in info_dict))\n    \n        def check_max_downloads():\n            if self._num_downloads >= float(self.params.get('max_downloads') or 'inf'):\n                raise MaxDownloadsReached\n    \n        if self.params.get('simulate'):\n            info_dict['__write_download_archive'] = self.params.get('force_write_download_archive')\n            check_max_downloads()\n            return\n    \n        if full_filename is None:\n            return\n        if not self._ensure_dir_exists(encodeFilename(full_filename)):\n            return\n        if not self._ensure_dir_exists(encodeFilename(temp_filename)):\n            return\n    \n        if self._write_description('video', info_dict,\n                                   self.prepare_filename(info_dict, 'description')) is None:\n            return\n    \n        sub_files = self._write_subtitles(info_dict, temp_filename)\n        if sub_files is None:\n            return\n        files_to_move.update(dict(sub_files))\n    \n        thumb_files = self._write_thumbnails(\n            'video', info_dict, temp_filename, self.prepare_filename(info_dict, 'thumbnail'))\n        if thumb_files is None:\n            return\n        files_to_move.update(dict(thumb_files))\n    \n        infofn = self.prepare_filename(info_dict, 'infojson')\n        _infojson_written = self._write_info_json('video', info_dict, infofn)\n        if _infojson_written:\n            info_dict['infojson_filename'] = infofn\n            # For backward compatibility, even though it was a private field\n            info_dict['__infojson_filename'] = infofn\n        elif _infojson_written is None:\n            return\n    \n        # Note: Annotations are deprecated\n        annofn = None\n        if self.params.get('writeannotations', False):\n            annofn = self.prepare_filename(info_dict, 'annotation')\n        if annofn:\n            if not self._ensure_dir_exists(encodeFilename(annofn)):\n                return\n            if not self.params.get('overwrites', True) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            elif not info_dict.get('annotations'):\n                self.report_warning('There are no annotations to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except OSError:\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n    \n        # Write internet shortcut files\n        def _write_link_file(link_type):\n            url = try_get(info_dict['webpage_url'], iri_to_uri)\n            if not url:\n                self.report_warning(\n                    f'Cannot write internet shortcut file because the actual URL of \"{info_dict[\"webpage_url\"]}\" is unknown')\n                return True\n            linkfn = replace_extension(self.prepare_filename(info_dict, 'link'), link_type, info_dict.get('ext'))\n            if not self._ensure_dir_exists(encodeFilename(linkfn)):\n                return False\n            if self.params.get('overwrites', True) and os.path.exists(encodeFilename(linkfn)):\n                self.to_screen(f'[info] Internet shortcut (.{link_type}) is already present')\n                return True\n            try:\n                self.to_screen(f'[info] Writing internet shortcut (.{link_type}) to: {linkfn}')\n                with open(encodeFilename(to_high_limit_path(linkfn)), 'w', encoding='utf-8',\n                          newline='\\r\\n' if link_type == 'url' else '\\n') as linkfile:\n                    template_vars = {'url': url}\n                    if link_type == 'desktop':\n                        template_vars['filename'] = linkfn[:-(len(link_type) + 1)]\n                    linkfile.write(LINK_TEMPLATES[link_type] % template_vars)\n            except OSError:\n                self.report_error(f'Cannot write internet shortcut {linkfn}')\n                return False\n            return True\n    \n        write_links = {\n            'url': self.params.get('writeurllink'),\n            'webloc': self.params.get('writewebloclink'),\n            'desktop': self.params.get('writedesktoplink'),\n        }\n        if self.params.get('writelink'):\n            link_type = ('webloc' if sys.platform == 'darwin'\n                         else 'desktop' if sys.platform.startswith('linux')\n                         else 'url')\n            write_links[link_type] = True\n    \n        if any(should_write and not _write_link_file(link_type)\n               for link_type, should_write in write_links.items()):\n            return\n    \n        new_info, files_to_move = self.pre_process(info_dict, 'before_dl', files_to_move)\n        replace_info_dict(new_info)\n    \n        if self.params.get('skip_download'):\n            info_dict['filepath'] = temp_filename\n            info_dict['__finaldir'] = os.path.dirname(os.path.abspath(encodeFilename(full_filename)))\n            info_dict['__files_to_move'] = files_to_move\n            replace_info_dict(self.run_pp(MoveFilesAfterDownloadPP(self, False), info_dict))\n            info_dict['__write_download_archive'] = self.params.get('force_write_download_archive')\n        else:\n            # Download\n            info_dict.setdefault('__postprocessors', [])\n            try:\n    \n                def existing_video_file(*filepaths):\n                    ext = info_dict.get('ext')\n                    converted = lambda file: replace_extension(file, self.params.get('final_ext') or ext, ext)\n                    file = self.existing_file(itertools.chain(*zip(map(converted, filepaths), filepaths)),\n                                              default_overwrite=False)\n                    if file:\n                        info_dict['ext'] = os.path.splitext(file)[1][1:]\n                    return file\n    \n                fd, success = None, True\n                if info_dict.get('protocol') or info_dict.get('url'):\n                    fd = get_suitable_downloader(info_dict, self.params, to_stdout=temp_filename == '-')\n                    if fd != FFmpegFD and 'no-direct-merge' not in self.params['compat_opts'] and (\n                            info_dict.get('section_start') or info_dict.get('section_end')):\n                        msg = ('This format cannot be partially downloaded' if FFmpegFD.available()\n                               else 'You have requested downloading the video partially, but ffmpeg is not installed')\n                        self.report_error(f'{msg}. Aborting')\n                        return\n    \n                if info_dict.get('requested_formats') is not None:\n                    old_ext = info_dict['ext']\n                    if self.params.get('merge_output_format') is None:\n                        if (info_dict['ext'] == 'webm'\n                                and info_dict.get('thumbnails')\n                                # check with type instead of pp_key, __name__, or isinstance\n                                # since we dont want any custom PPs to trigger this\n                                and any(type(pp) == EmbedThumbnailPP for pp in self._pps['post_process'])):  # noqa: E721\n                            info_dict['ext'] = 'mkv'\n                            self.report_warning(\n                                'webm doesn\\'t support embedding a thumbnail, mkv will be used')\n                    new_ext = info_dict['ext']\n    \n                    def correct_ext(filename, ext=new_ext):\n                        if filename == '-':\n                            return filename\n                        filename_real_ext = os.path.splitext(filename)[1][1:]\n                        filename_wo_ext = (\n                            os.path.splitext(filename)[0]\n                            if filename_real_ext in (old_ext, new_ext)\n                            else filename)\n                        return f'{filename_wo_ext}.{ext}'\n    \n                    # Ensure filename always has a correct extension for successful merge\n                    full_filename = correct_ext(full_filename)\n                    temp_filename = correct_ext(temp_filename)\n                    dl_filename = existing_video_file(full_filename, temp_filename)\n    \n                    info_dict['__real_download'] = False\n                    # NOTE: Copy so that original format dicts are not modified\n                    info_dict['requested_formats'] = list(map(dict, info_dict['requested_formats']))\n    \n                    merger = FFmpegMergerPP(self)\n                    downloaded = []\n                    if dl_filename is not None:\n                        self.report_file_already_downloaded(dl_filename)\n                    elif fd:\n                        for f in info_dict['requested_formats'] if fd != FFmpegFD else []:\n                            f['filepath'] = fname = prepend_extension(\n                                correct_ext(temp_filename, info_dict['ext']),\n                                'f{}'.format(f['format_id']), info_dict['ext'])\n                            downloaded.append(fname)\n                        info_dict['url'] = '\\n'.join(f['url'] for f in info_dict['requested_formats'])\n                        success, real_download = self.dl(temp_filename, info_dict)\n                        info_dict['__real_download'] = real_download\n                    else:\n                        if self.params.get('allow_unplayable_formats'):\n                            self.report_warning(\n                                'You have requested merging of multiple formats '\n                                'while also allowing unplayable formats to be downloaded. '\n                                'The formats won\\'t be merged to prevent data corruption.')\n                        elif not merger.available:\n                            msg = 'You have requested merging of multiple formats but ffmpeg is not installed'\n                            if not self.params.get('ignoreerrors'):\n                                self.report_error(f'{msg}. Aborting due to --abort-on-error')\n                                return\n                            self.report_warning(f'{msg}. The formats won\\'t be merged')\n    \n                        if temp_filename == '-':\n                            reason = ('using a downloader other than ffmpeg' if FFmpegFD.can_merge_formats(info_dict, self.params)\n                                      else 'but the formats are incompatible for simultaneous download' if merger.available\n                                      else 'but ffmpeg is not installed')\n                            self.report_warning(\n                                f'You have requested downloading multiple formats to stdout {reason}. '\n                                'The formats will be streamed one after the other')\n                            fname = temp_filename\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            del new_info['requested_formats']\n                            new_info.update(f)\n                            if temp_filename != '-':\n                                fname = prepend_extension(\n                                    correct_ext(temp_filename, new_info['ext']),\n                                    'f{}'.format(f['format_id']), new_info['ext'])\n                                if not self._ensure_dir_exists(fname):\n                                    return\n                                f['filepath'] = fname\n                                downloaded.append(fname)\n>                           partial_success, real_download = self.dl(fname, new_info)\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3460: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3198: in dl\n    return fd.download(name, new_info, subtitle)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/common.py:466: in download\n    ret = self.real_download(filename, info_dict)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/http.py:369: in real_download\n    establish_connection()\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/http.py:120: in establish_connection\n    ctx.data = self.ydl.urlopen(request)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:4160: in urlopen\n    return self._request_director.send(req)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/common.py:117: in send\n    response = handler.send(request)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/_helper.py:208: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/common.py:337: in send\n    return self._send(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <yt_dlp.networking._requests.RequestsRH object at 0x7fe08724dd00>\nrequest = <yt_dlp.networking.common.Request object at 0x7fe042737760>\n\n    def _send(self, request):\n    \n        headers = self._merge_headers(request.headers)\n        add_accept_encoding_header(headers, SUPPORTED_ENCODINGS)\n    \n        max_redirects_exceeded = False\n    \n        session = self._get_instance(cookiejar=self._get_cookiejar(request))\n    \n        try:\n            requests_res = session.request(\n                method=request.method,\n                url=request.url,\n                data=request.data,\n                headers=headers,\n                timeout=self._calculate_timeout(request),\n                proxies=self._get_proxies(request),\n                allow_redirects=True,\n                stream=True,\n            )\n    \n        except requests.exceptions.TooManyRedirects as e:\n            max_redirects_exceeded = True\n            requests_res = e.response\n    \n        except requests.exceptions.SSLError as e:\n            if 'CERTIFICATE_VERIFY_FAILED' in str(e):\n                raise CertificateVerifyError(cause=e) from e\n            raise SSLError(cause=e) from e\n    \n        except requests.exceptions.ProxyError as e:\n            raise ProxyError(cause=e) from e\n    \n        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:\n            raise TransportError(cause=e) from e\n    \n        except urllib3.exceptions.HTTPError as e:\n            # Catch any urllib3 exceptions that may leak through\n            raise TransportError(cause=e) from e\n    \n        except requests.exceptions.RequestException as e:\n            # Miscellaneous Requests exceptions. May not necessary be network related e.g. InvalidURL\n            raise RequestError(cause=e) from e\n    \n        res = RequestsResponseAdapter(requests_res)\n    \n        if not 200 <= res.status < 300:\n>           raise HTTPError(res, redirect_loop=max_redirects_exceeded)\nE           yt_dlp.networking.exceptions.HTTPError: HTTP Error 403: Forbidden\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/_requests.py:361: HTTPError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_output_dir = '/home/runner/work/github-runner/github-runner/mypy/tests/lib/youtube/_out/test_video_handler'\nvideo_url = 'https://www.youtube.com/watch?v=mAxFB3vbt7c'\n\n    @pytest.mark.parametrize(\n        'video_url',\n        ['https://www.youtube.com/shorts/B0lkyu2NFnA',\n         'https://www.youtube.com/shorts/3OSwmeCuq_0',\n         'https://www.youtube.com/watch?v=mAxFB3vbt7c',\n         'https://www.youtube.com/watch?v=c9hWEA9fiNQ',\n         'https://www.youtube.com/watch?v=MWIeswvua1I'],\n        ids=['SciePro', 'SlideSkills', 'TedEd', 'RegisteredNurseRN', 'vertical_video'])\n    def test_video_handler(test_output_dir, video_url):\n        \"\"\"\n        测试 youtu 视频剪辑\n        \"\"\"\n        api = VideoHandler(work_path=test_output_dir,\n                           channel_id=YouTube(video_url).channel_id,\n                           video_url=video_url,\n                           ffmpeg_log_output=True)\n>       _, video_fullpath = api.get_video(with_srt=True,\n                                          clean_download=False)\n\nmypy/tests/lib/youtube/test_video_handler.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nmypy/lib/youtube/video_handler.py:299: in get_video\n    download_video, zh_srt, en_srt = y2_api.download_media(with_srt)\nmypy/lib/youtube/ytdlp_helper.py:206: in download_media\n    self._download_video()\nmypy/lib/youtube/ytdlp_helper.py:152: in _download_video\n    ydl.download([self._video_url])\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3602: in download\n    self.__download_wrapper(self.extract_info)(\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3577: in wrapper\n    res = func(*args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1611: in extract_info\n    return self.__extract_info(url, self.get_info_extractor(key), download, extra_info, process)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1622: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1778: in __extract_info\n    return self.process_ie_result(ie_result, download, extra_info)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1837: in process_ie_result\n    ie_result = self.process_video_result(ie_result, download=download)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3011: in process_video_result\n    self.process_info(new_info)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:179: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3487: in process_info\n    self.report_error(f'unable to download video data: {err}')\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1088: in report_error\n    self.trouble(f'{self._format_err(\"ERROR:\", self.Styles.ERROR)} {message}', *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <yt_dlp.YoutubeDL.YoutubeDL object at 0x7fe054093c70>\nmessage = 'ERROR: unable to download video data: HTTP Error 403: Forbidden'\ntb = None, is_error = True\n\n    def trouble(self, message=None, tb=None, is_error=True):\n        \"\"\"Determine action to take when a download problem appears.\n    \n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n    \n        @param tb          If given, is additional traceback information\n        @param is_error    Whether to raise error according to ignorerrors\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += encode_compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            if tb:\n                self.to_stderr(tb)\n        if not is_error:\n            return\n        if not self.params.get('ignoreerrors'):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n>           raise DownloadError(message, exc_info)\nE           yt_dlp.utils.DownloadError: ERROR: unable to download video data: HTTP Error 403: Forbidden\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1027: DownloadError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"event_loop_policy","time":{"start":1720661881298,"stop":1720661881298,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"copy_config_to_dir","time":{"start":1720667717197,"stop":1720667717198,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"test_output_dir","time":{"start":1720667717198,"stop":1720667717198,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"\n    测试 youtu 视频剪辑\n    ","status":"broken","statusMessage":"yt_dlp.utils.DownloadError: ERROR: unable to download video data: HTTP Error 403: Forbidden","statusTrace":"self = <yt_dlp.YoutubeDL.YoutubeDL object at 0x7fe054093c70>\ninfo_dict = {'__postprocessors': [], '__real_download': True, '_filename': '/home/runner/work/github-runner/github-runner/mypy/tes...vbt7c/mAxFB3vbt7c.mp4', '_format_sort_fields': ('quality', 'res', 'fps', 'hdr:12', 'source', 'vcodec:vp9.2', ...), ...}\n\n    @_catch_unsafe_extension_error\n    def process_info(self, info_dict):\n        \"\"\"Process a single resolved IE result. (Modifies it in-place)\"\"\"\n    \n        assert info_dict.get('_type', 'video') == 'video'\n        original_infodict = info_dict\n    \n        if 'format' not in info_dict and 'ext' in info_dict:\n            info_dict['format'] = info_dict['ext']\n    \n        if self._match_entry(info_dict) is not None:\n            info_dict['__write_download_archive'] = 'ignore'\n            return\n    \n        # Does nothing under normal operation - for backward compatibility of process_info\n        self.post_extract(info_dict)\n    \n        def replace_info_dict(new_info):\n            nonlocal info_dict\n            if new_info == info_dict:\n                return\n            info_dict.clear()\n            info_dict.update(new_info)\n    \n        new_info, _ = self.pre_process(info_dict, 'video')\n        replace_info_dict(new_info)\n        self._num_downloads += 1\n    \n        # info_dict['_filename'] needs to be set for backward compatibility\n        info_dict['_filename'] = full_filename = self.prepare_filename(info_dict, warn=True)\n        temp_filename = self.prepare_filename(info_dict, 'temp')\n        files_to_move = {}\n    \n        # Forced printings\n        self.__forced_printings(info_dict, full_filename, incomplete=('format' not in info_dict))\n    \n        def check_max_downloads():\n            if self._num_downloads >= float(self.params.get('max_downloads') or 'inf'):\n                raise MaxDownloadsReached\n    \n        if self.params.get('simulate'):\n            info_dict['__write_download_archive'] = self.params.get('force_write_download_archive')\n            check_max_downloads()\n            return\n    \n        if full_filename is None:\n            return\n        if not self._ensure_dir_exists(encodeFilename(full_filename)):\n            return\n        if not self._ensure_dir_exists(encodeFilename(temp_filename)):\n            return\n    \n        if self._write_description('video', info_dict,\n                                   self.prepare_filename(info_dict, 'description')) is None:\n            return\n    \n        sub_files = self._write_subtitles(info_dict, temp_filename)\n        if sub_files is None:\n            return\n        files_to_move.update(dict(sub_files))\n    \n        thumb_files = self._write_thumbnails(\n            'video', info_dict, temp_filename, self.prepare_filename(info_dict, 'thumbnail'))\n        if thumb_files is None:\n            return\n        files_to_move.update(dict(thumb_files))\n    \n        infofn = self.prepare_filename(info_dict, 'infojson')\n        _infojson_written = self._write_info_json('video', info_dict, infofn)\n        if _infojson_written:\n            info_dict['infojson_filename'] = infofn\n            # For backward compatibility, even though it was a private field\n            info_dict['__infojson_filename'] = infofn\n        elif _infojson_written is None:\n            return\n    \n        # Note: Annotations are deprecated\n        annofn = None\n        if self.params.get('writeannotations', False):\n            annofn = self.prepare_filename(info_dict, 'annotation')\n        if annofn:\n            if not self._ensure_dir_exists(encodeFilename(annofn)):\n                return\n            if not self.params.get('overwrites', True) and os.path.exists(encodeFilename(annofn)):\n                self.to_screen('[info] Video annotations are already present')\n            elif not info_dict.get('annotations'):\n                self.report_warning('There are no annotations to write.')\n            else:\n                try:\n                    self.to_screen('[info] Writing video annotations to: ' + annofn)\n                    with open(encodeFilename(annofn), 'w', encoding='utf-8') as annofile:\n                        annofile.write(info_dict['annotations'])\n                except (KeyError, TypeError):\n                    self.report_warning('There are no annotations to write.')\n                except OSError:\n                    self.report_error('Cannot write annotations file: ' + annofn)\n                    return\n    \n        # Write internet shortcut files\n        def _write_link_file(link_type):\n            url = try_get(info_dict['webpage_url'], iri_to_uri)\n            if not url:\n                self.report_warning(\n                    f'Cannot write internet shortcut file because the actual URL of \"{info_dict[\"webpage_url\"]}\" is unknown')\n                return True\n            linkfn = replace_extension(self.prepare_filename(info_dict, 'link'), link_type, info_dict.get('ext'))\n            if not self._ensure_dir_exists(encodeFilename(linkfn)):\n                return False\n            if self.params.get('overwrites', True) and os.path.exists(encodeFilename(linkfn)):\n                self.to_screen(f'[info] Internet shortcut (.{link_type}) is already present')\n                return True\n            try:\n                self.to_screen(f'[info] Writing internet shortcut (.{link_type}) to: {linkfn}')\n                with open(encodeFilename(to_high_limit_path(linkfn)), 'w', encoding='utf-8',\n                          newline='\\r\\n' if link_type == 'url' else '\\n') as linkfile:\n                    template_vars = {'url': url}\n                    if link_type == 'desktop':\n                        template_vars['filename'] = linkfn[:-(len(link_type) + 1)]\n                    linkfile.write(LINK_TEMPLATES[link_type] % template_vars)\n            except OSError:\n                self.report_error(f'Cannot write internet shortcut {linkfn}')\n                return False\n            return True\n    \n        write_links = {\n            'url': self.params.get('writeurllink'),\n            'webloc': self.params.get('writewebloclink'),\n            'desktop': self.params.get('writedesktoplink'),\n        }\n        if self.params.get('writelink'):\n            link_type = ('webloc' if sys.platform == 'darwin'\n                         else 'desktop' if sys.platform.startswith('linux')\n                         else 'url')\n            write_links[link_type] = True\n    \n        if any(should_write and not _write_link_file(link_type)\n               for link_type, should_write in write_links.items()):\n            return\n    \n        new_info, files_to_move = self.pre_process(info_dict, 'before_dl', files_to_move)\n        replace_info_dict(new_info)\n    \n        if self.params.get('skip_download'):\n            info_dict['filepath'] = temp_filename\n            info_dict['__finaldir'] = os.path.dirname(os.path.abspath(encodeFilename(full_filename)))\n            info_dict['__files_to_move'] = files_to_move\n            replace_info_dict(self.run_pp(MoveFilesAfterDownloadPP(self, False), info_dict))\n            info_dict['__write_download_archive'] = self.params.get('force_write_download_archive')\n        else:\n            # Download\n            info_dict.setdefault('__postprocessors', [])\n            try:\n    \n                def existing_video_file(*filepaths):\n                    ext = info_dict.get('ext')\n                    converted = lambda file: replace_extension(file, self.params.get('final_ext') or ext, ext)\n                    file = self.existing_file(itertools.chain(*zip(map(converted, filepaths), filepaths)),\n                                              default_overwrite=False)\n                    if file:\n                        info_dict['ext'] = os.path.splitext(file)[1][1:]\n                    return file\n    \n                fd, success = None, True\n                if info_dict.get('protocol') or info_dict.get('url'):\n                    fd = get_suitable_downloader(info_dict, self.params, to_stdout=temp_filename == '-')\n                    if fd != FFmpegFD and 'no-direct-merge' not in self.params['compat_opts'] and (\n                            info_dict.get('section_start') or info_dict.get('section_end')):\n                        msg = ('This format cannot be partially downloaded' if FFmpegFD.available()\n                               else 'You have requested downloading the video partially, but ffmpeg is not installed')\n                        self.report_error(f'{msg}. Aborting')\n                        return\n    \n                if info_dict.get('requested_formats') is not None:\n                    old_ext = info_dict['ext']\n                    if self.params.get('merge_output_format') is None:\n                        if (info_dict['ext'] == 'webm'\n                                and info_dict.get('thumbnails')\n                                # check with type instead of pp_key, __name__, or isinstance\n                                # since we dont want any custom PPs to trigger this\n                                and any(type(pp) == EmbedThumbnailPP for pp in self._pps['post_process'])):  # noqa: E721\n                            info_dict['ext'] = 'mkv'\n                            self.report_warning(\n                                'webm doesn\\'t support embedding a thumbnail, mkv will be used')\n                    new_ext = info_dict['ext']\n    \n                    def correct_ext(filename, ext=new_ext):\n                        if filename == '-':\n                            return filename\n                        filename_real_ext = os.path.splitext(filename)[1][1:]\n                        filename_wo_ext = (\n                            os.path.splitext(filename)[0]\n                            if filename_real_ext in (old_ext, new_ext)\n                            else filename)\n                        return f'{filename_wo_ext}.{ext}'\n    \n                    # Ensure filename always has a correct extension for successful merge\n                    full_filename = correct_ext(full_filename)\n                    temp_filename = correct_ext(temp_filename)\n                    dl_filename = existing_video_file(full_filename, temp_filename)\n    \n                    info_dict['__real_download'] = False\n                    # NOTE: Copy so that original format dicts are not modified\n                    info_dict['requested_formats'] = list(map(dict, info_dict['requested_formats']))\n    \n                    merger = FFmpegMergerPP(self)\n                    downloaded = []\n                    if dl_filename is not None:\n                        self.report_file_already_downloaded(dl_filename)\n                    elif fd:\n                        for f in info_dict['requested_formats'] if fd != FFmpegFD else []:\n                            f['filepath'] = fname = prepend_extension(\n                                correct_ext(temp_filename, info_dict['ext']),\n                                'f{}'.format(f['format_id']), info_dict['ext'])\n                            downloaded.append(fname)\n                        info_dict['url'] = '\\n'.join(f['url'] for f in info_dict['requested_formats'])\n                        success, real_download = self.dl(temp_filename, info_dict)\n                        info_dict['__real_download'] = real_download\n                    else:\n                        if self.params.get('allow_unplayable_formats'):\n                            self.report_warning(\n                                'You have requested merging of multiple formats '\n                                'while also allowing unplayable formats to be downloaded. '\n                                'The formats won\\'t be merged to prevent data corruption.')\n                        elif not merger.available:\n                            msg = 'You have requested merging of multiple formats but ffmpeg is not installed'\n                            if not self.params.get('ignoreerrors'):\n                                self.report_error(f'{msg}. Aborting due to --abort-on-error')\n                                return\n                            self.report_warning(f'{msg}. The formats won\\'t be merged')\n    \n                        if temp_filename == '-':\n                            reason = ('using a downloader other than ffmpeg' if FFmpegFD.can_merge_formats(info_dict, self.params)\n                                      else 'but the formats are incompatible for simultaneous download' if merger.available\n                                      else 'but ffmpeg is not installed')\n                            self.report_warning(\n                                f'You have requested downloading multiple formats to stdout {reason}. '\n                                'The formats will be streamed one after the other')\n                            fname = temp_filename\n                        for f in info_dict['requested_formats']:\n                            new_info = dict(info_dict)\n                            del new_info['requested_formats']\n                            new_info.update(f)\n                            if temp_filename != '-':\n                                fname = prepend_extension(\n                                    correct_ext(temp_filename, new_info['ext']),\n                                    'f{}'.format(f['format_id']), new_info['ext'])\n                                if not self._ensure_dir_exists(fname):\n                                    return\n                                f['filepath'] = fname\n                                downloaded.append(fname)\n>                           partial_success, real_download = self.dl(fname, new_info)\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3460: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3198: in dl\n    return fd.download(name, new_info, subtitle)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/common.py:466: in download\n    ret = self.real_download(filename, info_dict)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/http.py:369: in real_download\n    establish_connection()\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/downloader/http.py:120: in establish_connection\n    ctx.data = self.ydl.urlopen(request)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:4160: in urlopen\n    return self._request_director.send(req)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/common.py:117: in send\n    response = handler.send(request)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/_helper.py:208: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/common.py:337: in send\n    return self._send(request)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <yt_dlp.networking._requests.RequestsRH object at 0x7fe08724dd00>\nrequest = <yt_dlp.networking.common.Request object at 0x7fe042737760>\n\n    def _send(self, request):\n    \n        headers = self._merge_headers(request.headers)\n        add_accept_encoding_header(headers, SUPPORTED_ENCODINGS)\n    \n        max_redirects_exceeded = False\n    \n        session = self._get_instance(cookiejar=self._get_cookiejar(request))\n    \n        try:\n            requests_res = session.request(\n                method=request.method,\n                url=request.url,\n                data=request.data,\n                headers=headers,\n                timeout=self._calculate_timeout(request),\n                proxies=self._get_proxies(request),\n                allow_redirects=True,\n                stream=True,\n            )\n    \n        except requests.exceptions.TooManyRedirects as e:\n            max_redirects_exceeded = True\n            requests_res = e.response\n    \n        except requests.exceptions.SSLError as e:\n            if 'CERTIFICATE_VERIFY_FAILED' in str(e):\n                raise CertificateVerifyError(cause=e) from e\n            raise SSLError(cause=e) from e\n    \n        except requests.exceptions.ProxyError as e:\n            raise ProxyError(cause=e) from e\n    \n        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout) as e:\n            raise TransportError(cause=e) from e\n    \n        except urllib3.exceptions.HTTPError as e:\n            # Catch any urllib3 exceptions that may leak through\n            raise TransportError(cause=e) from e\n    \n        except requests.exceptions.RequestException as e:\n            # Miscellaneous Requests exceptions. May not necessary be network related e.g. InvalidURL\n            raise RequestError(cause=e) from e\n    \n        res = RequestsResponseAdapter(requests_res)\n    \n        if not 200 <= res.status < 300:\n>           raise HTTPError(res, redirect_loop=max_redirects_exceeded)\nE           yt_dlp.networking.exceptions.HTTPError: HTTP Error 403: Forbidden\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/networking/_requests.py:361: HTTPError\n\nDuring handling of the above exception, another exception occurred:\n\ntest_output_dir = '/home/runner/work/github-runner/github-runner/mypy/tests/lib/youtube/_out/test_video_handler'\nvideo_url = 'https://www.youtube.com/watch?v=mAxFB3vbt7c'\n\n    @pytest.mark.parametrize(\n        'video_url',\n        ['https://www.youtube.com/shorts/B0lkyu2NFnA',\n         'https://www.youtube.com/shorts/3OSwmeCuq_0',\n         'https://www.youtube.com/watch?v=mAxFB3vbt7c',\n         'https://www.youtube.com/watch?v=c9hWEA9fiNQ',\n         'https://www.youtube.com/watch?v=MWIeswvua1I'],\n        ids=['SciePro', 'SlideSkills', 'TedEd', 'RegisteredNurseRN', 'vertical_video'])\n    def test_video_handler(test_output_dir, video_url):\n        \"\"\"\n        测试 youtu 视频剪辑\n        \"\"\"\n        api = VideoHandler(work_path=test_output_dir,\n                           channel_id=YouTube(video_url).channel_id,\n                           video_url=video_url,\n                           ffmpeg_log_output=True)\n>       _, video_fullpath = api.get_video(with_srt=True,\n                                          clean_download=False)\n\nmypy/tests/lib/youtube/test_video_handler.py:26: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nmypy/lib/youtube/video_handler.py:299: in get_video\n    download_video, zh_srt, en_srt = y2_api.download_media(with_srt)\nmypy/lib/youtube/ytdlp_helper.py:206: in download_media\n    self._download_video()\nmypy/lib/youtube/ytdlp_helper.py:152: in _download_video\n    ydl.download([self._video_url])\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3602: in download\n    self.__download_wrapper(self.extract_info)(\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3577: in wrapper\n    res = func(*args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1611: in extract_info\n    return self.__extract_info(url, self.get_info_extractor(key), download, extra_info, process)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1622: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1778: in __extract_info\n    return self.process_ie_result(ie_result, download, extra_info)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1837: in process_ie_result\n    ie_result = self.process_video_result(ie_result, download=download)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3011: in process_video_result\n    self.process_info(new_info)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:179: in wrapper\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:3487: in process_info\n    self.report_error(f'unable to download video data: {err}')\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1088: in report_error\n    self.trouble(f'{self._format_err(\"ERROR:\", self.Styles.ERROR)} {message}', *args, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <yt_dlp.YoutubeDL.YoutubeDL object at 0x7fe054093c70>\nmessage = 'ERROR: unable to download video data: HTTP Error 403: Forbidden'\ntb = None, is_error = True\n\n    def trouble(self, message=None, tb=None, is_error=True):\n        \"\"\"Determine action to take when a download problem appears.\n    \n        Depending on if the downloader has been configured to ignore\n        download errors or not, this method may throw an exception or\n        not when errors are found, after printing the message.\n    \n        @param tb          If given, is additional traceback information\n        @param is_error    Whether to raise error according to ignorerrors\n        \"\"\"\n        if message is not None:\n            self.to_stderr(message)\n        if self.params.get('verbose'):\n            if tb is None:\n                if sys.exc_info()[0]:  # if .trouble has been called from an except block\n                    tb = ''\n                    if hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                        tb += ''.join(traceback.format_exception(*sys.exc_info()[1].exc_info))\n                    tb += encode_compat_str(traceback.format_exc())\n                else:\n                    tb_data = traceback.format_list(traceback.extract_stack())\n                    tb = ''.join(tb_data)\n            if tb:\n                self.to_stderr(tb)\n        if not is_error:\n            return\n        if not self.params.get('ignoreerrors'):\n            if sys.exc_info()[0] and hasattr(sys.exc_info()[1], 'exc_info') and sys.exc_info()[1].exc_info[0]:\n                exc_info = sys.exc_info()[1].exc_info\n            else:\n                exc_info = sys.exc_info()\n>           raise DownloadError(message, exc_info)\nE           yt_dlp.utils.DownloadError: ERROR: unable to download video data: HTTP Error 403: Forbidden\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/yt_dlp/YoutubeDL.py:1027: DownloadError","steps":[],"attachments":[{"uid":"402ac33929d0fe4e","name":"log","source":"402ac33929d0fe4e.txt","type":"text/plain","size":487}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"test_output_dir::0","time":{"start":1720667819144,"stop":1720667819144,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"copy_config_to_dir::finish_callback","time":{"start":1720667819144,"stop":1720667819145,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"tag","value":"youtube"},{"name":"parentSuite","value":"lib.youtube"},{"name":"suite","value":"test_video_handler"},{"name":"host","value":"fv-az1980-950"},{"name":"thread","value":"8966-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"lib.youtube.test_video_handler"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"video_url","value":"'https://www.youtube.com/watch?v=mAxFB3vbt7c'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":["youtube"]},"source":"8fea6a102dcf206b.json","parameterValues":["'https://www.youtube.com/watch?v=mAxFB3vbt7c'"]}