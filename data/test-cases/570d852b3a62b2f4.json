{"uid":"570d852b3a62b2f4","name":"test_y2douyin_once[channel]","fullName":"apps.youtu2douyin.test_youtu2douyin#test_y2douyin_once","historyId":"5e1029e1310b384993810de9c459971e","time":{"start":1726240353386,"stop":1726240367173,"duration":13787},"description":"\n    检测一次 youtube 的频道\n    ","descriptionHtml":"<pre><code>检测一次 youtube 的频道\n</code></pre>\n","status":"broken","statusMessage":"KeyError: 'reelItemRenderer'","statusTrace":"self = []\nraw_json = '{\"responseContext\": {\"serviceTrackingParams\": [{\"service\": \"GFEEDBACK\", \"params\": [{\"key\": \"route\", \"value\": \"channel...l/UCsooa4yRKGN_zEE8iknghZA\"}, {\"hrefUrl\": \"ios-app://544007664/http/youtube.com/channel/UCsooa4yRKGN_zEE8iknghZA\"}]}}}'\n\n    def _extract_videos(self, raw_json: str) -> Tuple[List[str], Optional[str]]:\n        \"\"\"Extracts videos from a raw json page\n    \n        :param str raw_json: Input json extracted from the page or the last\n            server response\n        :rtype: Tuple[List[str], Optional[str]]\n        :returns: Tuple containing a list of up to 100 video watch ids and\n            a continuation token, if more videos are available\n        \"\"\"\n        initial_data = json.loads(raw_json)\n        # this is the json tree structure, if the json was extracted from\n        # html\n        try:\n            # Possible tabs: Home, Videos, Shorts, Live, Playlists, Community, Channels, About\n            active_tab = {}\n            for tab in initial_data[\"contents\"][\"twoColumnBrowseResultsRenderer\"][\"tabs\"]:\n                tab_url = tab[\"tabRenderer\"][\"endpoint\"][\"commandMetadata\"][\"webCommandMetadata\"][\"url\"]\n                if tab_url.rsplit('/', maxsplit=1)[-1] == self.html_url.rsplit('/', maxsplit=1)[-1]:\n                    active_tab = tab\n                    break\n    \n            # This is the json tree structure for videos, shorts and streams\n            videos = active_tab[\"tabRenderer\"][\"content\"][\"richGridRenderer\"][\"contents\"]\n    \n            # This is the json tree structure of visitor data\n            # It is necessary to send the visitorData together with the continuation token\n            self._visitor_data = initial_data[\"responseContext\"][\"webResponseContextExtensionData\"][\n                \"ytConfigData\"][\"visitorData\"]\n    \n        except (KeyError, IndexError, TypeError):\n            try:\n                # this is the json tree structure, if the json was directly sent\n                # by the server in a continuation response\n                important_content = initial_data[1]['response']['onResponseReceivedActions'][\n                    0\n                ]['appendContinuationItemsAction']['continuationItems']\n                videos = important_content\n            except (KeyError, IndexError, TypeError):\n                try:\n                    # this is the json tree structure, if the json was directly sent\n                    # by the server in a continuation response\n                    # no longer a list and no longer has the \"response\" key\n                    important_content = initial_data['onResponseReceivedActions'][0][\n                        'appendContinuationItemsAction']['continuationItems']\n                    videos = important_content\n                except (KeyError, IndexError, TypeError) as p:\n                    logger.info(p)\n                    return [], None\n    \n        try:\n            continuation = videos[-1]['continuationItemRenderer'][\n                'continuationEndpoint'\n            ]['continuationCommand']['token']\n            videos = videos[:-1]\n        except (KeyError, IndexError):\n            # if there is an error, no continuation is available\n            continuation = None\n    \n        # only extract the video ids from the video data\n        videos_url = []\n        try:\n            # Extract id from videos and live\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n>                                 f\"{x['richItemRenderer']['content']['videoRenderer']['videoId']}\")\nE                                 KeyError: 'videoRenderer'\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/channel.py:258: KeyError\n\nDuring handling of the above exception, another exception occurred:\n\ncoll_handler = <class 'mypy.lib.youtube.core.base.YouTubeChannel'>\n\n    @pytest.mark.parametrize('coll_handler',\n                             [YouTubePlaylist, YouTubeChannel],\n                             ids=['playlist', 'channel'])\n    def test_y2douyin_once(coll_handler):\n        \"\"\"\n        检测一次 youtube 的频道\n        \"\"\"\n>       upd_channel_to_latest(\n            record_file_dir=os.path.join(curr_dir, 'config'),\n            coll_handler=coll_handler)\n\nmypy/tests/apps/youtu2douyin/test_youtu2douyin.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nmypy/apps/youtu2douyin/tools.py:111: in upd_channel_to_latest\n    if channel.shorts:\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:89: in __len__\n    self.generate_all()\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:105: in generate_all\n    next_item = next(self.gen)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:296: in videos_generator\n    for url in self.video_urls:\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:71: in __iter__\n    curr_item = self[iter_index]\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:57: in __getitem__\n    next_item = next(self.gen)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:281: in url_generator\n    for page in self._paginate():\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:117: in _paginate\n    videos_urls, continuation = self._extract_videos(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = []\nraw_json = '{\"responseContext\": {\"serviceTrackingParams\": [{\"service\": \"GFEEDBACK\", \"params\": [{\"key\": \"route\", \"value\": \"channel...l/UCsooa4yRKGN_zEE8iknghZA\"}, {\"hrefUrl\": \"ios-app://544007664/http/youtube.com/channel/UCsooa4yRKGN_zEE8iknghZA\"}]}}}'\n\n    def _extract_videos(self, raw_json: str) -> Tuple[List[str], Optional[str]]:\n        \"\"\"Extracts videos from a raw json page\n    \n        :param str raw_json: Input json extracted from the page or the last\n            server response\n        :rtype: Tuple[List[str], Optional[str]]\n        :returns: Tuple containing a list of up to 100 video watch ids and\n            a continuation token, if more videos are available\n        \"\"\"\n        initial_data = json.loads(raw_json)\n        # this is the json tree structure, if the json was extracted from\n        # html\n        try:\n            # Possible tabs: Home, Videos, Shorts, Live, Playlists, Community, Channels, About\n            active_tab = {}\n            for tab in initial_data[\"contents\"][\"twoColumnBrowseResultsRenderer\"][\"tabs\"]:\n                tab_url = tab[\"tabRenderer\"][\"endpoint\"][\"commandMetadata\"][\"webCommandMetadata\"][\"url\"]\n                if tab_url.rsplit('/', maxsplit=1)[-1] == self.html_url.rsplit('/', maxsplit=1)[-1]:\n                    active_tab = tab\n                    break\n    \n            # This is the json tree structure for videos, shorts and streams\n            videos = active_tab[\"tabRenderer\"][\"content\"][\"richGridRenderer\"][\"contents\"]\n    \n            # This is the json tree structure of visitor data\n            # It is necessary to send the visitorData together with the continuation token\n            self._visitor_data = initial_data[\"responseContext\"][\"webResponseContextExtensionData\"][\n                \"ytConfigData\"][\"visitorData\"]\n    \n        except (KeyError, IndexError, TypeError):\n            try:\n                # this is the json tree structure, if the json was directly sent\n                # by the server in a continuation response\n                important_content = initial_data[1]['response']['onResponseReceivedActions'][\n                    0\n                ]['appendContinuationItemsAction']['continuationItems']\n                videos = important_content\n            except (KeyError, IndexError, TypeError):\n                try:\n                    # this is the json tree structure, if the json was directly sent\n                    # by the server in a continuation response\n                    # no longer a list and no longer has the \"response\" key\n                    important_content = initial_data['onResponseReceivedActions'][0][\n                        'appendContinuationItemsAction']['continuationItems']\n                    videos = important_content\n                except (KeyError, IndexError, TypeError) as p:\n                    logger.info(p)\n                    return [], None\n    \n        try:\n            continuation = videos[-1]['continuationItemRenderer'][\n                'continuationEndpoint'\n            ]['continuationCommand']['token']\n            videos = videos[:-1]\n        except (KeyError, IndexError):\n            # if there is an error, no continuation is available\n            continuation = None\n    \n        # only extract the video ids from the video data\n        videos_url = []\n        try:\n            # Extract id from videos and live\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n                                  f\"{x['richItemRenderer']['content']['videoRenderer']['videoId']}\")\n        except (KeyError, IndexError, TypeError):\n            # Extract id from short videos\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n>                                 f\"{x['richItemRenderer']['content']['reelItemRenderer']['videoId']}\")\nE               KeyError: 'reelItemRenderer'\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/channel.py:263: KeyError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"event_loop_policy","time":{"start":1726237832833,"stop":1726237832833,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"copy_config_to_dir","time":{"start":1726240330237,"stop":1726240330238,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"\n    检测一次 youtube 的频道\n    ","status":"broken","statusMessage":"KeyError: 'reelItemRenderer'","statusTrace":"self = []\nraw_json = '{\"responseContext\": {\"serviceTrackingParams\": [{\"service\": \"GFEEDBACK\", \"params\": [{\"key\": \"route\", \"value\": \"channel...l/UCsooa4yRKGN_zEE8iknghZA\"}, {\"hrefUrl\": \"ios-app://544007664/http/youtube.com/channel/UCsooa4yRKGN_zEE8iknghZA\"}]}}}'\n\n    def _extract_videos(self, raw_json: str) -> Tuple[List[str], Optional[str]]:\n        \"\"\"Extracts videos from a raw json page\n    \n        :param str raw_json: Input json extracted from the page or the last\n            server response\n        :rtype: Tuple[List[str], Optional[str]]\n        :returns: Tuple containing a list of up to 100 video watch ids and\n            a continuation token, if more videos are available\n        \"\"\"\n        initial_data = json.loads(raw_json)\n        # this is the json tree structure, if the json was extracted from\n        # html\n        try:\n            # Possible tabs: Home, Videos, Shorts, Live, Playlists, Community, Channels, About\n            active_tab = {}\n            for tab in initial_data[\"contents\"][\"twoColumnBrowseResultsRenderer\"][\"tabs\"]:\n                tab_url = tab[\"tabRenderer\"][\"endpoint\"][\"commandMetadata\"][\"webCommandMetadata\"][\"url\"]\n                if tab_url.rsplit('/', maxsplit=1)[-1] == self.html_url.rsplit('/', maxsplit=1)[-1]:\n                    active_tab = tab\n                    break\n    \n            # This is the json tree structure for videos, shorts and streams\n            videos = active_tab[\"tabRenderer\"][\"content\"][\"richGridRenderer\"][\"contents\"]\n    \n            # This is the json tree structure of visitor data\n            # It is necessary to send the visitorData together with the continuation token\n            self._visitor_data = initial_data[\"responseContext\"][\"webResponseContextExtensionData\"][\n                \"ytConfigData\"][\"visitorData\"]\n    \n        except (KeyError, IndexError, TypeError):\n            try:\n                # this is the json tree structure, if the json was directly sent\n                # by the server in a continuation response\n                important_content = initial_data[1]['response']['onResponseReceivedActions'][\n                    0\n                ]['appendContinuationItemsAction']['continuationItems']\n                videos = important_content\n            except (KeyError, IndexError, TypeError):\n                try:\n                    # this is the json tree structure, if the json was directly sent\n                    # by the server in a continuation response\n                    # no longer a list and no longer has the \"response\" key\n                    important_content = initial_data['onResponseReceivedActions'][0][\n                        'appendContinuationItemsAction']['continuationItems']\n                    videos = important_content\n                except (KeyError, IndexError, TypeError) as p:\n                    logger.info(p)\n                    return [], None\n    \n        try:\n            continuation = videos[-1]['continuationItemRenderer'][\n                'continuationEndpoint'\n            ]['continuationCommand']['token']\n            videos = videos[:-1]\n        except (KeyError, IndexError):\n            # if there is an error, no continuation is available\n            continuation = None\n    \n        # only extract the video ids from the video data\n        videos_url = []\n        try:\n            # Extract id from videos and live\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n>                                 f\"{x['richItemRenderer']['content']['videoRenderer']['videoId']}\")\nE                                 KeyError: 'videoRenderer'\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/channel.py:258: KeyError\n\nDuring handling of the above exception, another exception occurred:\n\ncoll_handler = <class 'mypy.lib.youtube.core.base.YouTubeChannel'>\n\n    @pytest.mark.parametrize('coll_handler',\n                             [YouTubePlaylist, YouTubeChannel],\n                             ids=['playlist', 'channel'])\n    def test_y2douyin_once(coll_handler):\n        \"\"\"\n        检测一次 youtube 的频道\n        \"\"\"\n>       upd_channel_to_latest(\n            record_file_dir=os.path.join(curr_dir, 'config'),\n            coll_handler=coll_handler)\n\nmypy/tests/apps/youtu2douyin/test_youtu2douyin.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nmypy/apps/youtu2douyin/tools.py:111: in upd_channel_to_latest\n    if channel.shorts:\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:89: in __len__\n    self.generate_all()\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:105: in generate_all\n    next_item = next(self.gen)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:296: in videos_generator\n    for url in self.video_urls:\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:71: in __iter__\n    curr_item = self[iter_index]\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/helpers.py:57: in __getitem__\n    next_item = next(self.gen)\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:281: in url_generator\n    for page in self._paginate():\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/playlist.py:117: in _paginate\n    videos_urls, continuation = self._extract_videos(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = []\nraw_json = '{\"responseContext\": {\"serviceTrackingParams\": [{\"service\": \"GFEEDBACK\", \"params\": [{\"key\": \"route\", \"value\": \"channel...l/UCsooa4yRKGN_zEE8iknghZA\"}, {\"hrefUrl\": \"ios-app://544007664/http/youtube.com/channel/UCsooa4yRKGN_zEE8iknghZA\"}]}}}'\n\n    def _extract_videos(self, raw_json: str) -> Tuple[List[str], Optional[str]]:\n        \"\"\"Extracts videos from a raw json page\n    \n        :param str raw_json: Input json extracted from the page or the last\n            server response\n        :rtype: Tuple[List[str], Optional[str]]\n        :returns: Tuple containing a list of up to 100 video watch ids and\n            a continuation token, if more videos are available\n        \"\"\"\n        initial_data = json.loads(raw_json)\n        # this is the json tree structure, if the json was extracted from\n        # html\n        try:\n            # Possible tabs: Home, Videos, Shorts, Live, Playlists, Community, Channels, About\n            active_tab = {}\n            for tab in initial_data[\"contents\"][\"twoColumnBrowseResultsRenderer\"][\"tabs\"]:\n                tab_url = tab[\"tabRenderer\"][\"endpoint\"][\"commandMetadata\"][\"webCommandMetadata\"][\"url\"]\n                if tab_url.rsplit('/', maxsplit=1)[-1] == self.html_url.rsplit('/', maxsplit=1)[-1]:\n                    active_tab = tab\n                    break\n    \n            # This is the json tree structure for videos, shorts and streams\n            videos = active_tab[\"tabRenderer\"][\"content\"][\"richGridRenderer\"][\"contents\"]\n    \n            # This is the json tree structure of visitor data\n            # It is necessary to send the visitorData together with the continuation token\n            self._visitor_data = initial_data[\"responseContext\"][\"webResponseContextExtensionData\"][\n                \"ytConfigData\"][\"visitorData\"]\n    \n        except (KeyError, IndexError, TypeError):\n            try:\n                # this is the json tree structure, if the json was directly sent\n                # by the server in a continuation response\n                important_content = initial_data[1]['response']['onResponseReceivedActions'][\n                    0\n                ]['appendContinuationItemsAction']['continuationItems']\n                videos = important_content\n            except (KeyError, IndexError, TypeError):\n                try:\n                    # this is the json tree structure, if the json was directly sent\n                    # by the server in a continuation response\n                    # no longer a list and no longer has the \"response\" key\n                    important_content = initial_data['onResponseReceivedActions'][0][\n                        'appendContinuationItemsAction']['continuationItems']\n                    videos = important_content\n                except (KeyError, IndexError, TypeError) as p:\n                    logger.info(p)\n                    return [], None\n    \n        try:\n            continuation = videos[-1]['continuationItemRenderer'][\n                'continuationEndpoint'\n            ]['continuationCommand']['token']\n            videos = videos[:-1]\n        except (KeyError, IndexError):\n            # if there is an error, no continuation is available\n            continuation = None\n    \n        # only extract the video ids from the video data\n        videos_url = []\n        try:\n            # Extract id from videos and live\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n                                  f\"{x['richItemRenderer']['content']['videoRenderer']['videoId']}\")\n        except (KeyError, IndexError, TypeError):\n            # Extract id from short videos\n            for x in videos:\n                videos_url.append(f\"/watch?v=\"\n>                                 f\"{x['richItemRenderer']['content']['reelItemRenderer']['videoId']}\")\nE               KeyError: 'reelItemRenderer'\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/pytube/contrib/channel.py:263: KeyError","steps":[],"attachments":[{"uid":"b504613f17854af2","name":"log","source":"b504613f17854af2.txt","type":"text/plain","size":361}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"copy_config_to_dir::finish_callback","time":{"start":1726240367219,"stop":1726240367219,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"tag","value":"app"},{"name":"parentSuite","value":"apps.youtu2douyin"},{"name":"suite","value":"test_youtu2douyin"},{"name":"host","value":"fv-az702-656"},{"name":"thread","value":"9827-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"apps.youtu2douyin.test_youtu2douyin"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"coll_handler","value":"<class 'mypy.lib.youtube.core.base.YouTubeChannel'>"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":["app"]},"source":"570d852b3a62b2f4.json","parameterValues":["<class 'mypy.lib.youtube.core.base.YouTubeChannel'>"]}